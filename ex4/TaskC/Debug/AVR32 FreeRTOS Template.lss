
AVR32 FreeRTOS Template.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002008  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .init         0000001c  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .text         000039ac  80002024  80002024  00002424  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .exception    00000200  80005a00  80005a00  00005e00  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  5 .fini         00000018  80005c00  80005c00  00006000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .rodata       00000160  80005c18  80005c18  00006018  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  8 .ctors        00000008  00000008  80005d78  00006408  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .dtors        00000008  00000010  80005d80  00006410  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 10 .jcr          00000004  00000018  80005d88  00006418  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 11 .got          0000000c  0000001c  80005d8c  0000641c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 12 .data         000005d8  00000028  80005d98  00006428  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 13 .bss          00000430  00000600  00000600  00000000  2**2
                  ALLOC
 14 .heap         0000e5d0  00000a30  00000a30  00000000  2**0
                  ALLOC
 15 .comment      00000030  00000000  00000000  00006a00  2**0
                  CONTENTS, READONLY
 16 .debug_aranges 00000cd8  00000000  00000000  00006a30  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_pubnames 000019df  00000000  00000000  00007708  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_info   00025b87  00000000  00000000  000090e7  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_abbrev 000047c8  00000000  00000000  0002ec6e  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_line   0000e752  00000000  00000000  00033436  2**0
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_frame  00001dac  00000000  00000000  00041b88  2**2
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_str    00007eb6  00000000  00000000  00043934  2**0
                  CONTENTS, READONLY, DEBUGGING
 23 .debug_loc    000043eb  00000000  00000000  0004b7ea  2**0
                  CONTENTS, READONLY, DEBUGGING
 24 .debug_macinfo 014ad94f  00000000  00000000  0004fbd5  2**0
                  CONTENTS, READONLY, DEBUGGING
 25 .stack        00001000  0000f000  0000f000  00000000  2**0
                  ALLOC
 26 .debug_ranges 00000d60  00000000  00000000  014fd524  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:
80002000:	48 1f       	lddpc	pc,80002004 <program_start+0x4>
80002002:	00 00       	add	r0,r0
80002004:	80 00       	ld.sh	r0,r0[0x0]
80002006:	20 24       	sub	r4,2

Disassembly of section .init:

80002008 <_init>:
80002008:	eb cd 40 40 	pushm	r6,lr
8000200c:	48 26       	lddpc	r6,80002014 <_init+0xc>
8000200e:	1e 26       	rsub	r6,pc
80002010:	c0 48       	rjmp	80002018 <_init+0x10>
80002012:	00 00       	add	r0,r0
80002014:	80 00       	ld.sh	r0,r0[0x0]
80002016:	1f f2       	ld.ub	r2,pc[0x7]
80002018:	f0 16 00 01 	mcall	r6[4]
8000201c:	f0 16 00 00 	mcall	r6[0]
80002020:	e3 cd 80 40 	ldm	sp++,r6,pc

Disassembly of section .text:

80002024 <_stext>:
80002024:	30 07       	mov	r7,0
80002026:	49 5a       	lddpc	r10,80002078 <_stext+0x54>
80002028:	5b fa       	cp.w	r10,-1
8000202a:	f4 0d 17 10 	movne	sp,r10
8000202e:	49 4b       	lddpc	r11,8000207c <_stext+0x58>
80002030:	49 4c       	lddpc	r12,80002080 <_stext+0x5c>
80002032:	18 3b       	cp.w	r11,r12
80002034:	c0 60       	breq	80002040 <_stext+0x1c>
80002036:	49 4a       	lddpc	r10,80002084 <_stext+0x60>
80002038:	b7 09       	ld.d	r8,r11++
8000203a:	b9 28       	st.d	r12++,r8
8000203c:	14 3c       	cp.w	r12,r10
8000203e:	cf d5       	brlt	80002038 <_stext+0x14>
80002040:	49 2a       	lddpc	r10,80002088 <_stext+0x64>
80002042:	49 1c       	lddpc	r12,80002084 <_stext+0x60>
80002044:	30 08       	mov	r8,0
80002046:	30 09       	mov	r9,0
80002048:	b9 28       	st.d	r12++,r8
8000204a:	14 3c       	cp.w	r12,r10
8000204c:	cf e5       	brlt	80002048 <_stext+0x24>
8000204e:	f0 1f 00 10 	mcall	8000208c <_stext+0x68>
80002052:	49 0c       	lddpc	r12,80002090 <_stext+0x6c>
80002054:	f0 1f 00 10 	mcall	80002094 <_stext+0x70>
80002058:	f0 1f 00 10 	mcall	80002098 <_stext+0x74>
8000205c:	1a 9c       	mov	r12,sp
8000205e:	30 0b       	mov	r11,0
80002060:	f0 1f 00 0f 	mcall	8000209c <_stext+0x78>
80002064:	5b fc       	cp.w	r12,-1
80002066:	f9 bc 00 00 	moveq	r12,0
8000206a:	f9 ba 00 00 	moveq	r10,0
8000206e:	14 1d       	sub	sp,r10
80002070:	f0 1f 00 0c 	mcall	800020a0 <_stext+0x7c>
80002074:	f0 1f 00 0c 	mcall	800020a4 <_stext+0x80>
80002078:	00 01       	add	r1,r0
8000207a:	00 00       	add	r0,r0
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	5d 78       	*unknown*
80002080:	00 00       	add	r0,r0
80002082:	00 08       	add	r8,r0
80002084:	00 00       	add	r0,r0
80002086:	06 00       	add	r0,r3
80002088:	00 00       	add	r0,r0
8000208a:	0a 30       	cp.w	r0,r5
8000208c:	80 00       	ld.sh	r0,r0[0x0]
8000208e:	42 e8       	lddsp	r8,sp[0xb8]
80002090:	80 00       	ld.sh	r0,r0[0x0]
80002092:	5c 00       	acr	r0
80002094:	80 00       	ld.sh	r0,r0[0x0]
80002096:	4a 08       	lddpc	r8,80002114 <board_init+0x8>
80002098:	80 00       	ld.sh	r0,r0[0x0]
8000209a:	20 08       	sub	r8,0
8000209c:	80 00       	ld.sh	r0,r0[0x0]
8000209e:	50 58       	stdsp	sp[0x14],r8
800020a0:	80 00       	ld.sh	r0,r0[0x0]
800020a2:	49 74       	lddpc	r4,800020fc <frame_dummy+0xc>
800020a4:	80 00       	ld.sh	r0,r0[0x0]
800020a6:	4a 1c       	lddpc	r12,80002128 <board_init+0x1c>

800020a8 <__do_global_dtors_aux>:
800020a8:	d4 21       	pushm	r4-r7,lr
800020aa:	48 e8       	lddpc	r8,800020e0 <__do_global_dtors_aux+0x38>
800020ac:	11 89       	ld.ub	r9,r8[0x0]
800020ae:	30 08       	mov	r8,0
800020b0:	f0 09 18 00 	cp.b	r9,r8
800020b4:	c1 41       	brne	800020dc <__do_global_dtors_aux+0x34>
800020b6:	48 c8       	lddpc	r8,800020e4 <__do_global_dtors_aux+0x3c>
800020b8:	48 c6       	lddpc	r6,800020e8 <__do_global_dtors_aux+0x40>
800020ba:	10 95       	mov	r5,r8
800020bc:	10 16       	sub	r6,r8
800020be:	48 c7       	lddpc	r7,800020ec <__do_global_dtors_aux+0x44>
800020c0:	a3 46       	asr	r6,0x2
800020c2:	20 16       	sub	r6,1
800020c4:	c0 68       	rjmp	800020d0 <__do_global_dtors_aux+0x28>
800020c6:	2f f8       	sub	r8,-1
800020c8:	8f 08       	st.w	r7[0x0],r8
800020ca:	ea 08 03 28 	ld.w	r8,r5[r8<<0x2]
800020ce:	5d 18       	icall	r8
800020d0:	6e 08       	ld.w	r8,r7[0x0]
800020d2:	0c 38       	cp.w	r8,r6
800020d4:	cf 93       	brcs	800020c6 <__do_global_dtors_aux+0x1e>
800020d6:	30 19       	mov	r9,1
800020d8:	48 28       	lddpc	r8,800020e0 <__do_global_dtors_aux+0x38>
800020da:	b0 89       	st.b	r8[0x0],r9
800020dc:	d8 22       	popm	r4-r7,pc
800020de:	00 00       	add	r0,r0
800020e0:	00 00       	add	r0,r0
800020e2:	06 00       	add	r0,r3
800020e4:	00 00       	add	r0,r0
800020e6:	00 10       	sub	r0,r0
800020e8:	00 00       	add	r0,r0
800020ea:	00 14       	sub	r4,r0
800020ec:	00 00       	add	r0,r0
800020ee:	06 04       	add	r4,r3

800020f0 <frame_dummy>:
800020f0:	d4 01       	pushm	lr
800020f2:	48 5c       	lddpc	r12,80002104 <frame_dummy+0x14>
800020f4:	78 08       	ld.w	r8,r12[0x0]
800020f6:	58 08       	cp.w	r8,0
800020f8:	c0 50       	breq	80002102 <frame_dummy+0x12>
800020fa:	48 48       	lddpc	r8,80002108 <frame_dummy+0x18>
800020fc:	58 08       	cp.w	r8,0
800020fe:	c0 20       	breq	80002102 <frame_dummy+0x12>
80002100:	5d 18       	icall	r8
80002102:	d8 02       	popm	pc
80002104:	00 00       	add	r0,r0
80002106:	00 18       	sub	r8,r0
80002108:	00 00       	add	r0,r0
	...

8000210c <board_init>:
#endif



void board_init (void)
{
8000210c:	d4 01       	pushm	lr
    gpio_configure_pin (LED0_GPIO, GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
8000210e:	30 3b       	mov	r11,3
80002110:	32 3c       	mov	r12,35
80002112:	f0 1f 00 0a 	mcall	80002138 <board_init+0x2c>
    gpio_configure_pin (LED1_GPIO, GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
80002116:	30 3b       	mov	r11,3
80002118:	34 9c       	mov	r12,73
8000211a:	f0 1f 00 08 	mcall	80002138 <board_init+0x2c>
    gpio_configure_pin (LED2_GPIO, GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
8000211e:	30 3b       	mov	r11,3
80002120:	32 2c       	mov	r12,34
80002122:	f0 1f 00 06 	mcall	80002138 <board_init+0x2c>
    gpio_configure_pin (LED3_GPIO, GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
80002126:	30 3b       	mov	r11,3
80002128:	32 6c       	mov	r12,38
8000212a:	f0 1f 00 04 	mcall	80002138 <board_init+0x2c>

    gpio_configure_pin (GPIO_PUSH_BUTTON_0, (GPIO_DIR_INPUT | GPIO_PULL_UP));
8000212e:	30 4b       	mov	r11,4
80002130:	32 1c       	mov	r12,33
80002132:	f0 1f 00 02 	mcall	80002138 <board_init+0x2c>
     * the platform Xplained board has configured basic clock settings,
     * GPIO pin mapping, interrupt controller options, etc.
     */
    sensor_board_init ();
#endif
}
80002136:	d8 02       	popm	pc
80002138:	80 00       	ld.sh	r0,r0[0x0]
8000213a:	21 3c       	sub	r12,19

8000213c <gpio_configure_pin>:

#endif

void gpio_configure_pin(uint32_t pin, uint32_t flags)
{  
  volatile avr32_gpio_port_t *gpio_port = &GPIO.port[pin >> 5];  
8000213c:	f8 08 16 05 	lsr	r8,r12,0x5
80002140:	a9 68       	lsl	r8,0x8
80002142:	e0 28 f0 00 	sub	r8,61440
    if (flags & GPIO_PULL_DOWN)
            gpio_port->pders = 1 << (pin & 0x1F);
    else
            gpio_port->pderc = 1 << (pin & 0x1F);
#endif    
    if (flags & GPIO_PULL_UP)
80002146:	16 99       	mov	r9,r11
80002148:	e2 19 00 04 	andl	r9,0x4,COH
8000214c:	c0 70       	breq	8000215a <gpio_configure_pin+0x1e>
            gpio_port->puers = 1 << (pin & 0x1F);
8000214e:	30 19       	mov	r9,1
80002150:	f2 0c 09 49 	lsl	r9,r9,r12
80002154:	f1 49 00 74 	st.w	r8[116],r9
80002158:	c0 68       	rjmp	80002164 <gpio_configure_pin+0x28>
    else
            gpio_port->puerc = 1 << (pin & 0x1F);
8000215a:	30 19       	mov	r9,1
8000215c:	f2 0c 09 49 	lsl	r9,r9,r12
80002160:	f1 49 00 78 	st.w	r8[120],r9
            else
                    gpio_port->odcr1c = 1 << (pin & 0x1F);
#endif

    /* Select interrupt level for group */
    if (flags & GPIO_INTERRUPT) {
80002164:	16 99       	mov	r9,r11
80002166:	e2 19 00 80 	andl	r9,0x80,COH
8000216a:	c2 40       	breq	800021b2 <gpio_configure_pin+0x76>
            if (flags & GPIO_BOTHEDGES)
8000216c:	16 99       	mov	r9,r11
8000216e:	e2 19 01 80 	andl	r9,0x180,COH
80002172:	c0 90       	breq	80002184 <gpio_configure_pin+0x48>
            {
                   gpio_port->imr0c = 1 << (pin & 0x1F);
80002174:	30 19       	mov	r9,1
80002176:	f2 0c 09 49 	lsl	r9,r9,r12
8000217a:	f1 49 00 a8 	st.w	r8[168],r9
                   gpio_port->imr1c = 1 << (pin & 0x1F);
8000217e:	f1 49 00 b8 	st.w	r8[184],r9
80002182:	c1 88       	rjmp	800021b2 <gpio_configure_pin+0x76>
            }
            else if (flags & GPIO_RISING)
80002184:	16 99       	mov	r9,r11
80002186:	e2 19 02 80 	andl	r9,0x280,COH
8000218a:	c0 90       	breq	8000219c <gpio_configure_pin+0x60>
            {
                   gpio_port->imr0s = 1 << (pin & 0x1F);
8000218c:	30 19       	mov	r9,1
8000218e:	f2 0c 09 49 	lsl	r9,r9,r12
80002192:	f1 49 00 a4 	st.w	r8[164],r9
                   gpio_port->imr1c = 1 << (pin & 0x1F);
80002196:	f1 49 00 b8 	st.w	r8[184],r9
8000219a:	c0 c8       	rjmp	800021b2 <gpio_configure_pin+0x76>
            }
            else if (flags & GPIO_FALLING)
8000219c:	16 99       	mov	r9,r11
8000219e:	e2 19 03 80 	andl	r9,0x380,COH
800021a2:	c0 80       	breq	800021b2 <gpio_configure_pin+0x76>
            {
                   gpio_port->imr0c = 1 << (pin & 0x1F);
800021a4:	30 19       	mov	r9,1
800021a6:	f2 0c 09 49 	lsl	r9,r9,r12
800021aa:	f1 49 00 a8 	st.w	r8[168],r9
                   gpio_port->imr1s = 1 << (pin & 0x1F);
800021ae:	f1 49 00 b4 	st.w	r8[180],r9
            }
    }

    /* Select direction and initial pin state */
    if (flags & GPIO_DIR_OUTPUT) {
800021b2:	f3 db c0 01 	bfextu	r9,r11,0x0,0x1
800021b6:	c1 50       	breq	800021e0 <gpio_configure_pin+0xa4>
            if (flags & GPIO_INIT_HIGH)
800021b8:	e2 1b 00 02 	andl	r11,0x2,COH
800021bc:	c0 70       	breq	800021ca <gpio_configure_pin+0x8e>
                    gpio_port->ovrs = 1 << (pin & 0x1F);
800021be:	30 19       	mov	r9,1
800021c0:	f2 0c 09 49 	lsl	r9,r9,r12
800021c4:	f1 49 00 54 	st.w	r8[84],r9
800021c8:	c0 68       	rjmp	800021d4 <gpio_configure_pin+0x98>
            else
                    gpio_port->ovrc = 1 << (pin & 0x1F);
800021ca:	30 19       	mov	r9,1
800021cc:	f2 0c 09 49 	lsl	r9,r9,r12
800021d0:	f1 49 00 58 	st.w	r8[88],r9
            gpio_port->oders = 1 << (pin & 0x1F);
800021d4:	30 19       	mov	r9,1
800021d6:	f2 0c 09 49 	lsl	r9,r9,r12
800021da:	f1 49 00 44 	st.w	r8[68],r9
800021de:	c0 68       	rjmp	800021ea <gpio_configure_pin+0xae>
    } else {
            gpio_port->oderc = 1 << (pin & 0x1F);
800021e0:	30 19       	mov	r9,1
800021e2:	f2 0c 09 49 	lsl	r9,r9,r12
800021e6:	f1 49 00 48 	st.w	r8[72],r9
    }

    /* Enable GPIO */
    gpio_port->gpers = 1 << (pin & 0x1F);
800021ea:	30 19       	mov	r9,1
800021ec:	f2 0c 09 4c 	lsl	r12,r9,r12
800021f0:	91 1c       	st.w	r8[0x4],r12
}
800021f2:	5e fc       	retal	r12

800021f4 <gpio_get_pin_value>:
    gpio_port->gpers = mask;
}

int gpio_get_pin_value(uint32_t pin)
{
  volatile avr32_gpio_port_t *gpio_port = &GPIO.port[pin >> 5];
800021f4:	f8 08 16 05 	lsr	r8,r12,0x5
800021f8:	a9 68       	lsl	r8,0x8
800021fa:	e0 28 f0 00 	sub	r8,61440
  return (gpio_port->pvr >> (pin & 0x1F)) & 1;
800021fe:	71 88       	ld.w	r8,r8[0x60]
80002200:	f0 0c 0a 4c 	lsr	r12,r8,r12
}
80002204:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80002208:	5e fc       	retal	r12

8000220a <gpio_set_pin_high>:
  gpio_port->gpers = 1 << (pin & 0x1F); // The GPIO module controls that pin.
}

void gpio_set_pin_high(uint32_t pin)
{
  volatile avr32_gpio_port_t *gpio_port = &GPIO.port[pin >> 5];
8000220a:	f8 08 16 05 	lsr	r8,r12,0x5
8000220e:	a9 68       	lsl	r8,0x8
80002210:	e0 28 f0 00 	sub	r8,61440
  gpio_port->ovrs  = 1 << (pin & 0x1F); // Value to be driven on the I/O line: 1.
80002214:	30 19       	mov	r9,1
80002216:	f2 0c 09 4c 	lsl	r12,r9,r12
8000221a:	f1 4c 00 54 	st.w	r8[84],r12
}
8000221e:	5e fc       	retal	r12

80002220 <gpio_set_pin_low>:
}


void gpio_set_pin_low(uint32_t pin)
{
  volatile avr32_gpio_port_t *gpio_port = &GPIO.port[pin >> 5];
80002220:	f8 08 16 05 	lsr	r8,r12,0x5
80002224:	a9 68       	lsl	r8,0x8
80002226:	e0 28 f0 00 	sub	r8,61440
  gpio_port->ovrc  = 1 << (pin & 0x1F); // Value to be driven on the I/O line: 0.
8000222a:	30 19       	mov	r9,1
8000222c:	f2 0c 09 4c 	lsl	r12,r9,r12
80002230:	f1 4c 00 58 	st.w	r8[88],r12
}
80002234:	5e fc       	retal	r12

80002236 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80002236:	c0 08       	rjmp	80002236 <_unhandled_interrupt>

80002238 <INTC_register_interrupt>:


void INTC_register_interrupt(__int_handler handler, unsigned int irq, unsigned int int_level)
{
  // Determine the group of the IRQ.
  unsigned int int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80002238:	f6 08 16 05 	lsr	r8,r11,0x5

  // Store in _int_line_handler_table_x the pointer to the interrupt handler, so
  // that _get_interrupt_handler can retrieve it when the interrupt is vectored.
  _int_handler_table[int_grp]._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP] = handler;
8000223c:	48 99       	lddpc	r9,80002260 <INTC_register_interrupt+0x28>
8000223e:	f2 08 00 39 	add	r9,r9,r8<<0x3
80002242:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
80002246:	72 19       	ld.w	r9,r9[0x4]
80002248:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
  // Program the corresponding IPRX register to set the interrupt priority level
  // and the interrupt vector offset that will be fetched by the core interrupt
  // system.
  // NOTE: The _intx functions are intermediate assembly functions between the
  // core interrupt system and the user interrupt handler.
  AVR32_INTC.ipr[int_grp] = ipr_val[int_level & (AVR32_INTC_IPR_INTLEVEL_MASK >> AVR32_INTC_IPR_INTLEVEL_OFFSET)];
8000224c:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
80002250:	48 59       	lddpc	r9,80002264 <INTC_register_interrupt+0x2c>
80002252:	f2 0a 03 2a 	ld.w	r10,r9[r10<<0x2]
80002256:	fe 79 08 00 	mov	r9,-63488
8000225a:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
}
8000225e:	5e fc       	retal	r12
80002260:	80 00       	ld.sh	r0,r0[0x0]
80002262:	5c 18       	scr	r8
80002264:	80 00       	ld.sh	r0,r0[0x0]
80002266:	5b 3c       	cp.w	r12,-13

80002268 <INTC_init_interrupts>:
{
  Set_system_register(AVR32_EVBA, (int)&_evba );
}

void INTC_init_interrupts(void)
{
80002268:	d4 21       	pushm	r4-r7,lr
}

//! Init EVBA address. This sequence might also be done in the utils/startup/startup_uc3.S file.
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int)&_evba );
8000226a:	49 18       	lddpc	r8,800022ac <INTC_init_interrupts+0x44>
8000226c:	e3 b8 00 01 	mtsr	0x4,r8
80002270:	49 0e       	lddpc	lr,800022b0 <INTC_init_interrupts+0x48>
80002272:	30 07       	mov	r7,0
80002274:	0e 94       	mov	r4,r7
  {
    // For all interrupt request lines of each group,
    for (int_req = 0; int_req < _int_handler_table[int_grp].num_irqs; int_req++)
    {
      // Assign _unhandled_interrupt as default interrupt handler.
      _int_handler_table[int_grp]._int_line_handler_table[int_req] = &_unhandled_interrupt;
80002276:	49 0c       	lddpc	r12,800022b4 <INTC_init_interrupts+0x4c>
    }

    // Set the interrupt group priority register to its default value.
    // By default, all interrupt groups are linked to the interrupt priority
    // level 0 and to the interrupt vector _int0.
    AVR32_INTC.ipr[int_grp] = ipr_val[AVR32_INTC_INT0];
80002278:	49 08       	lddpc	r8,800022b8 <INTC_init_interrupts+0x50>
8000227a:	70 05       	ld.w	r5,r8[0x0]
8000227c:	fe 76 08 00 	mov	r6,-63488
80002280:	c1 08       	rjmp	800022a0 <INTC_init_interrupts+0x38>
}

//! Init EVBA address. This sequence might also be done in the utils/startup/startup_uc3.S file.
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int)&_evba );
80002282:	08 98       	mov	r8,r4
  {
    // For all interrupt request lines of each group,
    for (int_req = 0; int_req < _int_handler_table[int_grp].num_irqs; int_req++)
    {
      // Assign _unhandled_interrupt as default interrupt handler.
      _int_handler_table[int_grp]._int_line_handler_table[int_req] = &_unhandled_interrupt;
80002284:	7c 1b       	ld.w	r11,lr[0x4]

  // For all interrupt groups,
  for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
  {
    // For all interrupt request lines of each group,
    for (int_req = 0; int_req < _int_handler_table[int_grp].num_irqs; int_req++)
80002286:	7c 0a       	ld.w	r10,lr[0x0]
    {
      // Assign _unhandled_interrupt as default interrupt handler.
      _int_handler_table[int_grp]._int_line_handler_table[int_req] = &_unhandled_interrupt;
80002288:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12

  // For all interrupt groups,
  for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
  {
    // For all interrupt request lines of each group,
    for (int_req = 0; int_req < _int_handler_table[int_grp].num_irqs; int_req++)
8000228c:	2f f8       	sub	r8,-1
8000228e:	10 3a       	cp.w	r10,r8
80002290:	fe 9b ff fc 	brhi	80002288 <INTC_init_interrupts+0x20>
    }

    // Set the interrupt group priority register to its default value.
    // By default, all interrupt groups are linked to the interrupt priority
    // level 0 and to the interrupt vector _int0.
    AVR32_INTC.ipr[int_grp] = ipr_val[AVR32_INTC_INT0];
80002294:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
  unsigned int int_grp, int_req;

  INTC_init_evba();

  // For all interrupt groups,
  for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80002298:	2f f7       	sub	r7,-1
8000229a:	2f 8e       	sub	lr,-8
8000229c:	59 e7       	cp.w	r7,30
8000229e:	c0 50       	breq	800022a8 <INTC_init_interrupts+0x40>
  {
    // For all interrupt request lines of each group,
    for (int_req = 0; int_req < _int_handler_table[int_grp].num_irqs; int_req++)
800022a0:	7c 08       	ld.w	r8,lr[0x0]
800022a2:	58 08       	cp.w	r8,0
800022a4:	ce f1       	brne	80002282 <INTC_init_interrupts+0x1a>
800022a6:	cf 7b       	rjmp	80002294 <INTC_init_interrupts+0x2c>
800022a8:	d8 22       	popm	r4-r7,pc
800022aa:	00 00       	add	r0,r0
800022ac:	80 00       	ld.sh	r0,r0[0x0]
800022ae:	5a 00       	cp.w	r0,-32
800022b0:	80 00       	ld.sh	r0,r0[0x0]
800022b2:	5c 18       	scr	r8
800022b4:	80 00       	ld.sh	r0,r0[0x0]
800022b6:	22 36       	sub	r6,35
800022b8:	80 00       	ld.sh	r0,r0[0x0]
800022ba:	5b 3c       	cp.w	r12,-13

800022bc <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(unsigned int int_level)
{
  // ICR3 is mapped first, ICR0 last.
  // Code in exception.S puts int_level in R12 which is used by AVR32-GCC to
  // pass a single argument to a function.
  unsigned int int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
800022bc:	fe 78 08 00 	mov	r8,-63488
800022c0:	e0 69 00 83 	mov	r9,131
800022c4:	f2 0c 01 0c 	sub	r12,r9,r12
800022c8:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
  unsigned int int_req = AVR32_INTC.irr[int_grp];
800022cc:	f2 ca ff c0 	sub	r10,r9,-64
800022d0:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
  // exception.S will provide the interrupt handler with a clean interrupt stack
  // frame, with nothing more pushed onto the stack. The interrupt handler must
  // manage the `rete' instruction, what can be done thanks to pure assembly,
  // inline assembly or the `__attribute__((__interrupt__))' C function
  // attribute.
  return (int_req) ? _int_handler_table[int_grp]._int_line_handler_table[32 - clz(int_req) - 1] : NULL;
800022d4:	58 08       	cp.w	r8,0
800022d6:	c0 21       	brne	800022da <_get_interrupt_handler+0x1e>
800022d8:	5e fd       	retal	0
800022da:	f0 08 12 00 	clz	r8,r8
800022de:	48 5a       	lddpc	r10,800022f0 <_get_interrupt_handler+0x34>
800022e0:	f4 09 00 39 	add	r9,r10,r9<<0x3
800022e4:	f0 08 11 1f 	rsub	r8,r8,31
800022e8:	72 19       	ld.w	r9,r9[0x4]
800022ea:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
}
800022ee:	5e fc       	retal	r12
800022f0:	80 00       	ld.sh	r0,r0[0x0]
800022f2:	5c 18       	scr	r8

800022f4 <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
800022f4:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
800022f6:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
800022fa:	99 a8       	st.w	r12[0x28],r8
}
800022fc:	5e fc       	retal	r12
800022fe:	d7 03       	nop

80002300 <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
80002300:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
80002302:	ec 5b bb 9f 	cp.w	r11,899999
80002306:	e0 8b 00 04 	brhi	8000230e <pm_enable_osc0_crystal+0xe>
8000230a:	30 4b       	mov	r11,4
8000230c:	c1 38       	rjmp	80002332 <pm_enable_osc0_crystal+0x32>
8000230e:	e0 68 c6 bf 	mov	r8,50879
80002312:	ea 18 00 2d 	orh	r8,0x2d
80002316:	10 3b       	cp.w	r11,r8
80002318:	e0 8b 00 04 	brhi	80002320 <pm_enable_osc0_crystal+0x20>
8000231c:	30 5b       	mov	r11,5
8000231e:	c0 a8       	rjmp	80002332 <pm_enable_osc0_crystal+0x32>
80002320:	e0 68 12 00 	mov	r8,4608
80002324:	ea 18 00 7a 	orh	r8,0x7a
80002328:	10 3b       	cp.w	r11,r8
8000232a:	f9 bb 03 06 	movlo	r11,6
8000232e:	f9 bb 02 07 	movhs	r11,7
80002332:	f0 1f 00 02 	mcall	80002338 <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
80002336:	d8 02       	popm	pc
80002338:	80 00       	ld.sh	r0,r0[0x0]
8000233a:	22 f4       	sub	r4,47

8000233c <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
8000233c:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
8000233e:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80002342:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
80002344:	78 08       	ld.w	r8,r12[0x0]
80002346:	a3 a8       	sbr	r8,0x2
80002348:	99 08       	st.w	r12[0x0],r8
}
8000234a:	5e fc       	retal	r12

8000234c <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
8000234c:	79 58       	ld.w	r8,r12[0x54]
8000234e:	e2 18 00 80 	andl	r8,0x80,COH
80002352:	cf d0       	breq	8000234c <pm_wait_for_clk0_ready>
}
80002354:	5e fc       	retal	r12
80002356:	d7 03       	nop

80002358 <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
80002358:	eb cd 40 80 	pushm	r7,lr
8000235c:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
8000235e:	f0 1f 00 04 	mcall	8000236c <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
80002362:	0e 9c       	mov	r12,r7
80002364:	f0 1f 00 03 	mcall	80002370 <pm_enable_clk0+0x18>
}
80002368:	e3 cd 80 80 	ldm	sp++,r7,pc
8000236c:	80 00       	ld.sh	r0,r0[0x0]
8000236e:	23 3c       	sub	r12,51
80002370:	80 00       	ld.sh	r0,r0[0x0]
80002372:	23 4c       	sub	r12,52

80002374 <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
80002374:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
80002376:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
8000237a:	99 08       	st.w	r12[0x0],r8
}
8000237c:	5e fc       	retal	r12
8000237e:	d7 03       	nop

80002380 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
80002380:	eb cd 40 c0 	pushm	r6-r7,lr
80002384:	18 97       	mov	r7,r12
80002386:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
80002388:	f0 1f 00 06 	mcall	800023a0 <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
8000238c:	0c 9b       	mov	r11,r6
8000238e:	0e 9c       	mov	r12,r7
80002390:	f0 1f 00 05 	mcall	800023a4 <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
80002394:	30 1b       	mov	r11,1
80002396:	0e 9c       	mov	r12,r7
80002398:	f0 1f 00 04 	mcall	800023a8 <pm_switch_to_osc0+0x28>
}
8000239c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800023a0:	80 00       	ld.sh	r0,r0[0x0]
800023a2:	23 00       	sub	r0,48
800023a4:	80 00       	ld.sh	r0,r0[0x0]
800023a6:	23 58       	sub	r8,53
800023a8:	80 00       	ld.sh	r0,r0[0x0]
800023aa:	23 74       	sub	r4,55

800023ac <pcl_switch_to_osc>:
        return PASS;
}
#endif // UC3C device-specific implementation

long int pcl_switch_to_osc(pcl_osc_t osc, unsigned int fcrystal, unsigned int startup)
{
800023ac:	d4 01       	pushm	lr
#ifndef AVR32_PM_VERSION_RESETVALUE
// Implementation for UC3A, UC3A3, UC3B parts.
  if(PCL_OSC0 == osc)
800023ae:	58 0c       	cp.w	r12,0
800023b0:	c0 40       	breq	800023b8 <pcl_switch_to_osc+0xc>
800023b2:	fe 7c d8 f0 	mov	r12,-10000
800023b6:	d8 02       	popm	pc
  {
    // Configure OSC0 in crystal mode, external crystal with a FOSC0 Hz frequency,
    // enable the OSC0, set the main clock source as being OSC0.
    pm_switch_to_osc0(&AVR32_PM, fcrystal, startup);
800023b8:	fe 7c 0c 00 	mov	r12,-62464
800023bc:	f0 1f 00 02 	mcall	800023c4 <pcl_switch_to_osc+0x18>
800023c0:	d8 0a       	popm	pc,r12=0
800023c2:	00 00       	add	r0,r0
800023c4:	80 00       	ld.sh	r0,r0[0x0]
800023c6:	23 80       	sub	r0,56

800023c8 <udd_include_vbus_monitoring>:


bool udd_include_vbus_monitoring(void)
{
	return true;
}
800023c8:	5e ff       	retal	1

800023ca <udd_is_high_speed>:
#ifdef USB_DEVICE_HS_SUPPORT
	return !Is_udd_full_speed_mode();
#else
	return false;
#endif
}
800023ca:	5e fd       	retal	0

800023cc <udd_set_address>:


void udd_set_address(uint8_t address)
{
	udd_disable_address();
800023cc:	fe 68 00 00 	mov	r8,-131072
800023d0:	70 09       	ld.w	r9,r8[0x0]
800023d2:	a7 d9       	cbr	r9,0x7
800023d4:	91 09       	st.w	r8[0x0],r9
	udd_configure_address(address);
800023d6:	70 09       	ld.w	r9,r8[0x0]
800023d8:	f9 dc c0 07 	bfextu	r12,r12,0x0,0x7
800023dc:	e0 19 ff 80 	andl	r9,0xff80
800023e0:	f9 e9 10 09 	or	r9,r12,r9
800023e4:	91 09       	st.w	r8[0x0],r9
	udd_enable_address();
800023e6:	70 09       	ld.w	r9,r8[0x0]
800023e8:	a7 b9       	sbr	r9,0x7
800023ea:	91 09       	st.w	r8[0x0],r9
}
800023ec:	5e fc       	retal	r12

800023ee <udd_getaddress>:


uint8_t udd_getaddress(void)
{
	return udd_get_configured_address();
800023ee:	fe 68 00 00 	mov	r8,-131072
800023f2:	70 0c       	ld.w	r12,r8[0x0]
}
800023f4:	f9 dc c0 07 	bfextu	r12,r12,0x0,0x7
800023f8:	5e fc       	retal	r12

800023fa <udd_get_frame_number>:


uint16_t udd_get_frame_number(void)
{
	return udd_frame_number();
800023fa:	fe 68 00 00 	mov	r8,-131072
800023fe:	70 8c       	ld.w	r12,r8[0x20]
}
80002400:	f9 dc c0 6b 	bfextu	r12,r12,0x3,0xb
80002404:	5e fc       	retal	r12

80002406 <udd_get_micro_frame_number>:

uint16_t udd_get_micro_frame_number(void)
{
	return udd_micro_frame_number();
80002406:	fe 68 00 00 	mov	r8,-131072
8000240a:	70 8c       	ld.w	r12,r8[0x20]
}
8000240c:	f9 dc c0 0e 	bfextu	r12,r12,0x0,0xe
80002410:	5e fc       	retal	r12
80002412:	d7 03       	nop

80002414 <udd_set_setup_payload>:
}


void udd_set_setup_payload( uint8_t *payload,	uint16_t payload_size )
{
	udd_g_ctrlreq.payload = payload;
80002414:	48 28       	lddpc	r8,8000241c <udd_set_setup_payload+0x8>
80002416:	91 2c       	st.w	r8[0x8],r12
	udd_g_ctrlreq.payload_size = payload_size;
80002418:	b0 6b       	st.h	r8[0xc],r11
}
8000241a:	5e fc       	retal	r12
8000241c:	00 00       	add	r0,r0
8000241e:	0a 00       	add	r0,r5

80002420 <udd_ep_is_halted>:
}


bool udd_ep_is_halted(udd_ep_id_t ep)
{
	return Is_udd_endpoint_stall_requested(ep & USB_EP_ADDR_MASK);
80002420:	f1 dc c0 04 	bfextu	r8,r12,0x0,0x4
80002424:	a3 68       	lsl	r8,0x2
80002426:	e0 38 fe 40 	sub	r8,130624
8000242a:	70 0c       	ld.w	r12,r8[0x0]
}
8000242c:	f9 dc c2 61 	bfextu	r12,r12,0x13,0x1
80002430:	5e fc       	retal	r12
80002432:	d7 03       	nop

80002434 <udd_ep_set_halt>:


bool udd_ep_set_halt(udd_ep_id_t ep)
{
	udd_ep_job_t *ptr_job;
	uint8_t index = ep & USB_EP_ADDR_MASK;
80002434:	f9 dc c0 04 	bfextu	r12,r12,0x0,0x4

	if (USB_DEVICE_MAX_EP < index)
80002438:	30 38       	mov	r8,3
8000243a:	f0 0c 18 00 	cp.b	r12,r8
8000243e:	e0 8b 00 35 	brhi	800024a8 <udd_ep_set_halt+0x74>
		return false;

	ptr_job = &udd_ep_job[index - 1];
80002442:	18 99       	mov	r9,r12
80002444:	f8 c8 00 01 	sub	r8,r12,1
80002448:	a5 68       	lsl	r8,0x4
8000244a:	49 9a       	lddpc	r10,800024ac <udd_ep_set_halt+0x78>
8000244c:	f4 08 00 08 	add	r8,r10,r8
	if (ptr_job->busy == true) {
80002450:	70 0a       	ld.w	r10,r8[0x0]
80002452:	58 0a       	cp.w	r10,0
80002454:	c2 a5       	brlt	800024a8 <udd_ep_set_halt+0x74>
		return false;	// Job on going, stall impossible
	}
	
	if (0 != udd_nb_busy_bank(index)) {
80002456:	a3 69       	lsl	r9,0x2
80002458:	fe 6b 01 30 	mov	r11,-130768
8000245c:	f2 0b 00 0a 	add	r10,r9,r11
80002460:	74 0a       	ld.w	r10,r10[0x0]
80002462:	f5 da c1 82 	bfextu	r10,r10,0xc,0x2
80002466:	c1 10       	breq	80002488 <udd_ep_set_halt+0x54>
		// Wait end of transfer on USB line before stall endpoint
		// Flag a stall requested
		ptr_job->stall_requested = true;
80002468:	70 0b       	ld.w	r11,r8[0x0]
8000246a:	30 1a       	mov	r10,1
8000246c:	f7 da d3 81 	bfins	r11,r10,0x1c,0x1
80002470:	91 0b       	st.w	r8[0x0],r11
		udd_enable_bank_interrupt(index);
80002472:	e0 39 fe 10 	sub	r9,130576
80002476:	e0 68 10 00 	mov	r8,4096
8000247a:	93 08       	st.w	r9[0x0],r8
		udd_enable_endpoint_interrupt(index);
8000247c:	f0 0c 09 4c 	lsl	r12,r8,r12
80002480:	fe 69 00 00 	mov	r9,-131072
80002484:	93 6c       	st.w	r9[0x18],r12
80002486:	5e fa       	retal	r10
	} else {
		// Stall endpoint
		udd_disable_endpoint_bank_autoswitch(index);
80002488:	fe 6a 01 00 	mov	r10,-130816
8000248c:	f2 0a 00 08 	add	r8,r9,r10
80002490:	70 0a       	ld.w	r10,r8[0x0]
80002492:	a9 da       	cbr	r10,0x9
80002494:	91 0a       	st.w	r8[0x0],r10
		udd_enable_stall_handshake(index);
80002496:	e0 39 fe 10 	sub	r9,130576
8000249a:	e8 68 00 00 	mov	r8,524288
8000249e:	93 08       	st.w	r9[0x0],r8
		udd_reset_data_toggle(index);
800024a0:	e4 68 00 00 	mov	r8,262144
800024a4:	93 08       	st.w	r9[0x0],r8
800024a6:	5e ff       	retal	1
800024a8:	5e fd       	retal	0
800024aa:	00 00       	add	r0,r0
800024ac:	00 00       	add	r0,r0
800024ae:	07 18       	ld.sh	r8,r3++

800024b0 <udd_ep_clear_halt>:
	return true;
}


bool udd_ep_clear_halt(udd_ep_id_t ep)
{
800024b0:	d4 01       	pushm	lr
	udd_ep_job_t *ptr_job;

	ep &= USB_EP_ADDR_MASK;
800024b2:	f9 dc c0 04 	bfextu	r12,r12,0x0,0x4
	if (USB_DEVICE_MAX_EP < ep)
800024b6:	30 38       	mov	r8,3
800024b8:	f0 0c 18 00 	cp.b	r12,r8
800024bc:	e0 88 00 03 	brls	800024c2 <udd_ep_clear_halt+0x12>
800024c0:	d8 0a       	popm	pc,r12=0
		return false;
	ptr_job = &udd_ep_job[ep - 1];
800024c2:	f8 c8 00 01 	sub	r8,r12,1
800024c6:	a5 68       	lsl	r8,0x4
800024c8:	49 69       	lddpc	r9,80002520 <udd_ep_clear_halt+0x70>
800024ca:	f2 08 00 08 	add	r8,r9,r8

	if (Is_udd_endpoint_stall_requested(ep)	// Endpoint stalled
800024ce:	a3 6c       	lsl	r12,0x2
800024d0:	fe 6a 01 c0 	mov	r10,-130624
800024d4:	f8 0a 00 09 	add	r9,r12,r10
800024d8:	72 09       	ld.w	r9,r9[0x0]
800024da:	e6 19 00 08 	andh	r9,0x8,COH
800024de:	c0 51       	brne	800024e8 <udd_ep_clear_halt+0x38>
			|| ptr_job->stall_requested) {	// Endpoint stall is requested
800024e0:	70 09       	ld.w	r9,r8[0x0]
800024e2:	e6 19 10 00 	andh	r9,0x1000,COH
800024e6:	c1 c0       	breq	8000251e <udd_ep_clear_halt+0x6e>
		// Remove request to stall
		ptr_job->stall_requested = false;
800024e8:	70 09       	ld.w	r9,r8[0x0]
800024ea:	30 0a       	mov	r10,0
800024ec:	f3 da d3 81 	bfins	r9,r10,0x1c,0x1
800024f0:	91 09       	st.w	r8[0x0],r9
		// Remove stall
		udd_disable_stall_handshake(ep);
800024f2:	fe 6a 02 20 	mov	r10,-130528
800024f6:	f8 0a 00 09 	add	r9,r12,r10
800024fa:	e8 6a 00 00 	mov	r10,524288
800024fe:	93 0a       	st.w	r9[0x0],r10
		udd_enable_endpoint_bank_autoswitch(ep);	
80002500:	e0 3c ff 00 	sub	r12,130816
80002504:	78 09       	ld.w	r9,r12[0x0]
80002506:	a9 b9       	sbr	r9,0x9
80002508:	99 09       	st.w	r12[0x0],r9
		// If a job is register on clear halt action
		// then execute callback
		if (ptr_job->busy == true) {
8000250a:	70 09       	ld.w	r9,r8[0x0]
8000250c:	58 09       	cp.w	r9,0
8000250e:	c0 84       	brge	8000251e <udd_ep_clear_halt+0x6e>
			ptr_job->busy = false;
80002510:	30 0a       	mov	r10,0
80002512:	f3 da d3 e1 	bfins	r9,r10,0x1f,0x1
80002516:	91 09       	st.w	r8[0x0],r9
			ptr_job->call_nohalt();
80002518:	70 38       	ld.w	r8,r8[0xc]
8000251a:	5d 18       	icall	r8
8000251c:	da 0a       	popm	pc,r12=1
8000251e:	da 0a       	popm	pc,r12=1
80002520:	00 00       	add	r0,r0
80002522:	07 18       	ld.sh	r8,r3++

80002524 <udd_ctrl_stall_data>:


static void udd_ctrl_stall_data(void)
{
	// Stall all packets on IN & OUT control endpoint
	udd_ep_control_state = UDD_EPCTRL_STALL_REQ;
80002524:	30 59       	mov	r9,5
80002526:	48 58       	lddpc	r8,80002538 <udd_ctrl_stall_data+0x14>
80002528:	91 09       	st.w	r8[0x0],r9
	udd_enable_stall_handshake(0);
8000252a:	e8 69 00 00 	mov	r9,524288
8000252e:	fe 68 01 f0 	mov	r8,-130576
80002532:	91 09       	st.w	r8[0x0],r9
}
80002534:	5e fc       	retal	r12
80002536:	00 00       	add	r0,r0
80002538:	00 00       	add	r0,r0
8000253a:	07 4c       	ld.w	r12,--r3

8000253c <udd_ctrl_endofrequest>:
	cpu_irq_restore(flags);
}


static void udd_ctrl_endofrequest(void)
{
8000253c:	d4 01       	pushm	lr
	// If a callback is registered then call it
	if (udd_g_ctrlreq.callback) {
8000253e:	48 48       	lddpc	r8,8000254c <udd_ctrl_endofrequest+0x10>
80002540:	70 48       	ld.w	r8,r8[0x10]
80002542:	58 08       	cp.w	r8,0
80002544:	c0 20       	breq	80002548 <udd_ctrl_endofrequest+0xc>
		udd_g_ctrlreq.callback();
80002546:	5d 18       	icall	r8
80002548:	d8 02       	popm	pc
8000254a:	00 00       	add	r0,r0
8000254c:	00 00       	add	r0,r0
8000254e:	0a 00       	add	r0,r5

80002550 <udd_ep_finish_job>:
	udd_ep_finish_job(&udd_ep_job[ep - 1], true);
}


static void udd_ep_finish_job(udd_ep_job_t * ptr_job, bool b_abort)
{
80002550:	d4 01       	pushm	lr
80002552:	16 99       	mov	r9,r11
	if (ptr_job->busy == false)
80002554:	78 08       	ld.w	r8,r12[0x0]
80002556:	58 08       	cp.w	r8,0
80002558:	c0 b4       	brge	8000256e <udd_ep_finish_job+0x1e>
		return;	// No on-going job
	ptr_job->busy = false;
8000255a:	30 0a       	mov	r10,0
8000255c:	f1 da d3 e1 	bfins	r8,r10,0x1f,0x1
80002560:	99 08       	st.w	r12[0x0],r8
	if (NULL == ptr_job->call_trans)
80002562:	78 38       	ld.w	r8,r12[0xc]
80002564:	58 08       	cp.w	r8,0
80002566:	c0 40       	breq	8000256e <udd_ep_finish_job+0x1e>
		return;	// No callback linked to job
	ptr_job->call_trans((b_abort) ? UDD_EP_TRANSFER_ABORT :
80002568:	78 2b       	ld.w	r11,r12[0x8]
8000256a:	12 9c       	mov	r12,r9
8000256c:	5d 18       	icall	r8
8000256e:	d8 02       	popm	pc

80002570 <udd_ep_abort_job>:
	}
}


static void udd_ep_abort_job(udd_ep_id_t ep)
{
80002570:	d4 01       	pushm	lr
	ep &= USB_EP_ADDR_MASK;
	// Abort job on endpoint
	udd_ep_finish_job(&udd_ep_job[ep - 1], true);
80002572:	f1 dc c0 04 	bfextu	r8,r12,0x0,0x4
80002576:	20 18       	sub	r8,1
80002578:	a5 68       	lsl	r8,0x4
8000257a:	30 1b       	mov	r11,1
8000257c:	48 3c       	lddpc	r12,80002588 <udd_ep_abort_job+0x18>
8000257e:	10 0c       	add	r12,r8
80002580:	f0 1f 00 03 	mcall	8000258c <udd_ep_abort_job+0x1c>
}
80002584:	d8 02       	popm	pc
80002586:	00 00       	add	r0,r0
80002588:	00 00       	add	r0,r0
8000258a:	07 18       	ld.sh	r8,r3++
8000258c:	80 00       	ld.sh	r0,r0[0x0]
8000258e:	25 50       	sub	r0,85

80002590 <udd_ep_free>:
	return true;
}


void udd_ep_free(udd_ep_id_t ep)
{
80002590:	d4 01       	pushm	lr
	udd_disable_endpoint(ep & USB_EP_ADDR_MASK);
80002592:	fe 69 00 00 	mov	r9,-131072
80002596:	72 7b       	ld.w	r11,r9[0x1c]
80002598:	f1 dc c0 04 	bfextu	r8,r12,0x0,0x4
8000259c:	30 1a       	mov	r10,1
8000259e:	f4 08 09 4a 	lsl	r10,r10,r8
800025a2:	5c da       	com	r10
800025a4:	16 6a       	and	r10,r11
800025a6:	93 7a       	st.w	r9[0x1c],r10
	udd_unallocate_memory(ep & USB_EP_ADDR_MASK);
800025a8:	a3 68       	lsl	r8,0x2
800025aa:	e0 38 ff 00 	sub	r8,130816
800025ae:	70 09       	ld.w	r9,r8[0x0]
800025b0:	a1 d9       	cbr	r9,0x1
800025b2:	91 09       	st.w	r8[0x0],r9
	udd_ep_abort_job(ep);
800025b4:	f0 1f 00 02 	mcall	800025bc <udd_ep_free+0x2c>
}
800025b8:	d8 02       	popm	pc
800025ba:	00 00       	add	r0,r0
800025bc:	80 00       	ld.sh	r0,r0[0x0]
800025be:	25 70       	sub	r0,87

800025c0 <udd_ep_run>:


bool udd_ep_run(udd_ep_id_t ep, bool b_shortpacket,
		uint8_t * buf, iram_size_t buf_size,
		udd_callback_trans_t callback)
{
800025c0:	eb cd 40 fc 	pushm	r2-r7,lr
	uint32_t udd_dma_ctrl = 0;
	udd_ep_job_t *ptr_job;
	irqflags_t flags;

	b_dir_in = (USB_EP_DIR_IN == (ep & USB_EP_DIR_IN));
	ep &= USB_EP_ADDR_MASK;
800025c4:	fd dc c0 04 	bfextu	lr,r12,0x0,0x4
	if (USB_DEVICE_MAX_EP < ep)
800025c8:	30 37       	mov	r7,3
800025ca:	ee 0e 18 00 	cp.b	lr,r7
800025ce:	e0 8b 00 99 	brhi	80002700 <udd_ep_run+0x140>
		return false;

	// Get job about endpoint
	ptr_job = &udd_ep_job[ep - 1];

	if ((!Is_udd_endpoint_enabled(ep))
800025d2:	fe 67 00 00 	mov	r7,-131072
800025d6:	6e 76       	ld.w	r6,r7[0x1c]
800025d8:	1c 95       	mov	r5,lr
800025da:	30 17       	mov	r7,1
800025dc:	ee 0e 09 47 	lsl	r7,r7,lr
800025e0:	0c 67       	and	r7,r6
800025e2:	e0 80 00 8f 	breq	80002700 <udd_ep_run+0x140>
			|| Is_udd_endpoint_stall_requested(ep)
800025e6:	fc 06 15 02 	lsl	r6,lr,0x2
800025ea:	fe 64 01 c0 	mov	r4,-130624
800025ee:	ec 04 00 07 	add	r7,r6,r4
800025f2:	6e 07       	ld.w	r7,r7[0x0]
		return false;

	// Get job about endpoint
	ptr_job = &udd_ep_job[ep - 1];

	if ((!Is_udd_endpoint_enabled(ep))
800025f4:	e6 17 00 08 	andh	r7,0x8,COH
800025f8:	e0 81 00 84 	brne	80002700 <udd_ep_run+0x140>
	ep &= USB_EP_ADDR_MASK;
	if (USB_DEVICE_MAX_EP < ep)
		return false;

	// Get job about endpoint
	ptr_job = &udd_ep_job[ep - 1];
800025fc:	fc c7 00 01 	sub	r7,lr,1
80002600:	a5 67       	lsl	r7,0x4
80002602:	4c 14       	lddpc	r4,80002704 <udd_ep_run+0x144>
80002604:	e8 07 00 07 	add	r7,r4,r7

	if ((!Is_udd_endpoint_enabled(ep))
			|| Is_udd_endpoint_stall_requested(ep)
			|| ptr_job->stall_requested)
80002608:	6e 04       	ld.w	r4,r7[0x0]
8000260a:	e6 14 10 00 	andh	r4,0x1000,COH
8000260e:	c7 91       	brne	80002700 <udd_ep_run+0x140>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002610:	e1 b4 00 00 	mfsr	r4,0x0
	cpu_irq_disable();
80002614:	d3 03       	ssrf	0x10
		return false;	// Endpoint is halted

	flags = cpu_irq_save();
	if (ptr_job->busy == true) {
80002616:	6e 03       	ld.w	r3,r7[0x0]
80002618:	58 03       	cp.w	r3,0
8000261a:	c0 54       	brge	80002624 <udd_ep_run+0x64>
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
8000261c:	e3 b4 00 00 	mtsr	0x0,r4
#endif
	barrier();
80002620:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
	bool b_dir_in;
	uint32_t udd_dma_ctrl = 0;
	udd_ep_job_t *ptr_job;
	irqflags_t flags;

	b_dir_in = (USB_EP_DIR_IN == (ep & USB_EP_DIR_IN));
80002624:	f9 dc c0 e8 	bfextu	r12,r12,0x7,0x8
	flags = cpu_irq_save();
	if (ptr_job->busy == true) {
		cpu_irq_restore(flags);
		return false;	// Job already on going
	}
	ptr_job->busy = true;
80002628:	6e 03       	ld.w	r3,r7[0x0]
8000262a:	30 12       	mov	r2,1
8000262c:	e7 d2 d3 e1 	bfins	r3,r2,0x1f,0x1
80002630:	8f 03       	st.w	r7[0x0],r3
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002632:	e3 b4 00 00 	mtsr	0x0,r4
	cpu_irq_restore(flags);
	ptr_job->buf = buf;
80002636:	8f 1a       	st.w	r7[0x4],r10
	ptr_job->call_trans = callback;
80002638:	8f 38       	st.w	r7[0xc],r8
	ptr_job->b_raise_dma = false;
8000263a:	6e 08       	ld.w	r8,r7[0x0]
8000263c:	30 04       	mov	r4,0
8000263e:	f1 d4 d3 a1 	bfins	r8,r4,0x1d,0x1
80002642:	8f 08       	st.w	r7[0x0],r8

	// The USBB supports a maximum transfer size of 64KB
	if (0x10000 <= buf_size) {
80002644:	e0 49 ff ff 	cp.w	r9,65535
80002648:	e0 88 00 07 	brls	80002656 <udd_ep_run+0x96>
		// Transfer size = 64KB
		ptr_job->buf_size = 0x10000;
8000264c:	e0 78 00 00 	mov	r8,65536
80002650:	8f 28       	st.w	r7[0x8],r8
80002652:	08 99       	mov	r9,r4
80002654:	c3 58       	rjmp	800026be <udd_ep_run+0xfe>
		buf_size = 0;
	} else {
		ptr_job->buf_size = buf_size;
80002656:	8f 29       	st.w	r7[0x8],r9
		if (b_dir_in) {
80002658:	58 0c       	cp.w	r12,0
8000265a:	c3 20       	breq	800026be <udd_ep_run+0xfe>
			if (buf_size==0) {
8000265c:	58 09       	cp.w	r9,0
8000265e:	c1 71       	brne	8000268c <udd_ep_run+0xcc>
				// The USB DMA can't send a empty buffer
				// thus we raise the DMA interrupt end of transfert 
				// to execute ZLP process
				ptr_job->b_raise_dma = true;
80002660:	6e 08       	ld.w	r8,r7[0x0]
80002662:	30 1c       	mov	r12,1
				ptr_job->b_send_zlp = true;
80002664:	bd b8       	sbr	r8,0x1d
80002666:	f1 dc d3 c1 	bfins	r8,r12,0x1e,0x1
8000266a:	8f 08       	st.w	r7[0x0],r8

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
8000266c:	e1 ba 00 00 	mfsr	r10,0x0
	cpu_irq_disable();
80002670:	d3 03       	ssrf	0x10
				flags = cpu_irq_save();
				udd_enable_endpoint_dma_interrupt(ep);
80002672:	20 15       	sub	r5,1
80002674:	fc 19 02 00 	movh	r9,0x200
80002678:	f2 05 09 49 	lsl	r9,r9,r5
8000267c:	fe 68 00 00 	mov	r8,-131072
80002680:	91 69       	st.w	r8[0x18],r9
				udd_raise_endpoint_dma_interrupt(ep);
80002682:	91 39       	st.w	r8[0xc],r9
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002684:	e3 ba 00 00 	mtsr	0x0,r10
				cpu_irq_restore(flags);
				return true;
80002688:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
			}
			if (0 != buf_size % udd_get_endpoint_size(ep)) {
8000268c:	e0 36 ff 00 	sub	r6,130816
80002690:	6c 08       	ld.w	r8,r6[0x0]
80002692:	f1 d8 c0 83 	bfextu	r8,r8,0x4,0x3
80002696:	30 86       	mov	r6,8
80002698:	ec 08 09 48 	lsl	r8,r6,r8
8000269c:	20 18       	sub	r8,1
8000269e:	12 68       	and	r8,r9
800026a0:	c0 b0       	breq	800026b6 <udd_ep_run+0xf6>
				// Force short packet option to send a shortpacket on IN,
				// else the DMA transfer is accepted and interrupt DMA valid but nothing is sent.
				b_shortpacket = true;
				ptr_job->b_send_zlp = false;
800026a2:	6e 08       	ld.w	r8,r7[0x0]
800026a4:	30 0b       	mov	r11,0
800026a6:	f1 db d3 c1 	bfins	r8,r11,0x1e,0x1
800026aa:	8f 08       	st.w	r7[0x0],r8
			}
		}
	}

	// Start USB DMA to fill or read fifo of the selected endpoint
	udd_endpoint_dma_set_addr(ep, (U32) buf);
800026ac:	a5 6e       	lsl	lr,0x4
800026ae:	e0 3e fd 00 	sub	lr,130304
800026b2:	9d 1a       	st.w	lr[0x4],r10
800026b4:	c1 18       	rjmp	800026d6 <udd_ep_run+0x116>
				// Force short packet option to send a shortpacket on IN,
				// else the DMA transfer is accepted and interrupt DMA valid but nothing is sent.
				b_shortpacket = true;
				ptr_job->b_send_zlp = false;
			}else{
				ptr_job->b_send_zlp = b_shortpacket;
800026b6:	6e 08       	ld.w	r8,r7[0x0]
800026b8:	f1 db d3 c1 	bfins	r8,r11,0x1e,0x1
800026bc:	8f 08       	st.w	r7[0x0],r8
			}
		}
	}

	// Start USB DMA to fill or read fifo of the selected endpoint
	udd_endpoint_dma_set_addr(ep, (U32) buf);
800026be:	a5 6e       	lsl	lr,0x4
800026c0:	e0 3e fd 00 	sub	lr,130304
800026c4:	9d 1a       	st.w	lr[0x4],r10
	if (b_shortpacket) {
800026c6:	58 0b       	cp.w	r11,0
800026c8:	c0 31       	brne	800026ce <udd_ep_run+0x10e>
800026ca:	30 08       	mov	r8,0
800026cc:	c0 68       	rjmp	800026d8 <udd_ep_run+0x118>
		if (b_dir_in) {
800026ce:	58 0c       	cp.w	r12,0
800026d0:	c0 31       	brne	800026d6 <udd_ep_run+0x116>
800026d2:	31 48       	mov	r8,20
800026d4:	c0 28       	rjmp	800026d8 <udd_ep_run+0x118>
800026d6:	30 88       	mov	r8,8
		} else {
			udd_dma_ctrl = AVR32_USBB_UDDMA1_CONTROL_EOT_IRQ_EN_MASK
					| AVR32_USBB_UDDMA1_CONTROL_BUFF_CLOSE_IN_EN_MASK;
		}
	}
	udd_dma_ctrl |= (buf_size <<
800026d8:	e8 18 00 21 	orl	r8,0x21
			AVR32_USBB_UDDMA1_CONTROL_CH_BYTE_LENGTH_OFFSET)
			& AVR32_USBB_UDDMA1_CONTROL_CH_BYTE_LENGTH_MASK;
	udd_dma_ctrl |= AVR32_USBB_UDDMA1_CONTROL_EOBUFF_IRQ_EN_MASK |
800026dc:	f1 e9 11 09 	or	r9,r8,r9<<0x10
			AVR32_USBB_UDDMA1_CONTROL_CH_EN_MASK;
	udd_endpoint_dma_set_control(ep, udd_dma_ctrl);
800026e0:	9d 29       	st.w	lr[0x8],r9

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800026e2:	e1 b8 00 00 	mfsr	r8,0x0
	cpu_irq_disable();
800026e6:	d3 03       	ssrf	0x10
	flags = cpu_irq_save();
	udd_enable_endpoint_dma_interrupt(ep);
800026e8:	20 15       	sub	r5,1
800026ea:	fc 19 02 00 	movh	r9,0x200
800026ee:	f2 05 09 45 	lsl	r5,r9,r5
800026f2:	fe 69 00 00 	mov	r9,-131072
800026f6:	93 65       	st.w	r9[0x18],r5
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
800026f8:	e3 b8 00 00 	mtsr	0x0,r8
#endif
	barrier();
800026fc:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1
	cpu_irq_restore(flags);

	return true;
80002700:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
80002704:	00 00       	add	r0,r0
80002706:	07 18       	ld.sh	r8,r3++

80002708 <udd_sleep_mode>:
 * 
 * \param b_enable   true to authorize powerdown mode
 */
static void udd_sleep_mode(bool b_idle)
{
	if (!b_idle && udd_b_idle) {
80002708:	58 0c       	cp.w	r12,0
8000270a:	c1 11       	brne	8000272c <udd_sleep_mode+0x24>
8000270c:	49 18       	lddpc	r8,80002750 <udd_sleep_mode+0x48>
8000270e:	11 89       	ld.ub	r9,r8[0x0]
80002710:	30 08       	mov	r8,0
80002712:	f0 09 18 00 	cp.b	r9,r8
80002716:	c1 a0       	breq	8000274a <udd_sleep_mode+0x42>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002718:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
8000271c:	d3 03       	ssrf	0x10
	Assert(sleepmgr_locks[mode] < 0xff);

	// Enter a critical section
	flags = cpu_irq_save();

	++sleepmgr_locks[mode];
8000271e:	48 e8       	lddpc	r8,80002754 <udd_sleep_mode+0x4c>
80002720:	11 9a       	ld.ub	r10,r8[0x1]
80002722:	2f fa       	sub	r10,-1
80002724:	b0 9a       	st.b	r8[0x1],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002726:	e3 b9 00 00 	mtsr	0x0,r9
#endif
	barrier();
8000272a:	c1 08       	rjmp	8000274a <udd_sleep_mode+0x42>
		sleepmgr_lock_mode(USBB_SLEEP_MODE_USB_IDLE);
	}
	if (b_idle && !udd_b_idle) {
8000272c:	48 98       	lddpc	r8,80002750 <udd_sleep_mode+0x48>
8000272e:	11 89       	ld.ub	r9,r8[0x0]
80002730:	30 08       	mov	r8,0
80002732:	f0 09 18 00 	cp.b	r9,r8
80002736:	c0 a1       	brne	8000274a <udd_sleep_mode+0x42>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002738:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
8000273c:	d3 03       	ssrf	0x10
	Assert(sleepmgr_locks[mode]);

	// Enter a critical section
	flags = cpu_irq_save();

	--sleepmgr_locks[mode];
8000273e:	48 68       	lddpc	r8,80002754 <udd_sleep_mode+0x4c>
80002740:	11 9a       	ld.ub	r10,r8[0x1]
80002742:	20 1a       	sub	r10,1
80002744:	b0 9a       	st.b	r8[0x1],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002746:	e3 b9 00 00 	mtsr	0x0,r9
		sleepmgr_unlock_mode(USBB_SLEEP_MODE_USB_IDLE);
	}
	udd_b_idle = b_idle;
8000274a:	48 28       	lddpc	r8,80002750 <udd_sleep_mode+0x48>
8000274c:	b0 8c       	st.b	r8[0x0],r12
}
8000274e:	5e fc       	retal	r12
80002750:	00 00       	add	r0,r0
80002752:	07 48       	ld.w	r8,--r3
80002754:	00 00       	add	r0,r0
80002756:	0a 18       	sub	r8,r5

80002758 <udd_detach>:
	cpu_irq_restore(flags);
}


void udd_detach(void)
{
80002758:	d4 01       	pushm	lr
	otg_unfreeze_clock();
8000275a:	fe 68 00 00 	mov	r8,-131072
8000275e:	f0 f9 08 00 	ld.w	r9,r8[2048]
80002762:	af c9       	cbr	r9,0xe
80002764:	f1 49 08 00 	st.w	r8[2048],r9
	// Detach device from the bus
	udd_detach_device();
80002768:	70 09       	ld.w	r9,r8[0x0]
8000276a:	a9 a9       	sbr	r9,0x8
8000276c:	91 09       	st.w	r8[0x0],r9
	udd_sleep_mode(false);
8000276e:	30 0c       	mov	r12,0
80002770:	f0 1f 00 02 	mcall	80002778 <udd_detach+0x20>
}
80002774:	d8 02       	popm	pc
80002776:	00 00       	add	r0,r0
80002778:	80 00       	ld.sh	r0,r0[0x0]
8000277a:	27 08       	sub	r8,112

8000277c <udd_ctrl_init>:

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
8000277c:	e1 b8 00 00 	mfsr	r8,0x0
	cpu_irq_disable();
80002780:	d3 03       	ssrf	0x10
	// In case of abort of IN Data Phase:
	// No need to abort IN transfer (rise TXINI), 
	// because it is automatically done by hardware when a Setup packet is received.
	// But the interrupt must be disabled to don't generate interrupt TXINI 
	// after SETUP reception.
	udd_disable_in_send_interrupt(0);
80002782:	30 1a       	mov	r10,1
80002784:	fe 69 02 20 	mov	r9,-130528
80002788:	93 0a       	st.w	r9[0x0],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
8000278a:	e3 b8 00 00 	mtsr	0x0,r8
	cpu_irq_restore(flags);
	// In case of OUT ZLP event is no processed before Setup event occurs
	udd_ack_out_received(0);
8000278e:	30 29       	mov	r9,2
80002790:	fe 68 01 60 	mov	r8,-130720
80002794:	91 09       	st.w	r8[0x0],r9

	udd_g_ctrlreq.callback = NULL;
80002796:	48 59       	lddpc	r9,800027a8 <udd_ctrl_init+0x2c>
80002798:	30 08       	mov	r8,0
8000279a:	93 48       	st.w	r9[0x10],r8
	udd_g_ctrlreq.over_under_run = NULL;
8000279c:	93 58       	st.w	r9[0x14],r8
	udd_g_ctrlreq.payload_size = 0;
8000279e:	b2 68       	st.h	r9[0xc],r8
	udd_ep_control_state = UDD_EPCTRL_SETUP;
800027a0:	48 39       	lddpc	r9,800027ac <udd_ctrl_init+0x30>
800027a2:	93 08       	st.w	r9[0x0],r8
}
800027a4:	5e fc       	retal	r12
800027a6:	00 00       	add	r0,r0
800027a8:	00 00       	add	r0,r0
800027aa:	0a 00       	add	r0,r5
800027ac:	00 00       	add	r0,r0
800027ae:	07 4c       	ld.w	r12,--r3

800027b0 <udd_ctrl_send_zlp_in>:

static void udd_ctrl_send_zlp_in(void)
{
	irqflags_t flags;

	udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP;
800027b0:	30 39       	mov	r9,3
800027b2:	48 a8       	lddpc	r8,800027d8 <udd_ctrl_send_zlp_in+0x28>
800027b4:	91 09       	st.w	r8[0x0],r9

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800027b6:	e1 bb 00 00 	mfsr	r11,0x0
	cpu_irq_disable();
800027ba:	d3 03       	ssrf	0x10
	// Validate and send empty IN packet on control endpoint
	flags = cpu_irq_save();
	// Send ZLP on IN endpoint
	udd_ack_in_send(0);
800027bc:	fe 6a 01 60 	mov	r10,-130720
800027c0:	30 19       	mov	r9,1
800027c2:	95 09       	st.w	r10[0x0],r9
	udd_enable_in_send_interrupt(0);
800027c4:	fe 68 01 f0 	mov	r8,-130576
800027c8:	91 09       	st.w	r8[0x0],r9
	// To detect a protocol error, enable nak interrupt on data OUT phase
	udd_ack_nak_out(0);
800027ca:	30 89       	mov	r9,8
800027cc:	95 09       	st.w	r10[0x0],r9
	udd_enable_nak_out_interrupt(0);
800027ce:	91 09       	st.w	r8[0x0],r9
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
800027d0:	e3 bb 00 00 	mtsr	0x0,r11
	cpu_irq_restore(flags);
}
800027d4:	5e fc       	retal	r12
800027d6:	00 00       	add	r0,r0
800027d8:	00 00       	add	r0,r0
800027da:	07 4c       	ld.w	r12,--r3

800027dc <udd_ctrl_in_sent>:
	}
}


static void udd_ctrl_in_sent(void)
{
800027dc:	eb cd 40 80 	pushm	r7,lr

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800027e0:	e1 b8 00 00 	mfsr	r8,0x0
	cpu_irq_disable();
800027e4:	d3 03       	ssrf	0x10
	uint8_t i;
	uint8_t *ptr_dest, *ptr_src;
	irqflags_t flags;

	flags = cpu_irq_save();
	udd_disable_in_send_interrupt(0);
800027e6:	30 1a       	mov	r10,1
800027e8:	fe 69 02 20 	mov	r9,-130528
800027ec:	93 0a       	st.w	r9[0x0],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
800027ee:	e3 b8 00 00 	mtsr	0x0,r8
	cpu_irq_restore(flags);

	if (UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP == udd_ep_control_state) {
800027f2:	4c 38       	lddpc	r8,800028fc <udd_ctrl_in_sent+0x120>
800027f4:	70 08       	ld.w	r8,r8[0x0]
800027f6:	58 38       	cp.w	r8,3
800027f8:	c0 71       	brne	80002806 <udd_ctrl_in_sent+0x2a>
		// ZLP on IN is sent, then valid end of setup request
		udd_ctrl_endofrequest();
800027fa:	f0 1f 00 42 	mcall	80002900 <udd_ctrl_in_sent+0x124>
		// Reinitializes control endpoint management
		udd_ctrl_init();
800027fe:	f0 1f 00 42 	mcall	80002904 <udd_ctrl_in_sent+0x128>
		return;
80002802:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	Assert(udd_ep_control_state == UDD_EPCTRL_DATA_IN);

	nb_remain = udd_g_ctrlreq.payload_size - udd_ctrl_payload_nb_trans;
80002806:	4c 18       	lddpc	r8,80002908 <udd_ctrl_in_sent+0x12c>
80002808:	90 68       	ld.sh	r8,r8[0xc]
8000280a:	4c 19       	lddpc	r9,8000290c <udd_ctrl_in_sent+0x130>
8000280c:	92 07       	ld.sh	r7,r9[0x0]
8000280e:	f0 07 01 07 	sub	r7,r8,r7
80002812:	5c 87       	casts.h	r7
	if (0 == nb_remain) {
80002814:	c3 b1       	brne	8000288a <udd_ctrl_in_sent+0xae>
		// All content of current buffer payload are sent
		if (!udd_ctrl_payload_need_in_zlp) {
80002816:	4b f9       	lddpc	r9,80002910 <udd_ctrl_in_sent+0x134>
80002818:	13 8a       	ld.ub	r10,r9[0x0]
8000281a:	30 09       	mov	r9,0
8000281c:	f2 0a 18 00 	cp.b	r10,r9
80002820:	c1 21       	brne	80002844 <udd_ctrl_in_sent+0x68>

static void udd_ctrl_send_zlp_out(void)
{
	irqflags_t flags;

	udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
80002822:	30 49       	mov	r9,4
80002824:	4b 68       	lddpc	r8,800028fc <udd_ctrl_in_sent+0x120>
80002826:	91 09       	st.w	r8[0x0],r9

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002828:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
8000282c:	d3 03       	ssrf	0x10
	// No action is necessary to accept OUT ZLP
	// because the buffer of control endpoint is already free

	// To detect a protocol error, enable nak interrupt on data IN phase
	flags = cpu_irq_save();
	udd_ack_nak_in(0);
8000282e:	31 08       	mov	r8,16
80002830:	fe 6a 01 60 	mov	r10,-130720
80002834:	95 08       	st.w	r10[0x0],r8
	udd_enable_nak_in_interrupt(0);
80002836:	fe 6a 01 f0 	mov	r10,-130576
8000283a:	95 08       	st.w	r10[0x0],r8
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
8000283c:	e3 b9 00 00 	mtsr	0x0,r9
		// All content of current buffer payload are sent
		if (!udd_ctrl_payload_need_in_zlp) {
			// It is the end of data phase, because the last data packet is a short packet
			// then generate an OUT ZLP for handshake phase.
			udd_ctrl_send_zlp_out();
			return;
80002840:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		if ((udd_g_ctrlreq.req.wLength > (udd_ctrl_prev_payload_nb_trans
80002844:	4b 19       	lddpc	r9,80002908 <udd_ctrl_in_sent+0x12c>
80002846:	92 b9       	ld.uh	r9,r9[0x6]
80002848:	5c 78       	castu.h	r8
8000284a:	4b 3a       	lddpc	r10,80002914 <udd_ctrl_in_sent+0x138>
8000284c:	94 8a       	ld.uh	r10,r10[0x0]
8000284e:	14 08       	add	r8,r10
80002850:	10 39       	cp.w	r9,r8
80002852:	e0 89 00 08 	brgt	80002862 <udd_ctrl_in_sent+0x86>
								+
								udd_g_ctrlreq.
								payload_size))
				|| (!udd_g_ctrlreq.over_under_run)
80002856:	4a d8       	lddpc	r8,80002908 <udd_ctrl_in_sent+0x12c>
80002858:	70 5c       	ld.w	r12,r8[0x14]
			// It is the end of data phase, because the last data packet is a short packet
			// then generate an OUT ZLP for handshake phase.
			udd_ctrl_send_zlp_out();
			return;
		}
		if ((udd_g_ctrlreq.req.wLength > (udd_ctrl_prev_payload_nb_trans
8000285a:	58 0c       	cp.w	r12,0
8000285c:	c0 30       	breq	80002862 <udd_ctrl_in_sent+0x86>
8000285e:	5d 1c       	icall	r12
80002860:	c0 51       	brne	8000286a <udd_ctrl_in_sent+0x8e>
								udd_g_ctrlreq.
								payload_size))
				|| (!udd_g_ctrlreq.over_under_run)
				|| (!udd_g_ctrlreq.over_under_run())) {
			// Underrun or data packet complette than send zlp on IN (note don't change DataToggle)
			udd_ctrl_payload_need_in_zlp = false;
80002862:	30 09       	mov	r9,0
80002864:	4a b8       	lddpc	r8,80002910 <udd_ctrl_in_sent+0x134>
80002866:	b0 89       	st.b	r8[0x0],r9
			// It is the end of data phase, because the last data packet is a short packet
			// then generate an OUT ZLP for handshake phase.
			udd_ctrl_send_zlp_out();
			return;
		}
		if ((udd_g_ctrlreq.req.wLength > (udd_ctrl_prev_payload_nb_trans
80002868:	c1 18       	rjmp	8000288a <udd_ctrl_in_sent+0xae>
			udd_ctrl_payload_need_in_zlp = false;
			// nb_remain==0 allows to send a IN ZLP
		} else {
			// A new payload buffer is given
			// Update number of total data sending by previous playlaod buffer
			udd_ctrl_prev_payload_nb_trans +=
8000286a:	4a b9       	lddpc	r9,80002914 <udd_ctrl_in_sent+0x138>
8000286c:	4a 88       	lddpc	r8,8000290c <udd_ctrl_in_sent+0x130>
8000286e:	90 0b       	ld.sh	r11,r8[0x0]
80002870:	92 0a       	ld.sh	r10,r9[0x0]
80002872:	f6 0a 00 0a 	add	r10,r11,r10
80002876:	b2 0a       	st.h	r9[0x0],r10
					udd_ctrl_payload_nb_trans;
			// Update maangement of current playoad transfer
			udd_ctrl_payload_nb_trans = 0;
80002878:	30 09       	mov	r9,0
8000287a:	b0 09       	st.h	r8[0x0],r9
			nb_remain = udd_g_ctrlreq.payload_size;
8000287c:	4a 38       	lddpc	r8,80002908 <udd_ctrl_in_sent+0x12c>
8000287e:	90 67       	ld.sh	r7,r8[0xc]
			// Compute if an IN ZLP must be send after IN data
			udd_ctrl_payload_need_in_zlp =
80002880:	f1 d7 c0 06 	bfextu	r8,r7,0x0,0x6
80002884:	5f 09       	sreq	r9
80002886:	4a 38       	lddpc	r8,80002910 <udd_ctrl_in_sent+0x134>
80002888:	b0 89       	st.b	r8[0x0],r9
	if (nb_remain > USB_DEVICE_EP_CTRL_SIZE) {
		nb_remain = USB_DEVICE_EP_CTRL_SIZE;
	}
	// Fill buffer of endpoint control
	ptr_dest = (uint8_t *) & udd_get_endpoint_fifo_access(0, 8);
	ptr_src = udd_g_ctrlreq.payload + udd_ctrl_payload_nb_trans;
8000288a:	4a 08       	lddpc	r8,80002908 <udd_ctrl_in_sent+0x12c>
8000288c:	70 2a       	ld.w	r10,r8[0x8]
8000288e:	4a 08       	lddpc	r8,8000290c <udd_ctrl_in_sent+0x130>
80002890:	90 09       	ld.sh	r9,r8[0x0]

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002892:	e1 bb 00 00 	mfsr	r11,0x0
	cpu_irq_disable();
80002896:	d3 03       	ssrf	0x10
	// a next setup reception in same endpoint 0 DPRAM.
	// Thereby, an OUT ZLP reception must check before IN data write 
	// and if no OUT ZLP is recevied the data must be written quickly (800us)
	// before an eventually ZLP OUT and SETUP reception
	flags = cpu_irq_save();
	if (Is_udd_out_received(0)) {
80002898:	fe 68 01 30 	mov	r8,-130768
8000289c:	70 08       	ld.w	r8,r8[0x0]
8000289e:	e2 18 00 02 	andl	r8,0x2,COH
800028a2:	c0 91       	brne	800028b4 <udd_ctrl_in_sent+0xd8>
800028a4:	34 08       	mov	r8,64
800028a6:	f0 07 19 00 	cp.h	r7,r8
800028aa:	f9 b7 0b 40 	movhi	r7,64
		cpu_irq_restore(flags);
		udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
		return;	// Exit of IN DATA phase
	}
	// Write quickly the IN data
	for (i = 0; i < nb_remain; i++) {
800028ae:	58 07       	cp.w	r7,0
800028b0:	c0 91       	brne	800028c2 <udd_ctrl_in_sent+0xe6>
800028b2:	c1 48       	rjmp	800028da <udd_ctrl_in_sent+0xfe>
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
800028b4:	e3 bb 00 00 	mtsr	0x0,r11
	// before an eventually ZLP OUT and SETUP reception
	flags = cpu_irq_save();
	if (Is_udd_out_received(0)) {
		// IN DATA phase aborted by OUT ZLP
		cpu_irq_restore(flags);
		udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
800028b8:	30 49       	mov	r9,4
800028ba:	49 18       	lddpc	r8,800028fc <udd_ctrl_in_sent+0x120>
800028bc:	91 09       	st.w	r8[0x0],r9
		return;	// Exit of IN DATA phase
800028be:	e3 cd 80 80 	ldm	sp++,r7,pc
	if (nb_remain > USB_DEVICE_EP_CTRL_SIZE) {
		nb_remain = USB_DEVICE_EP_CTRL_SIZE;
	}
	// Fill buffer of endpoint control
	ptr_dest = (uint8_t *) & udd_get_endpoint_fifo_access(0, 8);
	ptr_src = udd_g_ctrlreq.payload + udd_ctrl_payload_nb_trans;
800028c2:	5c 79       	castu.h	r9
800028c4:	f4 09 00 09 	add	r9,r10,r9
800028c8:	fc 18 e0 00 	movh	r8,0xe000
		udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
		return;	// Exit of IN DATA phase
	}
	// Write quickly the IN data
	for (i = 0; i < nb_remain; i++) {
		*ptr_dest++ = *ptr_src++;
800028cc:	13 3a       	ld.ub	r10,r9++
800028ce:	10 ca       	st.b	r8++,r10
		cpu_irq_restore(flags);
		udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
		return;	// Exit of IN DATA phase
	}
	// Write quickly the IN data
	for (i = 0; i < nb_remain; i++) {
800028d0:	f5 d8 c0 08 	bfextu	r10,r8,0x0,0x8
800028d4:	ee 0a 19 00 	cp.h	r10,r7
800028d8:	cf a3       	brcs	800028cc <udd_ctrl_in_sent+0xf0>
		*ptr_dest++ = *ptr_src++;
	}
	udd_ctrl_payload_nb_trans += nb_remain;
800028da:	48 d8       	lddpc	r8,8000290c <udd_ctrl_in_sent+0x130>
800028dc:	90 09       	ld.sh	r9,r8[0x0]
800028de:	f2 07 00 07 	add	r7,r9,r7
800028e2:	b0 07       	st.h	r8[0x0],r7

	// Validate and send the data available in the control endpoint buffer
	udd_ack_in_send(0);
800028e4:	30 18       	mov	r8,1
800028e6:	fe 69 01 60 	mov	r9,-130720
800028ea:	93 08       	st.w	r9[0x0],r8
	udd_enable_in_send_interrupt(0);
800028ec:	fe 69 01 f0 	mov	r9,-130576
800028f0:	93 08       	st.w	r9[0x0],r8
800028f2:	e3 bb 00 00 	mtsr	0x0,r11
#endif
	barrier();
800028f6:	e3 cd 80 80 	ldm	sp++,r7,pc
800028fa:	00 00       	add	r0,r0
800028fc:	00 00       	add	r0,r0
800028fe:	07 4c       	ld.w	r12,--r3
80002900:	80 00       	ld.sh	r0,r0[0x0]
80002902:	25 3c       	sub	r12,83
80002904:	80 00       	ld.sh	r0,r0[0x0]
80002906:	27 7c       	sub	r12,119
80002908:	00 00       	add	r0,r0
8000290a:	0a 00       	add	r0,r5
8000290c:	00 00       	add	r0,r0
8000290e:	07 4a       	ld.w	r10,--r3
80002910:	00 00       	add	r0,r0
80002912:	07 50       	ld.sh	r0,--r3
80002914:	00 00       	add	r0,r0
80002916:	07 14       	ld.sh	r4,r3++

80002918 <udd_ep_alloc>:


#if (0!=USB_DEVICE_MAX_EP)
bool udd_ep_alloc(udd_ep_id_t ep, uint8_t bmAttributes,
		uint16_t MaxEndpointSize)
{
80002918:	eb cd 40 e0 	pushm	r5-r7,lr
	bool b_dir_in;
	uint16_t ep_allocated;
	uint8_t bank, i;

	b_dir_in = ep & USB_EP_DIR_IN;
	ep = ep & USB_EP_ADDR_MASK;
8000291c:	f1 dc c0 04 	bfextu	r8,r12,0x0,0x4

	if (ep > USB_DEVICE_MAX_EP)
80002920:	30 39       	mov	r9,3
80002922:	f2 08 18 00 	cp.b	r8,r9
80002926:	e0 8b 00 88 	brhi	80002a36 <udd_ep_alloc+0x11e>
		return false;
	if (Is_udd_endpoint_enabled(ep))
8000292a:	fe 69 00 00 	mov	r9,-131072
8000292e:	72 79       	ld.w	r9,r9[0x1c]
80002930:	30 17       	mov	r7,1
80002932:	ee 08 09 47 	lsl	r7,r7,r8
80002936:	ef e9 00 09 	and	r9,r7,r9
8000293a:	c7 e1       	brne	80002a36 <udd_ep_alloc+0x11e>
		return false;

	// Bank choise
	switch(bmAttributes&USB_EP_TYPE_MASK) {
8000293c:	f3 db c0 02 	bfextu	r9,r11,0x0,0x2
80002940:	58 19       	cp.w	r9,1
80002942:	c7 a5       	brlt	80002a36 <udd_ep_alloc+0x11e>
80002944:	58 29       	cp.w	r9,2
80002946:	e0 8a 00 06 	brle	80002952 <udd_ep_alloc+0x3a>
8000294a:	58 39       	cp.w	r9,3
8000294c:	c7 51       	brne	80002a36 <udd_ep_alloc+0x11e>
8000294e:	30 06       	mov	r6,0
80002950:	c0 28       	rjmp	80002954 <udd_ep_alloc+0x3c>
80002952:	30 16       	mov	r6,1
	Assert(MaxEndpointSize < 1024);
	Assert((MaxEndpointSize == 1023) || !(MaxEndpointSize & (MaxEndpointSize - 1)));
	Assert(MaxEndpointSize >= 8);
		   
	// Set configuration of new endpoint
	udd_configure_endpoint(ep, bmAttributes, (b_dir_in ? 1 : 0),
80002954:	f0 09 15 02 	lsl	r9,r8,0x2
80002958:	e0 39 ff 00 	sub	r9,130816
8000295c:	72 0e       	ld.w	lr,r9[0x0]
8000295e:	5c 7a       	castu.h	r10
80002960:	30 85       	mov	r5,8
80002962:	f4 05 0c 4a 	max	r10,r10,r5
80002966:	e0 65 04 00 	mov	r5,1024
8000296a:	f4 05 0d 4a 	min	r10,r10,r5
8000296e:	a1 7a       	lsl	r10,0x1
80002970:	20 1a       	sub	r10,1
80002972:	f4 0a 12 00 	clz	r10,r10
80002976:	f9 dc c0 e1 	bfextu	r12,r12,0x7,0x1
8000297a:	ab 7b       	lsl	r11,0xb
8000297c:	e2 1b 18 00 	andl	r11,0x1800,COH
80002980:	f7 ec 10 8c 	or	r12,r11,r12<<0x8
80002984:	f4 0b 11 1c 	rsub	r11,r10,28
80002988:	f9 eb 10 4b 	or	r11,r12,r11<<0x4
8000298c:	f7 e6 10 2b 	or	r11,r11,r6<<0x2
80002990:	e2 1b 19 7c 	andl	r11,0x197c,COH
80002994:	1c 9a       	mov	r10,lr
80002996:	e0 1a e6 83 	andl	r10,0xe683
8000299a:	f7 ea 10 0a 	or	r10,r11,r10
8000299e:	93 0a       	st.w	r9[0x0],r10
			MaxEndpointSize, bank);
	ep_allocated = 1 << ep;
800029a0:	5c 87       	casts.h	r7

	// Unalloc endpoints superior
	for (i = USB_DEVICE_MAX_EP; i > ep; i--) {
800029a2:	30 29       	mov	r9,2
800029a4:	f2 08 18 00 	cp.b	r8,r9
800029a8:	e0 8b 00 1d 	brhi	800029e2 <udd_ep_alloc+0xca>
800029ac:	fe 6a 01 0c 	mov	r10,-130804
800029b0:	30 39       	mov	r9,3
		if (Is_udd_endpoint_enabled(i)) {
800029b2:	fe 6c 00 00 	mov	r12,-131072
800029b6:	30 16       	mov	r6,1
800029b8:	78 7e       	ld.w	lr,r12[0x1c]
800029ba:	ec 09 09 4b 	lsl	r11,r6,r9
800029be:	f7 ee 00 0e 	and	lr,r11,lr
800029c2:	c0 b0       	breq	800029d8 <udd_ep_alloc+0xc0>
			ep_allocated |= 1 << i;
800029c4:	f7 e7 10 07 	or	r7,r11,r7
800029c8:	5c 87       	casts.h	r7
			udd_disable_endpoint(i);
800029ca:	78 7e       	ld.w	lr,r12[0x1c]
800029cc:	5c db       	com	r11
800029ce:	1c 6b       	and	r11,lr
800029d0:	99 7b       	st.w	r12[0x1c],r11
			udd_unallocate_memory(i);
800029d2:	74 0b       	ld.w	r11,r10[0x0]
800029d4:	a1 db       	cbr	r11,0x1
800029d6:	95 0b       	st.w	r10[0x0],r11
800029d8:	20 19       	sub	r9,1
800029da:	20 4a       	sub	r10,4
	udd_configure_endpoint(ep, bmAttributes, (b_dir_in ? 1 : 0),
			MaxEndpointSize, bank);
	ep_allocated = 1 << ep;

	// Unalloc endpoints superior
	for (i = USB_DEVICE_MAX_EP; i > ep; i--) {
800029dc:	f2 08 18 00 	cp.b	r8,r9
800029e0:	ce c3       	brcs	800029b8 <udd_ep_alloc+0xa0>
		}
	}

	// Realloc/Enable endpoints
	for (i = ep; i <= USB_DEVICE_MAX_EP; i++) {
		if (ep_allocated & (1 << i)) {
800029e2:	0e 9c       	mov	r12,r7
800029e4:	5c 7c       	castu.h	r12
			udd_allocate_memory(i);
			udd_enable_endpoint(i);
800029e6:	fe 6e 00 00 	mov	lr,-131072
800029ea:	30 16       	mov	r6,1
			udd_unallocate_memory(i);
		}
	}

	// Realloc/Enable endpoints
	for (i = ep; i <= USB_DEVICE_MAX_EP; i++) {
800029ec:	30 37       	mov	r7,3
		if (ep_allocated & (1 << i)) {
800029ee:	f8 08 08 49 	asr	r9,r12,r8
800029f2:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
800029f6:	c1 80       	breq	80002a26 <udd_ep_alloc+0x10e>
			udd_allocate_memory(i);
800029f8:	f0 0b 15 02 	lsl	r11,r8,0x2
800029fc:	fe 65 01 00 	mov	r5,-130816
80002a00:	f6 05 00 09 	add	r9,r11,r5
80002a04:	72 05       	ld.w	r5,r9[0x0]
80002a06:	a1 b5       	sbr	r5,0x1
80002a08:	93 05       	st.w	r9[0x0],r5
			udd_enable_endpoint(i);
80002a0a:	7c 75       	ld.w	r5,lr[0x1c]
80002a0c:	ec 08 09 4a 	lsl	r10,r6,r8
80002a10:	0a 4a       	or	r10,r5
80002a12:	9d 7a       	st.w	lr[0x1c],r10
			if (!Is_udd_endpoint_configured(i))
80002a14:	e0 3b fe d0 	sub	r11,130768
80002a18:	76 0a       	ld.w	r10,r11[0x0]
80002a1a:	e6 1a 00 04 	andh	r10,0x4,COH
80002a1e:	c0 c0       	breq	80002a36 <udd_ep_alloc+0x11e>
				return false;
			udd_enable_endpoint_bank_autoswitch(i);	
80002a20:	72 0a       	ld.w	r10,r9[0x0]
80002a22:	a9 ba       	sbr	r10,0x9
80002a24:	93 0a       	st.w	r9[0x0],r10
			udd_unallocate_memory(i);
		}
	}

	// Realloc/Enable endpoints
	for (i = ep; i <= USB_DEVICE_MAX_EP; i++) {
80002a26:	2f f8       	sub	r8,-1
80002a28:	5c 58       	castu.b	r8
80002a2a:	ee 08 18 00 	cp.b	r8,r7
80002a2e:	fe 98 ff e0 	brls	800029ee <udd_ep_alloc+0xd6>
80002a32:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80002a36:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0

80002a3a <udd_reset_ep_ctrl>:

static void udd_reset_ep_ctrl(void)
{
	irqflags_t flags;
	// Reset USB address to 0
	udd_configure_address(0);
80002a3a:	fe 68 00 00 	mov	r8,-131072
80002a3e:	70 09       	ld.w	r9,r8[0x0]
80002a40:	e0 19 ff 80 	andl	r9,0xff80
80002a44:	91 09       	st.w	r8[0x0],r9
	udd_enable_address();
80002a46:	70 09       	ld.w	r9,r8[0x0]
80002a48:	a7 b9       	sbr	r9,0x7
80002a4a:	91 09       	st.w	r8[0x0],r9
	// Alloc and configure control endpoint
	udd_configure_endpoint(0,
80002a4c:	fe 69 01 00 	mov	r9,-130816
80002a50:	72 0b       	ld.w	r11,r9[0x0]
80002a52:	30 8c       	mov	r12,8
80002a54:	34 0a       	mov	r10,64
80002a56:	f4 0c 0c 4a 	max	r10,r10,r12
80002a5a:	e0 6c 04 00 	mov	r12,1024
80002a5e:	f4 0c 0d 4a 	min	r10,r10,r12
80002a62:	a1 7a       	lsl	r10,0x1
80002a64:	20 1a       	sub	r10,1
80002a66:	f4 0a 12 00 	clz	r10,r10
80002a6a:	f4 0a 11 1c 	rsub	r10,r10,28
80002a6e:	a5 6a       	lsl	r10,0x4
80002a70:	e2 1a 19 7c 	andl	r10,0x197c,COH
80002a74:	e0 1b e6 83 	andl	r11,0xe683
80002a78:	16 4a       	or	r10,r11
80002a7a:	93 0a       	st.w	r9[0x0],r10
			USB_EP_TYPE_CONTROL,
			0,
			USB_DEVICE_EP_CTRL_SIZE, AVR32_USBB_UECFG0_EPBK_SINGLE);

	udd_allocate_memory(0);
80002a7c:	72 0a       	ld.w	r10,r9[0x0]
80002a7e:	a1 ba       	sbr	r10,0x1
80002a80:	93 0a       	st.w	r9[0x0],r10
	udd_enable_endpoint(0);
80002a82:	70 79       	ld.w	r9,r8[0x1c]
80002a84:	a1 a9       	sbr	r9,0x0
80002a86:	91 79       	st.w	r8[0x1c],r9

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002a88:	e1 ba 00 00 	mfsr	r10,0x0
	cpu_irq_disable();
80002a8c:	d3 03       	ssrf	0x10
	flags = cpu_irq_save();
	udd_enable_setup_received_interrupt(0);
80002a8e:	fe 69 01 f0 	mov	r9,-130576
80002a92:	30 4b       	mov	r11,4
80002a94:	93 0b       	st.w	r9[0x0],r11
	udd_enable_out_received_interrupt(0);
80002a96:	30 2b       	mov	r11,2
80002a98:	93 0b       	st.w	r9[0x0],r11
	udd_enable_endpoint_interrupt(0);
80002a9a:	e0 69 10 00 	mov	r9,4096
80002a9e:	91 69       	st.w	r8[0x18],r9
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002aa0:	e3 ba 00 00 	mtsr	0x0,r10
	cpu_irq_restore(flags);
}
80002aa4:	5e fc       	retal	r12
80002aa6:	d7 03       	nop

80002aa8 <udd_attach>:
	cpu_irq_restore(flags);
}


void udd_attach(void)
{
80002aa8:	eb cd 40 c0 	pushm	r6-r7,lr

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002aac:	e1 b6 00 00 	mfsr	r6,0x0
	cpu_irq_disable();
80002ab0:	d3 03       	ssrf	0x10
	irqflags_t flags;
	flags = cpu_irq_save();

	// At startup the USB bus state is unknown, 
	// therefore the state is considered IDLE to not miss any USB event
	udd_sleep_mode(true);
80002ab2:	30 1c       	mov	r12,1
80002ab4:	f0 1f 00 15 	mcall	80002b08 <udd_attach+0x60>
	otg_unfreeze_clock();
80002ab8:	fe 67 00 00 	mov	r7,-131072
80002abc:	ee f8 08 00 	ld.w	r8,r7[2048]
80002ac0:	af c8       	cbr	r8,0xe
80002ac2:	ef 48 08 00 	st.w	r7[2048],r8
#else
	// Check USB clock because the source can be a PLL
	while( !Is_clock_usable() );
#endif
	// Authorize attach if VBus is present
	udd_attach_device();
80002ac6:	6e 08       	ld.w	r8,r7[0x0]
80002ac8:	a9 c8       	cbr	r8,0x8
80002aca:	8f 08       	st.w	r7[0x0],r8

	// (RESET_AND_WAKEUP)
	// After the attach and the first USB suspend, the following USB Reset time can be inferior to CPU restart clock time.
	// Thus, the USB Reset state is not detected and endpoint control is not allocated
	// In this case, a Reset is do automatically after attach.
	udc_reset();	// Reset USB Device Stack Core
80002acc:	f0 1f 00 10 	mcall	80002b0c <udd_attach+0x64>
	udd_reset_ep_ctrl();	// Reset endpoint control
80002ad0:	f0 1f 00 10 	mcall	80002b10 <udd_attach+0x68>
	udd_ctrl_init();	// Reset endpoint control management
80002ad4:	f0 1f 00 10 	mcall	80002b14 <udd_attach+0x6c>

	// Enable USB line events
	udd_enable_reset_interrupt();
80002ad8:	30 8b       	mov	r11,8
80002ada:	8f 6b       	st.w	r7[0x18],r11
	udd_enable_suspend_interrupt();
80002adc:	30 19       	mov	r9,1
80002ade:	8f 69       	st.w	r7[0x18],r9
	udd_enable_wake_up_interrupt();
80002ae0:	31 08       	mov	r8,16
80002ae2:	8f 68       	st.w	r7[0x18],r8
	udd_enable_sof_interrupt();
80002ae4:	30 4a       	mov	r10,4
80002ae6:	8f 6a       	st.w	r7[0x18],r10
#ifdef USB_DEVICE_HS_SUPPORT
	udd_enable_msof_interrupt();
#endif
	// Reset following interupts flag
	udd_ack_reset();
80002ae8:	8f 2b       	st.w	r7[0x8],r11
	udd_ack_sof();
80002aea:	8f 2a       	st.w	r7[0x8],r10
	udd_ack_msof();
80002aec:	30 2a       	mov	r10,2
80002aee:	8f 2a       	st.w	r7[0x8],r10

	// The first suspend interrupt must be forced
#if UC3A3
	// With UTMI, the first suspend is detected but must be cleared to reoccur interrupt
	udd_ack_suspend();
80002af0:	8f 29       	st.w	r7[0x8],r9
#else
	// The first suspend interrupt is not detected else raise it
	udd_raise_suspend();
#endif
	udd_ack_wake_up();
80002af2:	8f 28       	st.w	r7[0x8],r8
	otg_freeze_clock();
80002af4:	ee f8 08 00 	ld.w	r8,r7[2048]
80002af8:	af a8       	sbr	r8,0xe
80002afa:	ef 48 08 00 	st.w	r7[2048],r8
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002afe:	e3 b6 00 00 	mtsr	0x0,r6
	cpu_irq_restore(flags);
}
80002b02:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002b06:	00 00       	add	r0,r0
80002b08:	80 00       	ld.sh	r0,r0[0x0]
80002b0a:	27 08       	sub	r8,112
80002b0c:	80 00       	ld.sh	r0,r0[0x0]
80002b0e:	39 dc       	mov	r12,-99
80002b10:	80 00       	ld.sh	r0,r0[0x0]
80002b12:	2a 3a       	sub	r10,-93
80002b14:	80 00       	ld.sh	r0,r0[0x0]
80002b16:	27 7c       	sub	r12,119

80002b18 <udd_enable>:
	return true;
}


void udd_enable(void)
{
80002b18:	eb cd 40 c0 	pushm	r6-r7,lr
	irqflags_t flags;
	sysclk_enable_usb();
80002b1c:	f0 1f 00 39 	mcall	80002c00 <udd_enable+0xe8>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002b20:	e1 b6 00 00 	mfsr	r6,0x0
	cpu_irq_disable();
80002b24:	d3 03       	ssrf	0x10

	flags = cpu_irq_save();

	//** Enable USB hardware
	otg_disable();
80002b26:	fe 67 00 00 	mov	r7,-131072
80002b2a:	ee f8 08 00 	ld.w	r8,r7[2048]
80002b2e:	af d8       	cbr	r8,0xf
80002b30:	ef 48 08 00 	st.w	r7[2048],r8
	(void)Is_otg_enabled();
80002b34:	ee f8 08 00 	ld.w	r8,r7[2048]
	// Check UID pin state before enter in USB device mode
	if (!Is_otg_id_device())
		return false;
#else
	// Here, only the Device mode is possible, then link USBB interrupt to UDD interrupt
	irq_register_handler(udd_interrupt, AVR32_USBB_IRQ, UDD_USB_INT_LEVEL);
80002b38:	30 0a       	mov	r10,0
80002b3a:	e0 6b 02 20 	mov	r11,544
80002b3e:	4b 2c       	lddpc	r12,80002c04 <udd_enable+0xec>
80002b40:	f0 1f 00 32 	mcall	80002c08 <udd_enable+0xf0>
	otg_force_device_mode();
80002b44:	ee f8 08 00 	ld.w	r8,r7[2048]
80002b48:	b9 b8       	sbr	r8,0x19
80002b4a:	ef 48 08 00 	st.w	r7[2048],r8
80002b4e:	ee f8 08 00 	ld.w	r8,r7[2048]
80002b52:	b9 c8       	cbr	r8,0x18
80002b54:	ef 48 08 00 	st.w	r7[2048],r8
#endif
	otg_disable_pad();
80002b58:	ee f8 08 00 	ld.w	r8,r7[2048]
80002b5c:	ad c8       	cbr	r8,0xc
80002b5e:	ef 48 08 00 	st.w	r7[2048],r8
	otg_enable_pad();
80002b62:	ee f8 08 00 	ld.w	r8,r7[2048]
80002b66:	ad a8       	sbr	r8,0xc
80002b68:	ef 48 08 00 	st.w	r7[2048],r8
	otg_enable();
80002b6c:	ee f8 08 00 	ld.w	r8,r7[2048]
80002b70:	af b8       	sbr	r8,0xf
80002b72:	ef 48 08 00 	st.w	r7[2048],r8
	otg_unfreeze_clock();
80002b76:	ee f8 08 00 	ld.w	r8,r7[2048]
80002b7a:	af c8       	cbr	r8,0xe
80002b7c:	ef 48 08 00 	st.w	r7[2048],r8
	(void)Is_otg_clock_frozen();
80002b80:	ee f8 08 00 	ld.w	r8,r7[2048]

static void udd_ep_job_table_reset(void)
{
	uint8_t i;
	for (i = 0; i < USB_DEVICE_MAX_EP; i++) {
		udd_ep_job[i].busy = false;
80002b84:	4a 28       	lddpc	r8,80002c0c <udd_enable+0xf4>
80002b86:	70 0a       	ld.w	r10,r8[0x0]
80002b88:	30 09       	mov	r9,0
		udd_ep_job[i].stall_requested = false;
80002b8a:	f5 da c0 1f 	bfextu	r10,r10,0x0,0x1f
80002b8e:	f5 d9 d3 81 	bfins	r10,r9,0x1c,0x1
80002b92:	91 0a       	st.w	r8[0x0],r10

static void udd_ep_job_table_reset(void)
{
	uint8_t i;
	for (i = 0; i < USB_DEVICE_MAX_EP; i++) {
		udd_ep_job[i].busy = false;
80002b94:	70 4a       	ld.w	r10,r8[0x10]
		udd_ep_job[i].stall_requested = false;
80002b96:	f5 da c0 1f 	bfextu	r10,r10,0x0,0x1f
80002b9a:	f5 d9 d3 81 	bfins	r10,r9,0x1c,0x1
80002b9e:	91 4a       	st.w	r8[0x10],r10

static void udd_ep_job_table_reset(void)
{
	uint8_t i;
	for (i = 0; i < USB_DEVICE_MAX_EP; i++) {
		udd_ep_job[i].busy = false;
80002ba0:	70 8a       	ld.w	r10,r8[0x20]
		udd_ep_job[i].stall_requested = false;
80002ba2:	f5 da c0 1f 	bfextu	r10,r10,0x0,0x1f
80002ba6:	f5 d9 d3 81 	bfins	r10,r9,0x1c,0x1
80002baa:	91 8a       	st.w	r8[0x20],r10

	// Set the USB speed requested by configuration file
#ifdef USB_DEVICE_LOW_SPEED
	udd_low_speed_enable();
#else
	udd_low_speed_disable();
80002bac:	6e 08       	ld.w	r8,r7[0x0]
80002bae:	ad c8       	cbr	r8,0xc
80002bb0:	8f 08       	st.w	r7[0x0],r8
#  ifdef USB_DEVICE_HS_SUPPORT
	udd_high_speed_enable();
#  else
	udd_high_speed_disable();
80002bb2:	6e 08       	ld.w	r8,r7[0x0]
80002bb4:	e8 18 0c 00 	orl	r8,0xc00
80002bb8:	8f 08       	st.w	r7[0x0],r8
#  endif
#endif
	udd_enable_vbus_interrupt();
80002bba:	ee f8 08 00 	ld.w	r8,r7[2048]
80002bbe:	a1 b8       	sbr	r8,0x1
80002bc0:	ef 48 08 00 	st.w	r7[2048],r8
	otg_freeze_clock();
80002bc4:	ee f8 08 00 	ld.w	r8,r7[2048]
80002bc8:	af a8       	sbr	r8,0xe
80002bca:	ef 48 08 00 	st.w	r7[2048],r8
	// Always authorize asynchrone USB interrupts to exit of sleep mode
	AVR32_PM.AWEN.usb_waken = 1;
80002bce:	fe 78 0c 00 	mov	r8,-62464
80002bd2:	f0 fa 01 44 	ld.w	r10,r8[324]
80002bd6:	30 1b       	mov	r11,1
80002bd8:	f5 db d0 01 	bfins	r10,r11,0x0,0x1
80002bdc:	f1 4a 01 44 	st.w	r8[324],r10

#ifndef UDD_NO_SLEEP_MGR
	// Initialize the sleep mode authorized for the USB suspend mode
	udd_b_idle = false;
80002be0:	48 c8       	lddpc	r8,80002c10 <udd_enable+0xf8>
80002be2:	b0 89       	st.b	r8[0x0],r9

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002be4:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
80002be8:	d3 03       	ssrf	0x10
	Assert(sleepmgr_locks[mode] < 0xff);

	// Enter a critical section
	flags = cpu_irq_save();

	++sleepmgr_locks[mode];
80002bea:	48 b8       	lddpc	r8,80002c14 <udd_enable+0xfc>
80002bec:	11 ba       	ld.ub	r10,r8[0x3]
80002bee:	2f fa       	sub	r10,-1
80002bf0:	b0 ba       	st.b	r8[0x3],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002bf2:	e3 b9 00 00 	mtsr	0x0,r9
80002bf6:	e3 b6 00 00 	mtsr	0x0,r6
	sleepmgr_lock_mode(USBB_SLEEP_MODE_USB_SUSPEND);
#endif

	cpu_irq_restore(flags);
}
80002bfa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002bfe:	00 00       	add	r0,r0
80002c00:	80 00       	ld.sh	r0,r0[0x0]
80002c02:	32 c0       	mov	r0,44
80002c04:	80 00       	ld.sh	r0,r0[0x0]
80002c06:	2c 18       	sub	r8,-63
80002c08:	80 00       	ld.sh	r0,r0[0x0]
80002c0a:	22 38       	sub	r8,35
80002c0c:	00 00       	add	r0,r0
80002c0e:	07 18       	ld.sh	r8,r3++
80002c10:	00 00       	add	r0,r0
80002c12:	07 48       	ld.w	r8,--r3
80002c14:	00 00       	add	r0,r0
80002c16:	0a 18       	sub	r8,r5

80002c18 <udd_interrupt>:
#define AVR32_USBB_IRQ_GROUP AVR32_USB_IRQ_GROUP
#endif
#endif
ISR(udd_interrupt, AVR32_USBB_IRQ_GROUP, UDD_USB_INT_LEVEL)
#endif
{
80002c18:	eb cd 40 fc 	pushm	r2-r7,lr
	if (Is_udd_sof()) {
80002c1c:	fe 68 00 00 	mov	r8,-131072
80002c20:	70 18       	ld.w	r8,r8[0x4]
80002c22:	e2 18 00 04 	andl	r8,0x4,COH
80002c26:	c0 f0       	breq	80002c44 <udd_interrupt+0x2c>
		udd_ack_sof();
80002c28:	fe 68 00 00 	mov	r8,-131072
80002c2c:	30 49       	mov	r9,4
80002c2e:	91 29       	st.w	r8[0x8],r9
		if (Is_udd_full_speed_mode()) {
80002c30:	f0 f8 08 04 	ld.w	r8,r8[2052]
80002c34:	f1 d8 c1 82 	bfextu	r8,r8,0xc,0x2
80002c38:	e0 81 02 ce 	brne	800031d4 <udd_interrupt+0x5bc>
		udc_sof_notify();
80002c3c:	f0 1f 01 6f 	mcall	800031f8 <udd_interrupt+0x5e0>
80002c40:	e0 8f 02 ca 	bral	800031d4 <udd_interrupt+0x5bc>
#ifdef UDC_SOF_EVENT
		UDC_SOF_EVENT();
#endif
		goto udd_interrupt_end;
	}
	if (Is_udd_msof()) {
80002c44:	fe 68 00 00 	mov	r8,-131072
80002c48:	70 18       	ld.w	r8,r8[0x4]
80002c4a:	e2 18 00 02 	andl	r8,0x2,COH
80002c4e:	c0 90       	breq	80002c60 <udd_interrupt+0x48>
		udd_ack_msof();
80002c50:	30 29       	mov	r9,2
80002c52:	fe 68 00 00 	mov	r8,-131072
80002c56:	91 29       	st.w	r8[0x8],r9
		udc_sof_notify();
80002c58:	f0 1f 01 68 	mcall	800031f8 <udd_interrupt+0x5e0>
		goto udd_interrupt_end;
80002c5c:	e0 8f 02 bc 	bral	800031d4 <udd_interrupt+0x5bc>


static bool udd_ctrl_interrupt(void)
{

	if (!Is_udd_endpoint_interrupt(0))
80002c60:	fe 68 00 00 	mov	r8,-131072
80002c64:	70 18       	ld.w	r8,r8[0x4]
80002c66:	e2 18 10 00 	andl	r8,0x1000,COH
80002c6a:	e0 80 01 6f 	breq	80002f48 <udd_interrupt+0x330>
		return false;	// No interrupt events on control endpoint

	// By default disable overflow and underflow interrupt
	udd_disable_nak_in_interrupt(0);
80002c6e:	fe 68 02 20 	mov	r8,-130528
80002c72:	31 09       	mov	r9,16
80002c74:	91 09       	st.w	r8[0x0],r9
	udd_disable_nak_out_interrupt(0);
80002c76:	30 89       	mov	r9,8
80002c78:	91 09       	st.w	r8[0x0],r9


	// Search event on control endpoint
	if (Is_udd_setup_received(0)) {
80002c7a:	fe 68 01 30 	mov	r8,-130768
80002c7e:	70 08       	ld.w	r8,r8[0x0]
80002c80:	e2 18 00 04 	andl	r8,0x4,COH
80002c84:	e0 80 00 87 	breq	80002d92 <udd_interrupt+0x17a>
static void udd_ctrl_setup_received(void)
{
	irqflags_t flags;
	uint8_t i;

	if (UDD_EPCTRL_SETUP != udd_ep_control_state) {
80002c88:	fe f8 05 74 	ld.w	r8,pc[1396]
80002c8c:	70 08       	ld.w	r8,r8[0x0]
80002c8e:	58 08       	cp.w	r8,0
80002c90:	c0 50       	breq	80002c9a <udd_interrupt+0x82>
		// May be a hidden DATA or ZLP phase
		// or protocol abort
		udd_ctrl_endofrequest();
80002c92:	f0 1f 01 5c 	mcall	80003200 <udd_interrupt+0x5e8>
		// Reinitializes control endpoint management
		udd_ctrl_init();
80002c96:	f0 1f 01 5c 	mcall	80003204 <udd_interrupt+0x5ec>
	}
	// Fill setup request structure
	if (8 != udd_byte_count(0)) {
80002c9a:	fe 68 01 30 	mov	r8,-130768
80002c9e:	70 08       	ld.w	r8,r8[0x0]
80002ca0:	f1 d8 c2 8b 	bfextu	r8,r8,0x14,0xb
80002ca4:	58 88       	cp.w	r8,8
80002ca6:	c0 90       	breq	80002cb8 <udd_interrupt+0xa0>
		udd_ctrl_stall_data();
80002ca8:	f0 1f 01 58 	mcall	80003208 <udd_interrupt+0x5f0>
		udd_ack_setup_received(0);
80002cac:	30 49       	mov	r9,4
80002cae:	fe 68 01 60 	mov	r8,-130720
80002cb2:	91 09       	st.w	r8[0x0],r9
80002cb4:	e0 8f 02 90 	bral	800031d4 <udd_interrupt+0x5bc>
80002cb8:	fc 18 e0 00 	movh	r8,0xe000
		return;	// Error data number doesn't correspond to SETUP packet
	}
	uint8_t *ptr = (uint8_t *) & udd_get_endpoint_fifo_access(0,8);
	for (i = 0; i < 8; i++) {
		((uint8_t*) &udd_g_ctrlreq.req)[i] = *ptr++;
80002cbc:	fe fc 05 50 	ld.w	r12,pc[1360]
80002cc0:	fc 1b 20 00 	movh	r11,0x2000
80002cc4:	f0 0c 00 09 	add	r9,r8,r12
80002cc8:	11 3a       	ld.ub	r10,r8++
80002cca:	f2 0b 0b 0a 	st.b	r9[r11],r10
		udd_ctrl_stall_data();
		udd_ack_setup_received(0);
		return;	// Error data number doesn't correspond to SETUP packet
	}
	uint8_t *ptr = (uint8_t *) & udd_get_endpoint_fifo_access(0,8);
	for (i = 0; i < 8; i++) {
80002cce:	30 8a       	mov	r10,8
80002cd0:	ea 1a e0 00 	orh	r10,0xe000
80002cd4:	14 38       	cp.w	r8,r10
80002cd6:	cf 71       	brne	80002cc4 <udd_interrupt+0xac>
		((uint8_t*) &udd_g_ctrlreq.req)[i] = *ptr++;
	}
	// Manage LSB/MSB to fit with CPU usage
	udd_g_ctrlreq.req.wValue = le16_to_cpu(udd_g_ctrlreq.req.wValue);
80002cd8:	fe f8 05 34 	ld.w	r8,pc[1332]
80002cdc:	90 19       	ld.sh	r9,r8[0x2]
80002cde:	5c c9       	swap.bh	r9
80002ce0:	b0 19       	st.h	r8[0x2],r9
	udd_g_ctrlreq.req.wIndex = le16_to_cpu(udd_g_ctrlreq.req.wIndex);
80002ce2:	90 29       	ld.sh	r9,r8[0x4]
80002ce4:	5c c9       	swap.bh	r9
80002ce6:	b0 29       	st.h	r8[0x4],r9
	udd_g_ctrlreq.req.wLength = le16_to_cpu(udd_g_ctrlreq.req.wLength);
80002ce8:	90 39       	ld.sh	r9,r8[0x6]
80002cea:	5c c9       	swap.bh	r9
80002cec:	b0 39       	st.h	r8[0x6],r9

	// Decode setup request
	if (udc_process_setup() == false) {
80002cee:	f0 1f 01 49 	mcall	80003210 <udd_interrupt+0x5f8>
80002cf2:	c0 91       	brne	80002d04 <udd_interrupt+0xec>
		// Setup request unknow then stall it
		udd_ctrl_stall_data();
80002cf4:	f0 1f 01 45 	mcall	80003208 <udd_interrupt+0x5f0>
		udd_ack_setup_received(0);
80002cf8:	30 49       	mov	r9,4
80002cfa:	fe 68 01 60 	mov	r8,-130720
80002cfe:	91 09       	st.w	r8[0x0],r9
80002d00:	e0 8f 02 6a 	bral	800031d4 <udd_interrupt+0x5bc>
		return;
	}
	udd_ack_setup_received(0);
80002d04:	30 49       	mov	r9,4
80002d06:	fe 68 01 60 	mov	r8,-130720
80002d0a:	91 09       	st.w	r8[0x0],r9

	if (Udd_setup_is_in()) {
80002d0c:	fe f8 05 00 	ld.w	r8,pc[1280]
80002d10:	11 89       	ld.ub	r9,r8[0x0]
80002d12:	30 08       	mov	r8,0
80002d14:	f0 09 18 00 	cp.b	r9,r8
80002d18:	c1 94       	brge	80002d4a <udd_interrupt+0x132>
		// Compute if an IN ZLP must be send after IN data
		udd_ctrl_payload_need_in_zlp =
80002d1a:	fe f8 04 f2 	ld.w	r8,pc[1266]
80002d1e:	90 e8       	ld.uh	r8,r8[0xc]
80002d20:	f1 d8 c0 06 	bfextu	r8,r8,0x0,0x6
80002d24:	5f 09       	sreq	r9
80002d26:	fe f8 04 ee 	ld.w	r8,pc[1262]
80002d2a:	b0 89       	st.b	r8[0x0],r9
				((udd_g_ctrlreq.payload_size %
						USB_DEVICE_EP_CTRL_SIZE) == 0);
		// IN data phase requested
		udd_ctrl_prev_payload_nb_trans = 0;
80002d2c:	30 08       	mov	r8,0
80002d2e:	fe f9 04 ea 	ld.w	r9,pc[1258]
80002d32:	b2 08       	st.h	r9[0x0],r8
		udd_ctrl_payload_nb_trans = 0;
80002d34:	fe f9 04 e8 	ld.w	r9,pc[1256]
80002d38:	b2 08       	st.h	r9[0x0],r8
		udd_ep_control_state = UDD_EPCTRL_DATA_IN;
80002d3a:	30 29       	mov	r9,2
80002d3c:	fe f8 04 c0 	ld.w	r8,pc[1216]
80002d40:	91 09       	st.w	r8[0x0],r9
		udd_ctrl_in_sent();	// Send first data transfer
80002d42:	f0 1f 01 38 	mcall	80003220 <udd_interrupt+0x608>
80002d46:	e0 8f 02 47 	bral	800031d4 <udd_interrupt+0x5bc>
	} else {
		if (0 == udd_g_ctrlreq.req.wLength) {
80002d4a:	fe f8 04 c2 	ld.w	r8,pc[1218]
80002d4e:	90 39       	ld.sh	r9,r8[0x6]
80002d50:	30 08       	mov	r8,0
80002d52:	f0 09 19 00 	cp.h	r9,r8
80002d56:	c0 51       	brne	80002d60 <udd_interrupt+0x148>
			// No data phase requested
			// Send IN ZLP to ACK setup request
			udd_ctrl_send_zlp_in();
80002d58:	f0 1f 01 33 	mcall	80003224 <udd_interrupt+0x60c>
80002d5c:	e0 8f 02 3c 	bral	800031d4 <udd_interrupt+0x5bc>
			return;
		}
		// OUT data phase requested
		udd_ctrl_prev_payload_nb_trans = 0;
80002d60:	30 08       	mov	r8,0
80002d62:	fe f9 04 b6 	ld.w	r9,pc[1206]
80002d66:	b2 08       	st.h	r9[0x0],r8
		udd_ctrl_payload_nb_trans = 0;
80002d68:	fe f9 04 b4 	ld.w	r9,pc[1204]
80002d6c:	b2 08       	st.h	r9[0x0],r8
		udd_ep_control_state = UDD_EPCTRL_DATA_OUT;
80002d6e:	30 19       	mov	r9,1
80002d70:	fe f8 04 8c 	ld.w	r8,pc[1164]
80002d74:	91 09       	st.w	r8[0x0],r9
		// To detect a protocol error, enable nak interrupt on data IN phase
		udd_ack_nak_in(0);
80002d76:	31 08       	mov	r8,16
80002d78:	fe 69 01 60 	mov	r9,-130720
80002d7c:	93 08       	st.w	r9[0x0],r8

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002d7e:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
80002d82:	d3 03       	ssrf	0x10
		flags = cpu_irq_save();
		udd_enable_nak_in_interrupt(0);
80002d84:	fe 6a 01 f0 	mov	r10,-130576
80002d88:	95 08       	st.w	r10[0x0],r8
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002d8a:	e3 b9 00 00 	mtsr	0x0,r9
#endif
	barrier();
80002d8e:	e0 8f 02 23 	bral	800031d4 <udd_interrupt+0x5bc>
	if (Is_udd_setup_received(0)) {
		// SETUP packet received
		udd_ctrl_setup_received();
		return true;
	}
	if (Is_udd_in_send(0) && Is_udd_in_send_interrupt_enabled(0)) {
80002d92:	fe 68 01 30 	mov	r8,-130768
80002d96:	70 08       	ld.w	r8,r8[0x0]
80002d98:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80002d9c:	c0 b0       	breq	80002db2 <udd_interrupt+0x19a>
80002d9e:	fe 68 01 c0 	mov	r8,-130624
80002da2:	70 08       	ld.w	r8,r8[0x0]
80002da4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80002da8:	c0 50       	breq	80002db2 <udd_interrupt+0x19a>
		// IN packet sent
		udd_ctrl_in_sent();
80002daa:	f0 1f 01 1e 	mcall	80003220 <udd_interrupt+0x608>
80002dae:	e0 8f 02 13 	bral	800031d4 <udd_interrupt+0x5bc>
		return true;
	}
	if (Is_udd_out_received(0)) {
80002db2:	fe 68 01 30 	mov	r8,-130768
80002db6:	70 08       	ld.w	r8,r8[0x0]
80002db8:	e2 18 00 02 	andl	r8,0x2,COH
80002dbc:	e0 80 00 a3 	breq	80002f02 <udd_interrupt+0x2ea>
{
	irqflags_t flags;
	uint8_t i;
	uint16_t nb_data;

	if (UDD_EPCTRL_DATA_OUT != udd_ep_control_state) {
80002dc0:	fe f8 04 3c 	ld.w	r8,pc[1084]
80002dc4:	70 08       	ld.w	r8,r8[0x0]
80002dc6:	58 18       	cp.w	r8,1
80002dc8:	c1 10       	breq	80002dea <udd_interrupt+0x1d2>
		if ((UDD_EPCTRL_DATA_IN == udd_ep_control_state)
80002dca:	58 28       	cp.w	r8,2
80002dcc:	5f 09       	sreq	r9
80002dce:	58 48       	cp.w	r8,4
80002dd0:	5f 08       	sreq	r8
80002dd2:	f3 e8 10 08 	or	r8,r9,r8
80002dd6:	c0 40       	breq	80002dde <udd_interrupt+0x1c6>
						udd_ep_control_state)) {
			// End of SETUP request:
			// - Data IN Phase aborted,
			// - or last Data IN Phase hidden by ZLP OUT sending quiclky,
			// - or ZLP OUT received normaly.
			udd_ctrl_endofrequest();
80002dd8:	f0 1f 01 0a 	mcall	80003200 <udd_interrupt+0x5e8>
80002ddc:	c0 38       	rjmp	80002de2 <udd_interrupt+0x1ca>
		} else {
			// Protocol error during SETUP request
			udd_ctrl_stall_data();
80002dde:	f0 1f 01 0b 	mcall	80003208 <udd_interrupt+0x5f0>
		}
		// Reinitializes control endpoint management
		udd_ctrl_init();
80002de2:	f0 1f 01 09 	mcall	80003204 <udd_interrupt+0x5ec>
80002de6:	e0 8f 01 f7 	bral	800031d4 <udd_interrupt+0x5bc>
		return;
	}
	// Read data received during OUT phase
	nb_data = udd_byte_count(0);
80002dea:	fe 68 01 30 	mov	r8,-130768
80002dee:	70 0b       	ld.w	r11,r8[0x0]
80002df0:	f7 db c2 8b 	bfextu	r11,r11,0x14,0xb
	if (udd_g_ctrlreq.payload_size < (udd_ctrl_payload_nb_trans + nb_data)) {
80002df4:	fe f8 04 18 	ld.w	r8,pc[1048]
80002df8:	90 69       	ld.sh	r9,r8[0xc]
80002dfa:	fe f8 04 22 	ld.w	r8,pc[1058]
80002dfe:	90 08       	ld.sh	r8,r8[0x0]
80002e00:	f9 d9 c0 10 	bfextu	r12,r9,0x0,0x10
80002e04:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
80002e08:	f6 0a 00 0a 	add	r10,r11,r10
80002e0c:	14 3c       	cp.w	r12,r10
80002e0e:	c0 44       	brge	80002e16 <udd_interrupt+0x1fe>
		// Payload buffer too small
		nb_data = udd_g_ctrlreq.payload_size -
80002e10:	10 19       	sub	r9,r8
80002e12:	f7 d9 b0 10 	bfexts	r11,r9,0x0,0x10
				udd_ctrl_payload_nb_trans;
	}
	uint8_t *ptr_src = (uint8_t *) & udd_get_endpoint_fifo_access(0, 8);
	uint8_t *ptr_dest = udd_g_ctrlreq.payload + udd_ctrl_payload_nb_trans;
80002e16:	fe f9 03 f6 	ld.w	r9,pc[1014]
80002e1a:	72 29       	ld.w	r9,r9[0x8]
	for (i = 0; i < nb_data; i++) {
80002e1c:	58 0b       	cp.w	r11,0
80002e1e:	e0 80 01 e2 	breq	800031e2 <udd_interrupt+0x5ca>
		// Payload buffer too small
		nb_data = udd_g_ctrlreq.payload_size -
				udd_ctrl_payload_nb_trans;
	}
	uint8_t *ptr_src = (uint8_t *) & udd_get_endpoint_fifo_access(0, 8);
	uint8_t *ptr_dest = udd_g_ctrlreq.payload + udd_ctrl_payload_nb_trans;
80002e22:	5c 78       	castu.h	r8
80002e24:	10 09       	add	r9,r8
80002e26:	fc 18 e0 00 	movh	r8,0xe000
	for (i = 0; i < nb_data; i++) {
		*ptr_dest++ = *ptr_src++;
80002e2a:	11 3a       	ld.ub	r10,r8++
80002e2c:	12 ca       	st.b	r9++,r10
		nb_data = udd_g_ctrlreq.payload_size -
				udd_ctrl_payload_nb_trans;
	}
	uint8_t *ptr_src = (uint8_t *) & udd_get_endpoint_fifo_access(0, 8);
	uint8_t *ptr_dest = udd_g_ctrlreq.payload + udd_ctrl_payload_nb_trans;
	for (i = 0; i < nb_data; i++) {
80002e2e:	f5 d8 c0 08 	bfextu	r10,r8,0x0,0x8
80002e32:	f6 0a 19 00 	cp.h	r10,r11
80002e36:	cf a3       	brcs	80002e2a <udd_interrupt+0x212>
		*ptr_dest++ = *ptr_src++;
	}
	udd_ctrl_payload_nb_trans += nb_data;
80002e38:	fe f9 03 e4 	ld.w	r9,pc[996]
80002e3c:	92 08       	ld.sh	r8,r9[0x0]
80002e3e:	16 08       	add	r8,r11
80002e40:	5c 88       	casts.h	r8
80002e42:	b2 08       	st.h	r9[0x0],r8

	if ((USB_DEVICE_EP_CTRL_SIZE != nb_data)
80002e44:	34 09       	mov	r9,64
80002e46:	f2 0b 19 00 	cp.h	r11,r9
80002e4a:	c0 e1       	brne	80002e66 <udd_interrupt+0x24e>
80002e4c:	fe f9 03 c0 	ld.w	r9,pc[960]
80002e50:	92 ba       	ld.uh	r10,r9[0x6]
80002e52:	f7 d8 c0 10 	bfextu	r11,r8,0x0,0x10
80002e56:	fe f9 03 c2 	ld.w	r9,pc[962]
80002e5a:	92 89       	ld.uh	r9,r9[0x0]
80002e5c:	f6 09 00 09 	add	r9,r11,r9
80002e60:	12 3a       	cp.w	r10,r9
80002e62:	e0 89 00 1a 	brgt	80002e96 <udd_interrupt+0x27e>
							udd_ctrl_payload_nb_trans)))
	{
		// End of reception because it is a short packet
		// Before send ZLP, call intermediat calback 
		// in case of data receiv generate a stall
		udd_g_ctrlreq.payload_size = udd_ctrl_payload_nb_trans;
80002e66:	fe f9 03 a6 	ld.w	r9,pc[934]
80002e6a:	b2 68       	st.h	r9[0xc],r8
		if (NULL != udd_g_ctrlreq.over_under_run) {
80002e6c:	72 5c       	ld.w	r12,r9[0x14]
80002e6e:	58 0c       	cp.w	r12,0
80002e70:	c0 b0       	breq	80002e86 <udd_interrupt+0x26e>
			if (!udd_g_ctrlreq.over_under_run()) {
80002e72:	5d 1c       	icall	r12
80002e74:	c0 91       	brne	80002e86 <udd_interrupt+0x26e>
				// Stall ZLP
				udd_ctrl_stall_data();
80002e76:	f0 1f 00 e5 	mcall	80003208 <udd_interrupt+0x5f0>
				// Ack reception of OUT to replace NAK by a STALL
				udd_ack_out_received(0);
80002e7a:	30 29       	mov	r9,2
80002e7c:	fe 68 01 60 	mov	r8,-130720
80002e80:	91 09       	st.w	r8[0x0],r9
80002e82:	e0 8f 01 a9 	bral	800031d4 <udd_interrupt+0x5bc>
				return;
			}
		}
		// Send IN ZLP to ACK setup request
		udd_ack_out_received(0);
80002e86:	30 29       	mov	r9,2
80002e88:	fe 68 01 60 	mov	r8,-130720
80002e8c:	91 09       	st.w	r8[0x0],r9
		udd_ctrl_send_zlp_in();
80002e8e:	f0 1f 00 e6 	mcall	80003224 <udd_interrupt+0x60c>
80002e92:	e0 8f 01 a1 	bral	800031d4 <udd_interrupt+0x5bc>
		return;
	}

	if (udd_g_ctrlreq.payload_size == udd_ctrl_payload_nb_trans) {
80002e96:	fe f9 03 76 	ld.w	r9,pc[886]
80002e9a:	92 69       	ld.sh	r9,r9[0xc]
80002e9c:	f0 09 19 00 	cp.h	r9,r8
80002ea0:	c2 21       	brne	80002ee4 <udd_interrupt+0x2cc>
		// Overrun then request a new payload buffer
		if (!udd_g_ctrlreq.over_under_run) {
80002ea2:	fe f8 03 6a 	ld.w	r8,pc[874]
80002ea6:	70 5c       	ld.w	r12,r8[0x14]
80002ea8:	58 0c       	cp.w	r12,0
80002eaa:	c0 91       	brne	80002ebc <udd_interrupt+0x2a4>
			// No callback availabled to request a new payload buffer
			udd_ctrl_stall_data();
80002eac:	f0 1f 00 d7 	mcall	80003208 <udd_interrupt+0x5f0>
			// Ack reception of OUT to replace NAK by a STALL
			udd_ack_out_received(0);
80002eb0:	30 29       	mov	r9,2
80002eb2:	fe 68 01 60 	mov	r8,-130720
80002eb6:	91 09       	st.w	r8[0x0],r9
80002eb8:	e0 8f 01 8e 	bral	800031d4 <udd_interrupt+0x5bc>
			return;
		}
		if (!udd_g_ctrlreq.over_under_run()) {
80002ebc:	5d 1c       	icall	r12
80002ebe:	c0 81       	brne	80002ece <udd_interrupt+0x2b6>
			// No new payload buffer delivered
			udd_ctrl_stall_data();
80002ec0:	f0 1f 00 d2 	mcall	80003208 <udd_interrupt+0x5f0>
			// Ack reception of OUT to replace NAK by a STALL
			udd_ack_out_received(0);
80002ec4:	30 29       	mov	r9,2
80002ec6:	fe 68 01 60 	mov	r8,-130720
80002eca:	91 09       	st.w	r8[0x0],r9
80002ecc:	c8 49       	rjmp	800031d4 <udd_interrupt+0x5bc>
			return;
		}
		// New payload buffer available
		// Update number of total data received
		udd_ctrl_prev_payload_nb_trans += udd_ctrl_payload_nb_trans;
80002ece:	fe f9 03 4a 	ld.w	r9,pc[842]
80002ed2:	fe f8 03 4a 	ld.w	r8,pc[842]
80002ed6:	90 0b       	ld.sh	r11,r8[0x0]
80002ed8:	92 0a       	ld.sh	r10,r9[0x0]
80002eda:	f6 0a 00 0a 	add	r10,r11,r10
80002ede:	b2 0a       	st.h	r9[0x0],r10
		// Reinit reception on payload buffer
		udd_ctrl_payload_nb_trans = 0;
80002ee0:	30 09       	mov	r9,0
80002ee2:	b0 09       	st.h	r8[0x0],r9
	}
	// Free buffer of control endpoint to authorize next reception
	udd_ack_out_received(0);
80002ee4:	fe 69 01 60 	mov	r9,-130720
80002ee8:	30 28       	mov	r8,2
80002eea:	93 08       	st.w	r9[0x0],r8
	// To detect a protocol error, enable nak interrupt on data IN phase
	udd_ack_nak_in(0);
80002eec:	31 08       	mov	r8,16
80002eee:	93 08       	st.w	r9[0x0],r8

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002ef0:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
80002ef4:	d3 03       	ssrf	0x10
	flags = cpu_irq_save();
	udd_enable_nak_in_interrupt(0);
80002ef6:	fe 6a 01 f0 	mov	r10,-130576
80002efa:	95 08       	st.w	r10[0x0],r8
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002efc:	e3 b9 00 00 	mtsr	0x0,r9
#endif
	barrier();
80002f00:	c6 a9       	rjmp	800031d4 <udd_interrupt+0x5bc>
	if (Is_udd_out_received(0)) {
		// OUT packet received
		udd_ctrl_out_received();
		return true;
	}
	if (Is_udd_nak_out(0)) {
80002f02:	fe 68 01 30 	mov	r8,-130768
80002f06:	70 08       	ld.w	r8,r8[0x0]
80002f08:	e2 18 00 08 	andl	r8,0x8,COH
80002f0c:	c1 80       	breq	80002f3c <udd_interrupt+0x324>
		// Overflow on OUT packet
		udd_ack_nak_out(0);
80002f0e:	30 89       	mov	r9,8
80002f10:	fe 68 01 60 	mov	r8,-130720
80002f14:	91 09       	st.w	r8[0x0],r9
}


static void udd_ctrl_overflow(void)
{
	if (Is_udd_in_send(0))
80002f16:	fe 68 01 30 	mov	r8,-130768
80002f1a:	70 08       	ld.w	r8,r8[0x0]
80002f1c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80002f20:	e0 81 01 5a 	brne	800031d4 <udd_interrupt+0x5bc>
		return;	// overflow ignored if IN data is received

	// The case of UDD_EPCTRL_DATA_IN is not managed
	// because the OUT endpoint is already free and OUT ZLP accepted

	if (UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP == udd_ep_control_state) {
80002f24:	fe f8 02 d8 	ld.w	r8,pc[728]
80002f28:	70 08       	ld.w	r8,r8[0x0]
80002f2a:	58 38       	cp.w	r8,3
80002f2c:	e0 81 01 54 	brne	800031d4 <udd_interrupt+0x5bc>
		// A IN handshake is waiting by device,
		// but host want extra OUT data then stall extra OUT data
		udd_enable_stall_handshake(0);
80002f30:	e8 69 00 00 	mov	r9,524288
80002f34:	fe 68 01 f0 	mov	r8,-130576
80002f38:	91 09       	st.w	r8[0x0],r9
80002f3a:	c4 d9       	rjmp	800031d4 <udd_interrupt+0x5bc>
		// Overflow on OUT packet
		udd_ack_nak_out(0);
		udd_ctrl_overflow();
		return true;
	}
	if (Is_udd_nak_in(0)) {
80002f3c:	fe 68 01 30 	mov	r8,-130768
80002f40:	70 08       	ld.w	r8,r8[0x0]
80002f42:	e2 18 00 10 	andl	r8,0x10,COH
80002f46:	c0 e1       	brne	80002f62 <udd_interrupt+0x34a>
80002f48:	fe f7 02 e0 	ld.w	r7,pc[736]
80002f4c:	0e 9a       	mov	r10,r7
80002f4e:	fe 69 01 34 	mov	r9,-130764
80002f52:	30 0b       	mov	r11,0
	for (ep = 1; ep <= USB_DEVICE_MAX_EP; ep++) {
		// Get job corresponding at endpoint
		ptr_job = &udd_ep_job[ep - 1];
		
		// Check DMA event
		if (Is_udd_endpoint_dma_interrupt_enabled(ep)
80002f54:	fe 66 00 00 	mov	r6,-131072
80002f58:	fc 14 02 00 	movh	r4,0x200
			// Call callback to signal end of transfer
			udd_ep_finish_job(ptr_job, false);
			return true;
		}
		// Check empty bank interrupt event
		if (Is_udd_endpoint_interrupt_enabled(ep)) {
80002f5c:	e0 63 10 00 	mov	r3,4096
80002f60:	c1 e8       	rjmp	80002f9c <udd_interrupt+0x384>
		udd_ctrl_overflow();
		return true;
	}
	if (Is_udd_nak_in(0)) {
		// Underflow on IN packet
		udd_ack_nak_in(0);
80002f62:	31 09       	mov	r9,16
80002f64:	fe 68 01 60 	mov	r8,-130720
80002f68:	91 09       	st.w	r8[0x0],r9
}


static void udd_ctrl_underflow(void)
{
	if (Is_udd_out_received(0))
80002f6a:	fe 68 01 30 	mov	r8,-130768
80002f6e:	70 08       	ld.w	r8,r8[0x0]
80002f70:	e2 18 00 02 	andl	r8,0x2,COH
80002f74:	e0 81 01 30 	brne	800031d4 <udd_interrupt+0x5bc>
		return;	// underflow ignored if OUT data is received

	if (UDD_EPCTRL_DATA_OUT == udd_ep_control_state) {
80002f78:	fe f8 02 84 	ld.w	r8,pc[644]
80002f7c:	70 08       	ld.w	r8,r8[0x0]
80002f7e:	58 18       	cp.w	r8,1
80002f80:	c0 41       	brne	80002f88 <udd_interrupt+0x370>
		// Host want to stop OUT transaction
		// then stop to wait OUT data phase and wait IN ZLP handshake
		udd_ctrl_send_zlp_in();
80002f82:	f0 1f 00 a9 	mcall	80003224 <udd_interrupt+0x60c>
80002f86:	c2 79       	rjmp	800031d4 <udd_interrupt+0x5bc>
	} else if (UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP == udd_ep_control_state) {
80002f88:	58 48       	cp.w	r8,4
80002f8a:	e0 81 01 25 	brne	800031d4 <udd_interrupt+0x5bc>
		// A OUT handshake is waiting by device,
		// but host want extra IN data then stall extra IN data
		udd_enable_stall_handshake(0);
80002f8e:	e8 69 00 00 	mov	r9,524288
80002f92:	fe 68 01 f0 	mov	r8,-130576
80002f96:	91 09       	st.w	r8[0x0],r9
80002f98:	c1 e9       	rjmp	800031d4 <udd_interrupt+0x5bc>
80002f9a:	10 9b       	mov	r11,r8
80002f9c:	f6 c8 ff ff 	sub	r8,r11,-1
80002fa0:	14 9c       	mov	r12,r10
	for (ep = 1; ep <= USB_DEVICE_MAX_EP; ep++) {
		// Get job corresponding at endpoint
		ptr_job = &udd_ep_job[ep - 1];
		
		// Check DMA event
		if (Is_udd_endpoint_dma_interrupt_enabled(ep)
80002fa2:	6c 45       	ld.w	r5,r6[0x10]
80002fa4:	10 9e       	mov	lr,r8
80002fa6:	e8 0b 09 4b 	lsl	r11,r4,r11
80002faa:	f7 e5 00 05 	and	r5,r11,r5
80002fae:	c4 b0       	breq	80003044 <udd_interrupt+0x42c>
				&& Is_udd_endpoint_dma_interrupt(ep)) {
80002fb0:	6c 15       	ld.w	r5,r6[0x4]
	for (ep = 1; ep <= USB_DEVICE_MAX_EP; ep++) {
		// Get job corresponding at endpoint
		ptr_job = &udd_ep_job[ep - 1];
		
		// Check DMA event
		if (Is_udd_endpoint_dma_interrupt_enabled(ep)
80002fb2:	f7 e5 00 05 	and	r5,r11,r5
80002fb6:	c4 70       	breq	80003044 <udd_interrupt+0x42c>
				&& Is_udd_endpoint_dma_interrupt(ep)) {
			uint32_t nb_remaining;
			udd_disable_endpoint_dma_interrupt(ep);
80002fb8:	fe 69 00 00 	mov	r9,-131072
80002fbc:	93 5b       	st.w	r9[0x14],r11
			if (ptr_job->b_raise_dma) {
80002fbe:	74 09       	ld.w	r9,r10[0x0]
80002fc0:	e6 19 20 00 	andh	r9,0x2000,COH
80002fc4:	c0 50       	breq	80002fce <udd_interrupt+0x3b6>
				// In case of manual raise DMA interrupt
				// to process a ZLP packet
				udd_raise_endpoint_dma_interrupt(ep);
80002fc6:	fe 69 00 00 	mov	r9,-131072
80002fca:	93 3b       	st.w	r9[0xc],r11
80002fcc:	c0 a8       	rjmp	80002fe0 <udd_interrupt+0x3c8>
			}else{
				// Save number of data no transfered
				nb_remaining = (udd_endpoint_dma_get_status(ep) &
80002fce:	f0 09 15 04 	lsl	r9,r8,0x4
80002fd2:	e0 39 fd 00 	sub	r9,130304
80002fd6:	72 39       	ld.w	r9,r9[0xc]
						AVR32_USBB_UDDMA1_STATUS_CH_BYTE_CNT_MASK)
						>> AVR32_USBB_UDDMA1_STATUS_CH_BYTE_CNT_OFFSET;
				// Update number of data transfered
				ptr_job->buf_size -= nb_remaining;
80002fd8:	b1 89       	lsr	r9,0x10
80002fda:	74 2a       	ld.w	r10,r10[0x8]
80002fdc:	12 1a       	sub	r10,r9
80002fde:	99 2a       	st.w	r12[0x8],r10
			}

			if (Is_udd_endpoint_in(ep)) {
80002fe0:	a3 68       	lsl	r8,0x2
80002fe2:	fe 6b 01 00 	mov	r11,-130816
80002fe6:	f0 0b 00 09 	add	r9,r8,r11
80002fea:	72 09       	ld.w	r9,r9[0x0]
80002fec:	e2 19 01 00 	andl	r9,0x100,COH
80002ff0:	c2 60       	breq	8000303c <udd_interrupt+0x424>
				// Transfer complet on IN
				if (ptr_job->b_send_zlp) {
80002ff2:	78 09       	ld.w	r9,r12[0x0]
80002ff4:	e6 19 40 00 	andh	r9,0x4000,COH
80002ff8:	c2 20       	breq	8000303c <udd_interrupt+0x424>
					// Need to send a ZLP after data transfer
					// enable interrupt to wait a free bank to sent ZLP
					udd_ack_in_send(ep);
80002ffa:	fe 6a 01 60 	mov	r10,-130720
80002ffe:	f0 0a 00 09 	add	r9,r8,r10
80003002:	30 1a       	mov	r10,1
80003004:	93 0a       	st.w	r9[0x0],r10
					if (Is_udd_write_enabled(ep)) {
80003006:	fe 6b 01 30 	mov	r11,-130768
8000300a:	f0 0b 00 09 	add	r9,r8,r11
8000300e:	72 0a       	ld.w	r10,r9[0x0]
						udd_raise_in_send(ep);
80003010:	fe 6b 01 90 	mov	r11,-130672
80003014:	f0 0b 00 09 	add	r9,r8,r11
				// Transfer complet on IN
				if (ptr_job->b_send_zlp) {
					// Need to send a ZLP after data transfer
					// enable interrupt to wait a free bank to sent ZLP
					udd_ack_in_send(ep);
					if (Is_udd_write_enabled(ep)) {
80003018:	e6 1a 00 01 	andh	r10,0x1,COH
						udd_raise_in_send(ep);
8000301c:	f9 ba 01 01 	movne	r10,1
80003020:	f3 fa 1a 00 	st.wne	r9[0x0],r10
					}
					udd_enable_in_send_interrupt(ep);
80003024:	e0 38 fe 10 	sub	r8,130576
80003028:	30 19       	mov	r9,1
8000302a:	91 09       	st.w	r8[0x0],r9
					udd_enable_endpoint_interrupt(ep);
8000302c:	e0 68 10 00 	mov	r8,4096
80003030:	f0 0e 09 4e 	lsl	lr,r8,lr
80003034:	fe 68 00 00 	mov	r8,-131072
80003038:	91 6e       	st.w	r8[0x18],lr
8000303a:	cc d8       	rjmp	800031d4 <udd_interrupt+0x5bc>
					return true;
				}
			}
			// Call callback to signal end of transfer
			udd_ep_finish_job(ptr_job, false);
8000303c:	30 0b       	mov	r11,0
8000303e:	f0 1f 00 7c 	mcall	8000322c <udd_interrupt+0x614>
80003042:	cc 98       	rjmp	800031d4 <udd_interrupt+0x5bc>
			return true;
		}
		// Check empty bank interrupt event
		if (Is_udd_endpoint_interrupt_enabled(ep)) {
80003044:	6c 4b       	ld.w	r11,r6[0x10]
80003046:	e6 0e 09 4e 	lsl	lr,r3,lr
8000304a:	fd eb 00 0b 	and	r11,lr,r11
8000304e:	c4 60       	breq	800030da <udd_interrupt+0x4c2>
80003050:	e0 7b fe d0 	mov	r11,130768
80003054:	f2 0b 00 02 	add	r2,r9,r11
80003058:	f2 cb ff 70 	sub	r11,r9,-144
			if (Is_udd_in_send_interrupt_enabled(ep) && Is_udd_in_send(ep)) {
8000305c:	76 05       	ld.w	r5,r11[0x0]
8000305e:	eb d5 c0 01 	bfextu	r5,r5,0x0,0x1
80003062:	c1 50       	breq	8000308c <udd_interrupt+0x474>
80003064:	72 05       	ld.w	r5,r9[0x0]
80003066:	eb d5 c0 01 	bfextu	r5,r5,0x0,0x1
8000306a:	c1 10       	breq	8000308c <udd_interrupt+0x474>
				udd_disable_in_send_interrupt(ep);
8000306c:	fe 6a 02 20 	mov	r10,-130528
80003070:	e4 0a 00 08 	add	r8,r2,r10
80003074:	30 19       	mov	r9,1
80003076:	91 09       	st.w	r8[0x0],r9
				// One bank is free then send a ZLP
				udd_ack_in_send(ep);
80003078:	e0 32 fe a0 	sub	r2,130720
8000307c:	85 09       	st.w	r2[0x0],r9
				udd_ack_fifocon(ep);
8000307e:	e0 69 40 00 	mov	r9,16384
80003082:	91 09       	st.w	r8[0x0],r9
				udd_ep_finish_job(ptr_job, false);
80003084:	30 0b       	mov	r11,0
80003086:	f0 1f 00 6a 	mcall	8000322c <udd_interrupt+0x614>
8000308a:	ca 58       	rjmp	800031d4 <udd_interrupt+0x5bc>
				return true;
			}
			if (Is_udd_bank_interrupt_enabled(ep) && (0==udd_nb_busy_bank(ep))) {
8000308c:	76 0b       	ld.w	r11,r11[0x0]
8000308e:	e2 1b 10 00 	andl	r11,0x1000,COH
80003092:	c2 40       	breq	800030da <udd_interrupt+0x4c2>
80003094:	72 0b       	ld.w	r11,r9[0x0]
80003096:	f7 db c1 82 	bfextu	r11,r11,0xc,0x2
8000309a:	c2 01       	brne	800030da <udd_interrupt+0x4c2>
				// End of background transfer on IN endpoint
				udd_disable_bank_interrupt(ep);
8000309c:	fe 69 02 20 	mov	r9,-130528
800030a0:	e4 09 00 08 	add	r8,r2,r9
800030a4:	e0 69 10 00 	mov	r9,4096
800030a8:	91 09       	st.w	r8[0x0],r9
				udd_disable_endpoint_interrupt(ep);
800030aa:	fe 68 00 00 	mov	r8,-131072
800030ae:	91 5e       	st.w	r8[0x14],lr

				Assert(ptr_job->stall_requested);
				// A stall has been requested during backgound transfer
				ptr_job->stall_requested = false;
800030b0:	78 08       	ld.w	r8,r12[0x0]
800030b2:	30 09       	mov	r9,0
800030b4:	f1 d9 d3 81 	bfins	r8,r9,0x1c,0x1
800030b8:	99 08       	st.w	r12[0x0],r8
				udd_disable_endpoint_bank_autoswitch(ep);
800030ba:	fe 6b 01 00 	mov	r11,-130816
800030be:	e4 0b 00 08 	add	r8,r2,r11
800030c2:	70 09       	ld.w	r9,r8[0x0]
800030c4:	a9 d9       	cbr	r9,0x9
800030c6:	91 09       	st.w	r8[0x0],r9
				udd_enable_stall_handshake(ep);
800030c8:	e0 32 fe 10 	sub	r2,130576
800030cc:	e8 68 00 00 	mov	r8,524288
800030d0:	85 08       	st.w	r2[0x0],r8
				udd_reset_data_toggle(ep);
800030d2:	e4 68 00 00 	mov	r8,262144
800030d6:	85 08       	st.w	r2[0x0],r8
800030d8:	c7 e8       	rjmp	800031d4 <udd_interrupt+0x5bc>
800030da:	2f 0a       	sub	r10,-16
800030dc:	2f c9       	sub	r9,-4
{
	udd_ep_id_t ep;
	udd_ep_job_t *ptr_job;

	// For each endpoint different of control endpoint (0)
	for (ep = 1; ep <= USB_DEVICE_MAX_EP; ep++) {
800030de:	58 38       	cp.w	r8,3
800030e0:	fe 91 ff 5d 	brne	80002f9a <udd_interrupt+0x382>
800030e4:	c8 38       	rjmp	800031ea <udd_interrupt+0x5d2>
		goto udd_interrupt_end;	// Interrupt acked by bulk/interrupt/isochronous endpoint managed
#endif

	// USB bus reset detection
	if (Is_udd_reset()) {
		udd_ack_reset();
800030e6:	30 89       	mov	r9,8
800030e8:	fe 68 00 00 	mov	r8,-131072
800030ec:	91 29       	st.w	r8[0x8],r9
#if __ICCAVR32__
#if !defined(AVR32_USBB_IRQ_GROUP)
#define AVR32_USBB_IRQ_GROUP AVR32_USB_IRQ_GROUP
#endif
#endif
ISR(udd_interrupt, AVR32_USBB_IRQ_GROUP, UDD_USB_INT_LEVEL)
800030ee:	ee c6 ff d0 	sub	r6,r7,-48
static void udd_ep_job_table_kill(void)
{
	uint8_t i;
	// For each endpoint, kill job
	for (i = 0; i < USB_DEVICE_MAX_EP; i++) {
		udd_ep_finish_job(&udd_ep_job[i], true);
800030f2:	30 15       	mov	r5,1
800030f4:	0a 9b       	mov	r11,r5
800030f6:	0e 9c       	mov	r12,r7
800030f8:	f0 1f 00 4d 	mcall	8000322c <udd_interrupt+0x614>
800030fc:	2f 07       	sub	r7,-16

static void udd_ep_job_table_kill(void)
{
	uint8_t i;
	// For each endpoint, kill job
	for (i = 0; i < USB_DEVICE_MAX_EP; i++) {
800030fe:	0c 37       	cp.w	r7,r6
80003100:	cf a1       	brne	800030f4 <udd_interrupt+0x4dc>
		// Abort all jobs on-going
#if (0!=USB_DEVICE_MAX_EP)
		udd_ep_job_table_kill();
#endif
		// Reset USB Device Stack Core
		udc_reset();
80003102:	f0 1f 00 4c 	mcall	80003230 <udd_interrupt+0x618>
		// Reset endpoint control
		udd_reset_ep_ctrl();
80003106:	f0 1f 00 4c 	mcall	80003234 <udd_interrupt+0x61c>
		// Reset endpoint control management
		udd_ctrl_init();
8000310a:	f0 1f 00 3f 	mcall	80003204 <udd_interrupt+0x5ec>
		goto udd_interrupt_end;
8000310e:	c6 38       	rjmp	800031d4 <udd_interrupt+0x5bc>
	}

	if (Is_udd_suspend_interrupt_enabled() && Is_udd_suspend()) {
80003110:	fe 68 00 00 	mov	r8,-131072
80003114:	70 48       	ld.w	r8,r8[0x10]
80003116:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000311a:	c1 b0       	breq	80003150 <udd_interrupt+0x538>
8000311c:	fe 68 00 00 	mov	r8,-131072
80003120:	70 18       	ld.w	r8,r8[0x4]
80003122:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80003126:	c1 50       	breq	80003150 <udd_interrupt+0x538>
		otg_unfreeze_clock();
80003128:	fe 68 00 00 	mov	r8,-131072
8000312c:	f0 f9 08 00 	ld.w	r9,r8[2048]
80003130:	af c9       	cbr	r9,0xe
80003132:	f1 49 08 00 	st.w	r8[2048],r9
		// The suspend interrupt is automatic acked when a wakeup occur
		udd_disable_suspend_interrupt();
80003136:	30 19       	mov	r9,1
80003138:	91 59       	st.w	r8[0x14],r9
		udd_enable_wake_up_interrupt();
8000313a:	31 09       	mov	r9,16
8000313c:	91 69       	st.w	r8[0x18],r9
		otg_freeze_clock();	// Mandatory to exit of sleep mode after a wakeup event
8000313e:	f0 f9 08 00 	ld.w	r9,r8[2048]
80003142:	af a9       	sbr	r9,0xe
80003144:	f1 49 08 00 	st.w	r8[2048],r9
		udd_sleep_mode(false);	// Enter in SUSPEND mode
80003148:	30 0c       	mov	r12,0
8000314a:	f0 1f 00 3c 	mcall	80003238 <udd_interrupt+0x620>
#ifdef UDC_SUSPEND_EVENT
		UDC_SUSPEND_EVENT();
#endif
		goto udd_interrupt_end;
8000314e:	c4 38       	rjmp	800031d4 <udd_interrupt+0x5bc>
	}

	if (Is_udd_wake_up_interrupt_enabled() && Is_udd_wake_up()) {
80003150:	fe 68 00 00 	mov	r8,-131072
80003154:	70 48       	ld.w	r8,r8[0x10]
80003156:	e2 18 00 10 	andl	r8,0x10,COH
8000315a:	c2 10       	breq	8000319c <udd_interrupt+0x584>
8000315c:	fe 68 00 00 	mov	r8,-131072
80003160:	70 18       	ld.w	r8,r8[0x4]
80003162:	e2 18 00 10 	andl	r8,0x10,COH
80003166:	c1 b0       	breq	8000319c <udd_interrupt+0x584>
		// Ack wakeup interrupt and enable suspend interrupt
		otg_unfreeze_clock();
80003168:	fe 68 00 00 	mov	r8,-131072
8000316c:	f0 f9 08 00 	ld.w	r9,r8[2048]
80003170:	af c9       	cbr	r9,0xe
80003172:	f1 49 08 00 	st.w	r8[2048],r9
		// Check USB clock ready after suspend and eventually sleep USB clock
		while( !Is_clock_usable() ) {
80003176:	c0 58       	rjmp	80003180 <udd_interrupt+0x568>
			if(Is_udd_suspend()) break;   // In case of USB state change in HS
80003178:	70 19       	ld.w	r9,r8[0x4]
8000317a:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
8000317e:	c0 61       	brne	8000318a <udd_interrupt+0x572>

	if (Is_udd_wake_up_interrupt_enabled() && Is_udd_wake_up()) {
		// Ack wakeup interrupt and enable suspend interrupt
		otg_unfreeze_clock();
		// Check USB clock ready after suspend and eventually sleep USB clock
		while( !Is_clock_usable() ) {
80003180:	f0 f9 08 04 	ld.w	r9,r8[2052]
80003184:	e2 19 40 00 	andl	r9,0x4000,COH
80003188:	cf 80       	breq	80003178 <udd_interrupt+0x560>
			if(Is_udd_suspend()) break;   // In case of USB state change in HS
		};
		// The wakeup interrupt is automatic acked when a suspend occur
		udd_disable_wake_up_interrupt();
8000318a:	fe 68 00 00 	mov	r8,-131072
8000318e:	31 09       	mov	r9,16
80003190:	91 59       	st.w	r8[0x14],r9
		udd_enable_suspend_interrupt();
80003192:	30 1c       	mov	r12,1
80003194:	91 6c       	st.w	r8[0x18],r12
		udd_sleep_mode(true);	// Enter in IDLE mode
80003196:	f0 1f 00 29 	mcall	80003238 <udd_interrupt+0x620>
#ifdef UDC_RESUME_EVENT
		UDC_RESUME_EVENT();
#endif
		goto udd_interrupt_end;
8000319a:	c1 d8       	rjmp	800031d4 <udd_interrupt+0x5bc>
	}

	if (Is_udd_vbus_transition()) {
8000319c:	fe 68 00 00 	mov	r8,-131072
800031a0:	f0 f8 08 04 	ld.w	r8,r8[2052]
800031a4:	e2 18 00 02 	andl	r8,0x2,COH
800031a8:	c1 60       	breq	800031d4 <udd_interrupt+0x5bc>
		// Ack VBus transition and send status to high level
		otg_unfreeze_clock();
800031aa:	fe 68 00 00 	mov	r8,-131072
800031ae:	f0 f9 08 00 	ld.w	r9,r8[2048]
800031b2:	af c9       	cbr	r9,0xe
800031b4:	f1 49 08 00 	st.w	r8[2048],r9
		udd_ack_vbus_transition();
800031b8:	30 29       	mov	r9,2
800031ba:	f1 49 08 08 	st.w	r8[2056],r9
		otg_freeze_clock();
800031be:	f0 f9 08 00 	ld.w	r9,r8[2048]
800031c2:	af a9       	sbr	r9,0xe
800031c4:	f1 49 08 00 	st.w	r8[2048],r9
#ifdef UDC_VBUS_EVENT
		UDC_VBUS_EVENT(Is_udd_vbus_high());
800031c8:	f0 fc 08 04 	ld.w	r12,r8[2052]
800031cc:	f9 dc c1 61 	bfextu	r12,r12,0xb,0x1
800031d0:	f0 1f 00 1b 	mcall	8000323c <udd_interrupt+0x624>
#endif
		goto udd_interrupt_end;
	}
udd_interrupt_end:
	otg_data_memory_barrier();
800031d4:	fe 68 00 00 	mov	r8,-131072
800031d8:	f0 f8 08 18 	ld.w	r8,r8[2072]
	return;
}
800031dc:	e3 cd 40 fc 	ldm	sp++,r2-r7,lr
800031e0:	d6 03       	rete
	uint8_t *ptr_src = (uint8_t *) & udd_get_endpoint_fifo_access(0, 8);
	uint8_t *ptr_dest = udd_g_ctrlreq.payload + udd_ctrl_payload_nb_trans;
	for (i = 0; i < nb_data; i++) {
		*ptr_dest++ = *ptr_src++;
	}
	udd_ctrl_payload_nb_trans += nb_data;
800031e2:	48 f9       	lddpc	r9,8000321c <udd_interrupt+0x604>
800031e4:	b2 08       	st.h	r9[0x0],r8
800031e6:	fe 9f fe 40 	bral	80002e66 <udd_interrupt+0x24e>
	if (udd_ep_interrupt())
		goto udd_interrupt_end;	// Interrupt acked by bulk/interrupt/isochronous endpoint managed
#endif

	// USB bus reset detection
	if (Is_udd_reset()) {
800031ea:	fe 68 00 00 	mov	r8,-131072
800031ee:	70 18       	ld.w	r8,r8[0x4]
800031f0:	e2 18 00 08 	andl	r8,0x8,COH
800031f4:	c8 e0       	breq	80003110 <udd_interrupt+0x4f8>
800031f6:	c7 8b       	rjmp	800030e6 <udd_interrupt+0x4ce>
800031f8:	80 00       	ld.sh	r0,r0[0x0]
800031fa:	37 bc       	mov	r12,123
800031fc:	00 00       	add	r0,r0
800031fe:	07 4c       	ld.w	r12,--r3
80003200:	80 00       	ld.sh	r0,r0[0x0]
80003202:	25 3c       	sub	r12,83
80003204:	80 00       	ld.sh	r0,r0[0x0]
80003206:	27 7c       	sub	r12,119
80003208:	80 00       	ld.sh	r0,r0[0x0]
8000320a:	25 24       	sub	r4,82
8000320c:	00 00       	add	r0,r0
8000320e:	0a 00       	add	r0,r5
80003210:	80 00       	ld.sh	r0,r0[0x0]
80003212:	3a 3c       	mov	r12,-93
80003214:	00 00       	add	r0,r0
80003216:	07 50       	ld.sh	r0,--r3
80003218:	00 00       	add	r0,r0
8000321a:	07 14       	ld.sh	r4,r3++
8000321c:	00 00       	add	r0,r0
8000321e:	07 4a       	ld.w	r10,--r3
80003220:	80 00       	ld.sh	r0,r0[0x0]
80003222:	27 dc       	sub	r12,125
80003224:	80 00       	ld.sh	r0,r0[0x0]
80003226:	27 b0       	sub	r0,123
80003228:	00 00       	add	r0,r0
8000322a:	07 18       	ld.sh	r8,r3++
8000322c:	80 00       	ld.sh	r0,r0[0x0]
8000322e:	25 50       	sub	r0,85
80003230:	80 00       	ld.sh	r0,r0[0x0]
80003232:	39 dc       	mov	r12,-99
80003234:	80 00       	ld.sh	r0,r0[0x0]
80003236:	2a 3a       	sub	r10,-93
80003238:	80 00       	ld.sh	r0,r0[0x0]
8000323a:	27 08       	sub	r8,112
8000323c:	80 00       	ld.sh	r0,r0[0x0]
8000323e:	3f 3c       	mov	r12,-13

80003240 <sysclk_priv_enable_module>:

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80003240:	e1 ba 00 00 	mfsr	r10,0x0
	cpu_irq_disable();
80003244:	d3 03       	ssrf	0x10

	/*
	 * Poll MSKRDY before changing mask rather than after, as it's
	 * highly unlikely to actually be cleared at this point.
	 */
	while (!(AVR32_PM.poscsr & (1U << AVR32_PM_POSCSR_MSKRDY))) {
80003246:	fe 78 0c 00 	mov	r8,-62464
8000324a:	71 59       	ld.w	r9,r8[0x54]
8000324c:	e2 19 00 40 	andl	r9,0x40,COH
80003250:	cf d0       	breq	8000324a <sysclk_priv_enable_module+0xa>
		/* Do nothing */
	}

	/* Enable the clock */
	mask = *(&AVR32_PM.cpumask + bus_id);
80003252:	a3 6c       	lsl	r12,0x2
80003254:	e0 2c f3 f8 	sub	r12,62456
80003258:	78 08       	ld.w	r8,r12[0x0]
	mask |= 1U << module_index;
8000325a:	30 19       	mov	r9,1
8000325c:	f2 0b 09 4b 	lsl	r11,r9,r11
80003260:	10 4b       	or	r11,r8
	*(&AVR32_PM.cpumask + bus_id) = mask;
80003262:	99 0b       	st.w	r12[0x0],r11
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80003264:	e3 ba 00 00 	mtsr	0x0,r10

	cpu_irq_restore(flags);
}
80003268:	5e fc       	retal	r12
8000326a:	d7 03       	nop

8000326c <sysclk_enable_pbb_module>:
/**
 * \brief Enable a module clock derived from the PBB clock
 * \param index Index of the module clock in the PBBMASK register
 */
void sysclk_enable_pbb_module(unsigned int index)
{
8000326c:	eb cd 40 e0 	pushm	r5-r7,lr
80003270:	18 96       	mov	r6,r12
80003272:	58 9c       	cp.w	r12,9
80003274:	5f 07       	sreq	r7

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80003276:	e1 b5 00 00 	mfsr	r5,0x0
	cpu_irq_disable();
8000327a:	d3 03       	ssrf	0x10
		pbus_id = 1;

	/* Enable the bridge if necessary */
	flags = cpu_irq_save();

	if (!sysclk_bus_refcount[pbus_id])
8000327c:	48 f8       	lddpc	r8,800032b8 <sysclk_enable_pbb_module+0x4c>
8000327e:	f0 07 07 09 	ld.ub	r9,r8[r7]
80003282:	30 08       	mov	r8,0
80003284:	f0 09 18 00 	cp.b	r9,r8
80003288:	c0 a1       	brne	8000329c <sysclk_enable_pbb_module+0x30>
 * \brief Enable a module clock derived from the HSB clock
 * \param index Index of the module clock in the HSBMASK register
 */
static inline void sysclk_enable_hsb_module(unsigned int index)
{
	sysclk_priv_enable_module(AVR32_PM_CLK_GRP_HSB, index);
8000328a:	ee 0b 15 01 	lsl	r11,r7,0x1
8000328e:	f9 bb 01 06 	movne	r11,6
80003292:	f9 bb 00 02 	moveq	r11,2
80003296:	30 1c       	mov	r12,1
80003298:	f0 1f 00 09 	mcall	800032bc <sysclk_enable_pbb_module+0x50>
		sysclk_enable_hsb_module(2 + (4 * pbus_id));
	sysclk_bus_refcount[pbus_id]++;
8000329c:	48 78       	lddpc	r8,800032b8 <sysclk_enable_pbb_module+0x4c>
8000329e:	f0 07 07 09 	ld.ub	r9,r8[r7]
800032a2:	2f f9       	sub	r9,-1
800032a4:	f0 07 0b 09 	st.b	r8[r7],r9
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
800032a8:	e3 b5 00 00 	mtsr	0x0,r5

	cpu_irq_restore(flags);

	/* Enable the module */
	sysclk_priv_enable_module(AVR32_PM_CLK_GRP_PBB, index);
800032ac:	0c 9b       	mov	r11,r6
800032ae:	30 3c       	mov	r12,3
800032b0:	f0 1f 00 03 	mcall	800032bc <sysclk_enable_pbb_module+0x50>
}
800032b4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800032b8:	00 00       	add	r0,r0
800032ba:	07 54       	ld.sh	r4,--r3
800032bc:	80 00       	ld.sh	r0,r0[0x0]
800032be:	32 40       	mov	r0,36

800032c0 <sysclk_enable_usb>:
 * \pre The USB generick clock must be configurated to 12MHz.
 * CONFIG_USBCLK_SOURCE and CONFIG_USBCLK_DIV must be defined with proper
 * configuration. The selected clock source must also be configured.
 */
void sysclk_enable_usb(void)
{
800032c0:	d4 01       	pushm	lr
	struct genclk_config gcfg;

	sysclk_enable_pbb_module(SYSCLK_USBB_REGS);
800032c2:	30 1c       	mov	r12,1
800032c4:	f0 1f 00 0f 	mcall	80003300 <sysclk_enable_usb+0x40>
800032c8:	30 3b       	mov	r11,3
800032ca:	30 1c       	mov	r12,1
800032cc:	f0 1f 00 0e 	mcall	80003304 <sysclk_enable_usb+0x44>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800032d0:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
800032d4:	d3 03       	ssrf	0x10
#ifdef BOARD_OSC0_HZ
	case OSC_ID_OSC0:
		oscctrl = OSC0_STARTUP_VALUE <<
				AVR32_PM_OSCCTRL0_STARTUP_OFFSET;
		oscctrl |= OSC0_MODE_VALUE << AVR32_PM_OSCCTRL0_MODE_OFFSET;
		AVR32_PM.oscctrl0 = oscctrl;
800032d6:	fe 78 0c 00 	mov	r8,-62464
800032da:	e0 6a 03 07 	mov	r10,775
800032de:	91 aa       	st.w	r8[0x28],r10
		AVR32_PM.mcctrl |= 1U << AVR32_PM_MCCTRL_OSC0EN;
800032e0:	70 0a       	ld.w	r10,r8[0x0]
800032e2:	a3 aa       	sbr	r10,0x2
800032e4:	91 0a       	st.w	r8[0x0],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
800032e6:	e3 b9 00 00 	mtsr	0x0,r9
	cpu_irq_restore(flags);
}

static inline bool osc_is_ready(uint8_t id)
{
	return !!(AVR32_PM.poscsr & (1U << (AVR32_PM_POSCSR_OSC0RDY + id)));
800032ea:	71 59       	ld.w	r9,r8[0x54]
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
	while (!osc_is_ready(id)) {
800032ec:	e2 19 00 80 	andl	r9,0x80,COH
800032f0:	cf d0       	breq	800032ea <sysclk_enable_usb+0x2a>
}

static inline void genclk_enable(const struct genclk_config *cfg,
		unsigned int id)
{
	AVR32_PM.gcctrl[id] = cfg->ctrl | (1U << AVR32_PM_GCCTRL_CEN);
800032f2:	30 49       	mov	r9,4
800032f4:	fe 78 0c 00 	mov	r8,-62464
800032f8:	f1 49 00 70 	st.w	r8[112],r9
		break;
	}

	genclk_config_set_divider(&gcfg, CONFIG_USBCLK_DIV);
	genclk_enable(&gcfg, AVR32_PM_GCLK_USBB);
}
800032fc:	d8 02       	popm	pc
800032fe:	00 00       	add	r0,r0
80003300:	80 00       	ld.sh	r0,r0[0x0]
80003302:	32 6c       	mov	r12,38
80003304:	80 00       	ld.sh	r0,r0[0x0]
80003306:	32 40       	mov	r0,36

80003308 <udi_cdc_data_disable>:
	UDI_CDC_DISABLE_EXT();
}

void udi_cdc_data_disable(void)
{
}
80003308:	5e fc       	retal	r12
8000330a:	d7 03       	nop

8000330c <udi_cdc_comm_setup>:


bool udi_cdc_comm_setup(void)
{
	if (Udd_setup_is_in()) {
8000330c:	49 e8       	lddpc	r8,80003384 <udi_cdc_comm_setup+0x78>
8000330e:	11 88       	ld.ub	r8,r8[0x0]
80003310:	30 09       	mov	r9,0
80003312:	f2 08 18 00 	cp.b	r8,r9
80003316:	c1 84       	brge	80003346 <udi_cdc_comm_setup+0x3a>
		// GET Interface Requests 
		if (Udd_setup_type() == USB_REQ_TYPE_CLASS) {
80003318:	e2 18 00 60 	andl	r8,0x60,COH
8000331c:	e0 48 00 20 	cp.w	r8,32
80003320:	c3 11       	brne	80003382 <udi_cdc_comm_setup+0x76>
			// Requests Class Interface Get
			switch (udd_g_ctrlreq.req.bRequest) {
80003322:	49 98       	lddpc	r8,80003384 <udi_cdc_comm_setup+0x78>
80003324:	11 99       	ld.ub	r9,r8[0x1]
80003326:	32 18       	mov	r8,33
80003328:	f0 09 18 00 	cp.b	r9,r8
8000332c:	c2 b1       	brne	80003382 <udi_cdc_comm_setup+0x76>
			case USB_REQ_CDC_GET_LINE_CODING:
				// Get configuration of CDC line
				if (sizeof(usb_cdc_line_coding_t) !=
8000332e:	49 68       	lddpc	r8,80003384 <udi_cdc_comm_setup+0x78>
80003330:	90 39       	ld.sh	r9,r8[0x6]
80003332:	30 78       	mov	r8,7
80003334:	f0 09 19 00 	cp.h	r9,r8
80003338:	c2 51       	brne	80003382 <udi_cdc_comm_setup+0x76>
						udd_g_ctrlreq.req.wLength)
					return false;	// Error for USB host
				udd_g_ctrlreq.payload =
8000333a:	49 38       	lddpc	r8,80003384 <udi_cdc_comm_setup+0x78>
8000333c:	49 39       	lddpc	r9,80003388 <udi_cdc_comm_setup+0x7c>
8000333e:	91 29       	st.w	r8[0x8],r9
						(uint8_t *) &
						udi_cdc_line_coding;
				udd_g_ctrlreq.payload_size =
80003340:	30 79       	mov	r9,7
80003342:	b0 69       	st.h	r8[0xc],r9
80003344:	5e ff       	retal	1
			}
		}
	}
	if (Udd_setup_is_out()) {
		// SET Interface Requests  
		if (Udd_setup_type() == USB_REQ_TYPE_CLASS) {
80003346:	e2 18 00 60 	andl	r8,0x60,COH
8000334a:	e0 48 00 20 	cp.w	r8,32
8000334e:	c1 a1       	brne	80003382 <udi_cdc_comm_setup+0x76>
			// Requests Class Interface Set
			switch (udd_g_ctrlreq.req.bRequest) {
80003350:	48 d8       	lddpc	r8,80003384 <udi_cdc_comm_setup+0x78>
80003352:	11 98       	ld.ub	r8,r8[0x1]
80003354:	32 09       	mov	r9,32
80003356:	f2 08 18 00 	cp.b	r8,r9
8000335a:	c0 60       	breq	80003366 <udi_cdc_comm_setup+0x5a>
8000335c:	32 29       	mov	r9,34
8000335e:	f2 08 18 00 	cp.b	r8,r9
80003362:	c1 01       	brne	80003382 <udi_cdc_comm_setup+0x76>
80003364:	5e ff       	retal	1
			case USB_REQ_CDC_SET_LINE_CODING:
				// Change configuration of CDC line
				if (sizeof(usb_cdc_line_coding_t) !=
80003366:	48 88       	lddpc	r8,80003384 <udi_cdc_comm_setup+0x78>
80003368:	90 39       	ld.sh	r9,r8[0x6]
8000336a:	30 78       	mov	r8,7
8000336c:	f0 09 19 00 	cp.h	r9,r8
80003370:	c0 91       	brne	80003382 <udi_cdc_comm_setup+0x76>
						udd_g_ctrlreq.req.wLength)
					return false;	// Error for USB host
				udd_g_ctrlreq.callback =
80003372:	48 58       	lddpc	r8,80003384 <udi_cdc_comm_setup+0x78>
80003374:	48 69       	lddpc	r9,8000338c <udi_cdc_comm_setup+0x80>
80003376:	91 49       	st.w	r8[0x10],r9
						udi_cdc_line_coding_received;
				udd_g_ctrlreq.payload =
80003378:	48 49       	lddpc	r9,80003388 <udi_cdc_comm_setup+0x7c>
8000337a:	91 29       	st.w	r8[0x8],r9
						(uint8_t *) &
						udi_cdc_line_coding;
				udd_g_ctrlreq.payload_size =
8000337c:	30 79       	mov	r9,7
8000337e:	b0 69       	st.h	r8[0xc],r9
80003380:	5e ff       	retal	1
						sizeof(udi_cdc_line_coding);
				return true;
80003382:	5e fd       	retal	0
80003384:	00 00       	add	r0,r0
80003386:	0a 00       	add	r0,r5
80003388:	00 00       	add	r0,r0
8000338a:	07 58       	ld.sh	r8,--r3
8000338c:	80 00       	ld.sh	r0,r0[0x0]
8000338e:	33 94       	mov	r4,57

80003390 <udi_cdc_data_setup>:
}

bool udi_cdc_data_setup(void)
{
	return false;  // request Not supported
}
80003390:	5e fd       	retal	0

80003392 <udi_cdc_getsetting>:

uint8_t udi_cdc_getsetting(void)
{
	return 0;      // CDC don't have multiple alternate setting
}
80003392:	5e fd       	retal	0

80003394 <udi_cdc_line_coding_received>:

void udi_cdc_line_coding_received(void)
{
	// Send line coding to component associated to CDC
	UDI_CDC_SET_CODING_EXT((&udi_cdc_line_coding));
}
80003394:	5e fc       	retal	r12
80003396:	d7 03       	nop

80003398 <udi_cdc_is_rx_ready>:
}


bool udi_cdc_is_rx_ready(void)
{
	return (udi_cdc_rx_pos < udi_cdc_rx_buf_nb[udi_cdc_rx_buf_sel]);
80003398:	48 68       	lddpc	r8,800033b0 <udi_cdc_is_rx_ready+0x18>
8000339a:	11 8a       	ld.ub	r10,r8[0x0]
8000339c:	48 68       	lddpc	r8,800033b4 <udi_cdc_is_rx_ready+0x1c>
8000339e:	90 08       	ld.sh	r8,r8[0x0]
800033a0:	48 69       	lddpc	r9,800033b8 <udi_cdc_is_rx_ready+0x20>
800033a2:	f2 0a 04 19 	ld.sh	r9,r9[r10<<0x1]
800033a6:	f0 09 19 00 	cp.h	r9,r8
}
800033aa:	5f bc       	srhi	r12
800033ac:	5e fc       	retal	r12
800033ae:	00 00       	add	r0,r0
800033b0:	00 00       	add	r0,r0
800033b2:	07 ec       	ld.ub	r12,r3[0x6]
800033b4:	00 00       	add	r0,r0
800033b6:	07 e8       	ld.ub	r8,r3[0x6]
800033b8:	00 00       	add	r0,r0
800033ba:	07 e4       	ld.ub	r4,r3[0x6]

800033bc <udi_cdc_is_tx_ready>:


bool udi_cdc_is_tx_ready(void)
{
	irqflags_t flags;
	if (udi_cdc_tx_buf_nb[udi_cdc_tx_buf_sel]!=UDI_CDC_TX_BUFFERS) {
800033bc:	49 58       	lddpc	r8,80003410 <udi_cdc_is_tx_ready+0x54>
800033be:	11 89       	ld.ub	r9,r8[0x0]
800033c0:	49 58       	lddpc	r8,80003414 <udi_cdc_is_tx_ready+0x58>
800033c2:	f0 09 04 19 	ld.sh	r9,r8[r9<<0x1]
800033c6:	34 08       	mov	r8,64
800033c8:	f0 09 19 00 	cp.h	r9,r8
800033cc:	c0 20       	breq	800033d0 <udi_cdc_is_tx_ready+0x14>
800033ce:	5e ff       	retal	1
		return true;
	}
	if (!udi_cdc_tx_both_buf_to_send) {
800033d0:	49 28       	lddpc	r8,80003418 <udi_cdc_is_tx_ready+0x5c>
800033d2:	11 88       	ld.ub	r8,r8[0x0]
800033d4:	58 08       	cp.w	r8,0
800033d6:	c1 21       	brne	800033fa <udi_cdc_is_tx_ready+0x3e>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800033d8:	e1 b8 00 00 	mfsr	r8,0x0
	cpu_irq_disable();
800033dc:	d3 03       	ssrf	0x10
		flags = cpu_irq_save();	// to protect udi_cdc_tx_buf_sel
		if (!udi_cdc_tx_trans_ongoing) {
800033de:	49 09       	lddpc	r9,8000341c <udi_cdc_is_tx_ready+0x60>
800033e0:	13 89       	ld.ub	r9,r9[0x0]
800033e2:	58 09       	cp.w	r9,0
800033e4:	c0 91       	brne	800033f6 <udi_cdc_is_tx_ready+0x3a>
			// No transfer on-going
			// then use the other buffer to store data
			udi_cdc_tx_both_buf_to_send = true;
800033e6:	30 1a       	mov	r10,1
800033e8:	48 c9       	lddpc	r9,80003418 <udi_cdc_is_tx_ready+0x5c>
800033ea:	b2 8a       	st.b	r9[0x0],r10
			udi_cdc_tx_buf_sel = (udi_cdc_tx_buf_sel==0)?1:0;
800033ec:	48 99       	lddpc	r9,80003410 <udi_cdc_is_tx_ready+0x54>
800033ee:	13 8a       	ld.ub	r10,r9[0x0]
800033f0:	58 0a       	cp.w	r10,0
800033f2:	5f 0a       	sreq	r10
800033f4:	b2 8a       	st.b	r9[0x0],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
800033f6:	e3 b8 00 00 	mtsr	0x0,r8
		}
	  	cpu_irq_restore(flags);
	}
	return (udi_cdc_tx_buf_nb[udi_cdc_tx_buf_sel]!=UDI_CDC_TX_BUFFERS);
800033fa:	48 68       	lddpc	r8,80003410 <udi_cdc_is_tx_ready+0x54>
800033fc:	11 89       	ld.ub	r9,r8[0x0]
800033fe:	48 68       	lddpc	r8,80003414 <udi_cdc_is_tx_ready+0x58>
80003400:	f0 09 04 19 	ld.sh	r9,r8[r9<<0x1]
80003404:	34 08       	mov	r8,64
80003406:	f0 09 19 00 	cp.h	r9,r8
8000340a:	5f 1c       	srne	r12
}
8000340c:	5e fc       	retal	r12
8000340e:	00 00       	add	r0,r0
80003410:	00 00       	add	r0,r0
80003412:	07 5f       	ld.sh	pc,--r3
80003414:	00 00       	add	r0,r0
80003416:	07 60       	ld.uh	r0,--r3
80003418:	00 00       	add	r0,r0
8000341a:	08 71       	tst	r1,r4
8000341c:	00 00       	add	r0,r0
8000341e:	07 ee       	ld.ub	lr,r3[0x6]

80003420 <udi_cdc_putc>:


int udi_cdc_putc(int value)
{
80003420:	eb cd 40 fe 	pushm	r1-r7,lr
80003424:	18 97       	mov	r7,r12
	irqflags_t flags;
	bool b_databit_9;
	uint8_t buf_sel;

	b_databit_9 = (9 == udi_cdc_line_coding.bDataBits);
80003426:	49 88       	lddpc	r8,80003484 <udi_cdc_putc+0x64>
80003428:	11 e9       	ld.ub	r9,r8[0x6]
8000342a:	30 98       	mov	r8,9
8000342c:	f0 09 18 00 	cp.b	r9,r8
80003430:	5f 04       	sreq	r4

udi_cdc_putc_process_one_byte:
	// Check avaliable space
	if (!udi_cdc_is_tx_ready()) {
		if (!udi_cdc_running) {
80003432:	49 66       	lddpc	r6,80003488 <udi_cdc_putc+0x68>
		goto udi_cdc_putc_process_one_byte;
	}

	// Write value
	flags = cpu_irq_save();
	buf_sel = udi_cdc_tx_buf_sel;
80003434:	49 63       	lddpc	r3,8000348c <udi_cdc_putc+0x6c>
	udi_cdc_tx_buf[buf_sel][udi_cdc_tx_buf_nb[buf_sel]++] = value;
80003436:	49 75       	lddpc	r5,80003490 <udi_cdc_putc+0x70>
80003438:	49 72       	lddpc	r2,80003494 <udi_cdc_putc+0x74>
	cpu_irq_restore(flags);

	if (b_databit_9) {
		// Send MSB
		b_databit_9 = false;
		value = value >> 8;
8000343a:	30 01       	mov	r1,0

	b_databit_9 = (9 == udi_cdc_line_coding.bDataBits);

udi_cdc_putc_process_one_byte:
	// Check avaliable space
	if (!udi_cdc_is_tx_ready()) {
8000343c:	f0 1f 00 17 	mcall	80003498 <udi_cdc_putc+0x78>
80003440:	c0 51       	brne	8000344a <udi_cdc_putc+0x2a>
		if (!udi_cdc_running) {
80003442:	0d 88       	ld.ub	r8,r6[0x0]
80003444:	58 08       	cp.w	r8,0
80003446:	cf b1       	brne	8000343c <udi_cdc_putc+0x1c>
80003448:	c1 b8       	rjmp	8000347e <udi_cdc_putc+0x5e>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
8000344a:	e1 ba 00 00 	mfsr	r10,0x0
	cpu_irq_disable();
8000344e:	d3 03       	ssrf	0x10
		goto udi_cdc_putc_process_one_byte;
	}

	// Write value
	flags = cpu_irq_save();
	buf_sel = udi_cdc_tx_buf_sel;
80003450:	07 88       	ld.ub	r8,r3[0x0]
	udi_cdc_tx_buf[buf_sel][udi_cdc_tx_buf_nb[buf_sel]++] = value;
80003452:	ea 08 04 19 	ld.sh	r9,r5[r8<<0x1]
80003456:	f7 d9 c0 10 	bfextu	r11,r9,0x0,0x10
8000345a:	f0 0c 15 06 	lsl	r12,r8,0x6
8000345e:	f8 0b 00 0b 	add	r11,r12,r11
80003462:	e4 0b 0b 07 	st.b	r2[r11],r7
80003466:	2f f9       	sub	r9,-1
80003468:	ea 08 0a 19 	st.h	r5[r8<<0x1],r9
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
8000346c:	e3 ba 00 00 	mtsr	0x0,r10
	cpu_irq_restore(flags);

	if (b_databit_9) {
80003470:	58 04       	cp.w	r4,0
80003472:	c0 31       	brne	80003478 <udi_cdc_putc+0x58>
80003474:	e3 cf 90 fe 	ldm	sp++,r1-r7,pc,r12=1
		// Send MSB
		b_databit_9 = false;
		value = value >> 8;
80003478:	a9 47       	asr	r7,0x8
8000347a:	02 94       	mov	r4,r1
8000347c:	ce 0b       	rjmp	8000343c <udi_cdc_putc+0x1c>
		goto udi_cdc_putc_process_one_byte;
8000347e:	e3 cf 80 fe 	ldm	sp++,r1-r7,pc,r12=0
80003482:	00 00       	add	r0,r0
80003484:	00 00       	add	r0,r0
80003486:	07 58       	ld.sh	r8,--r3
80003488:	00 00       	add	r0,r0
8000348a:	07 ed       	ld.ub	sp,r3[0x6]
8000348c:	00 00       	add	r0,r0
8000348e:	07 5f       	ld.sh	pc,--r3
80003490:	00 00       	add	r0,r0
80003492:	07 60       	ld.uh	r0,--r3
80003494:	00 00       	add	r0,r0
80003496:	07 64       	ld.uh	r4,--r3
80003498:	80 00       	ld.sh	r0,r0[0x0]
8000349a:	33 bc       	mov	r12,59

8000349c <udi_cdc_rx_start>:
//-------------------------------------------------
//------- Internal routines to process data transfer


static bool udi_cdc_rx_start(void)
{
8000349c:	eb cd 40 80 	pushm	r7,lr

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800034a0:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
800034a4:	d3 03       	ssrf	0x10
	irqflags_t flags;
	uint8_t buf_sel_trans;

	flags = cpu_irq_save();
	buf_sel_trans = udi_cdc_rx_buf_sel;
800034a6:	49 78       	lddpc	r8,80003500 <udi_cdc_rx_start+0x64>
800034a8:	11 87       	ld.ub	r7,r8[0x0]
	if (udi_cdc_rx_trans_ongoing ||
800034aa:	49 78       	lddpc	r8,80003504 <udi_cdc_rx_start+0x68>
800034ac:	11 88       	ld.ub	r8,r8[0x0]
800034ae:	58 08       	cp.w	r8,0
800034b0:	c0 a1       	brne	800034c4 <udi_cdc_rx_start+0x28>
		(udi_cdc_rx_pos < udi_cdc_rx_buf_nb[buf_sel_trans])) {
800034b2:	49 68       	lddpc	r8,80003508 <udi_cdc_rx_start+0x6c>
800034b4:	90 08       	ld.sh	r8,r8[0x0]
800034b6:	49 6a       	lddpc	r10,8000350c <udi_cdc_rx_start+0x70>
800034b8:	f4 07 04 1a 	ld.sh	r10,r10[r7<<0x1]
800034bc:	f0 0a 19 00 	cp.h	r10,r8
800034c0:	e0 88 00 06 	brls	800034cc <udi_cdc_rx_start+0x30>
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
800034c4:	e3 b9 00 00 	mtsr	0x0,r9
#endif
	barrier();
800034c8:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
		cpu_irq_restore(flags);
		return false;
	}

	// Change current buffer
	udi_cdc_rx_pos = 0;
800034cc:	30 0a       	mov	r10,0
800034ce:	48 f8       	lddpc	r8,80003508 <udi_cdc_rx_start+0x6c>
800034d0:	b0 0a       	st.h	r8[0x0],r10
	udi_cdc_rx_buf_sel = (buf_sel_trans==0)?1:0;
800034d2:	58 07       	cp.w	r7,0
800034d4:	5f 0a       	sreq	r10
800034d6:	48 b8       	lddpc	r8,80003500 <udi_cdc_rx_start+0x64>
800034d8:	b0 8a       	st.b	r8[0x0],r10

	// Start transfer on RX
	udi_cdc_rx_trans_ongoing = true;
800034da:	30 1a       	mov	r10,1
800034dc:	48 a8       	lddpc	r8,80003504 <udi_cdc_rx_start+0x68>
800034de:	b0 8a       	st.b	r8[0x0],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
800034e0:	e3 b9 00 00 	mtsr	0x0,r9
	cpu_irq_restore(flags);
	
	if (udi_cdc_is_rx_ready()) {
800034e4:	f0 1f 00 0b 	mcall	80003510 <udi_cdc_rx_start+0x74>
		UDI_CDC_RX_NOTIFY();
	}

	return udd_ep_run( UDI_CDC_DATA_EP_OUT,
800034e8:	a7 67       	lsl	r7,0x6
800034ea:	48 b8       	lddpc	r8,80003514 <udi_cdc_rx_start+0x78>
800034ec:	34 09       	mov	r9,64
800034ee:	48 ba       	lddpc	r10,80003518 <udi_cdc_rx_start+0x7c>
800034f0:	0e 0a       	add	r10,r7
800034f2:	30 1b       	mov	r11,1
800034f4:	30 2c       	mov	r12,2
800034f6:	f0 1f 00 0a 	mcall	8000351c <udi_cdc_rx_start+0x80>
					true,
					udi_cdc_rx_buf[buf_sel_trans],
					UDI_CDC_RX_BUFFERS,
					udi_cdc_data_recevied);
}
800034fa:	e3 cd 80 80 	ldm	sp++,r7,pc
800034fe:	00 00       	add	r0,r0
80003500:	00 00       	add	r0,r0
80003502:	07 ec       	ld.ub	r12,r3[0x6]
80003504:	00 00       	add	r0,r0
80003506:	08 70       	tst	r0,r4
80003508:	00 00       	add	r0,r0
8000350a:	07 e8       	ld.ub	r8,r3[0x6]
8000350c:	00 00       	add	r0,r0
8000350e:	07 e4       	ld.ub	r4,r3[0x6]
80003510:	80 00       	ld.sh	r0,r0[0x0]
80003512:	33 98       	mov	r8,57
80003514:	80 00       	ld.sh	r0,r0[0x0]
80003516:	35 9c       	mov	r12,89
80003518:	00 00       	add	r0,r0
8000351a:	07 f0       	ld.ub	r0,r3[0x7]
8000351c:	80 00       	ld.sh	r0,r0[0x0]
8000351e:	25 c0       	sub	r0,92

80003520 <udi_cdc_getc>:
	return (udi_cdc_rx_pos < udi_cdc_rx_buf_nb[udi_cdc_rx_buf_sel]);
}


int udi_cdc_getc(void)
{
80003520:	d4 31       	pushm	r0-r7,lr
	int rx_data = 0;
	bool b_databit_9;

	b_databit_9 = (9 == udi_cdc_line_coding.bDataBits);
80003522:	49 88       	lddpc	r8,80003580 <udi_cdc_getc+0x60>
80003524:	11 e9       	ld.ub	r9,r8[0x6]
80003526:	30 98       	mov	r8,9
80003528:	f0 09 18 00 	cp.b	r9,r8
8000352c:	5f 02       	sreq	r2
8000352e:	30 03       	mov	r3,0

udi_cdc_getc_process_one_byte:
	// Check avaliable data
	while (udi_cdc_rx_pos >= udi_cdc_rx_buf_nb[udi_cdc_rx_buf_sel]) {
80003530:	49 56       	lddpc	r6,80003584 <udi_cdc_getc+0x64>
80003532:	49 67       	lddpc	r7,80003588 <udi_cdc_getc+0x68>
80003534:	49 65       	lddpc	r5,8000358c <udi_cdc_getc+0x6c>
		if (!udi_cdc_running) {
80003536:	49 74       	lddpc	r4,80003590 <udi_cdc_getc+0x70>
		}
		goto udi_cdc_getc_process_one_byte;
	}

	// Read data
	rx_data |= udi_cdc_rx_buf[udi_cdc_rx_buf_sel][udi_cdc_rx_pos];
80003538:	49 71       	lddpc	r1,80003594 <udi_cdc_getc+0x74>
	udi_cdc_rx_start();

	if (b_databit_9) {
		// Receive MSB
		b_databit_9 = false;
		rx_data = rx_data << 8;
8000353a:	06 90       	mov	r0,r3
8000353c:	c0 48       	rjmp	80003544 <udi_cdc_getc+0x24>
	b_databit_9 = (9 == udi_cdc_line_coding.bDataBits);

udi_cdc_getc_process_one_byte:
	// Check avaliable data
	while (udi_cdc_rx_pos >= udi_cdc_rx_buf_nb[udi_cdc_rx_buf_sel]) {
		if (!udi_cdc_running) {
8000353e:	09 88       	ld.ub	r8,r4[0x0]
80003540:	58 08       	cp.w	r8,0
80003542:	c1 b0       	breq	80003578 <udi_cdc_getc+0x58>

	b_databit_9 = (9 == udi_cdc_line_coding.bDataBits);

udi_cdc_getc_process_one_byte:
	// Check avaliable data
	while (udi_cdc_rx_pos >= udi_cdc_rx_buf_nb[udi_cdc_rx_buf_sel]) {
80003544:	0d 89       	ld.ub	r9,r6[0x0]
80003546:	8e 08       	ld.sh	r8,r7[0x0]
80003548:	ea 09 04 19 	ld.sh	r9,r5[r9<<0x1]
8000354c:	f0 09 19 00 	cp.h	r9,r8
80003550:	fe 98 ff f7 	brls	8000353e <udi_cdc_getc+0x1e>
		}
		goto udi_cdc_getc_process_one_byte;
	}

	// Read data
	rx_data |= udi_cdc_rx_buf[udi_cdc_rx_buf_sel][udi_cdc_rx_pos];
80003554:	0d 88       	ld.ub	r8,r6[0x0]
80003556:	8e 09       	ld.sh	r9,r7[0x0]
80003558:	5c 79       	castu.h	r9
8000355a:	a7 68       	lsl	r8,0x6
8000355c:	12 08       	add	r8,r9
8000355e:	e2 08 07 08 	ld.ub	r8,r1[r8]
80003562:	10 43       	or	r3,r8
	udi_cdc_rx_pos++;
80003564:	8e 08       	ld.sh	r8,r7[0x0]
80003566:	2f f8       	sub	r8,-1
80003568:	ae 08       	st.h	r7[0x0],r8

	udi_cdc_rx_start();
8000356a:	f0 1f 00 0c 	mcall	80003598 <udi_cdc_getc+0x78>

	if (b_databit_9) {
8000356e:	58 02       	cp.w	r2,0
80003570:	c0 50       	breq	8000357a <udi_cdc_getc+0x5a>
		// Receive MSB
		b_databit_9 = false;
		rx_data = rx_data << 8;
80003572:	a9 63       	lsl	r3,0x8
80003574:	00 92       	mov	r2,r0
80003576:	ce 7b       	rjmp	80003544 <udi_cdc_getc+0x24>
		goto udi_cdc_getc_process_one_byte;
80003578:	30 03       	mov	r3,0
	}
	return rx_data;
}
8000357a:	06 9c       	mov	r12,r3
8000357c:	d8 32       	popm	r0-r7,pc
8000357e:	00 00       	add	r0,r0
80003580:	00 00       	add	r0,r0
80003582:	07 58       	ld.sh	r8,--r3
80003584:	00 00       	add	r0,r0
80003586:	07 ec       	ld.ub	r12,r3[0x6]
80003588:	00 00       	add	r0,r0
8000358a:	07 e8       	ld.ub	r8,r3[0x6]
8000358c:	00 00       	add	r0,r0
8000358e:	07 e4       	ld.ub	r4,r3[0x6]
80003590:	00 00       	add	r0,r0
80003592:	07 ed       	ld.ub	sp,r3[0x6]
80003594:	00 00       	add	r0,r0
80003596:	07 f0       	ld.ub	r0,r3[0x7]
80003598:	80 00       	ld.sh	r0,r0[0x0]
8000359a:	34 9c       	mov	r12,73

8000359c <udi_cdc_data_recevied>:
					udi_cdc_data_recevied);
}


void udi_cdc_data_recevied(udd_ep_status_t status, iram_size_t n)
{
8000359c:	d4 01       	pushm	lr
	uint8_t buf_sel_trans;

	if (UDD_EP_TRANSFER_OK != status) {
8000359e:	58 0c       	cp.w	r12,0
800035a0:	c1 01       	brne	800035c0 <udi_cdc_data_recevied+0x24>
		// Abort reception
		return;
	}
	buf_sel_trans = (udi_cdc_rx_buf_sel==0)?1:0;
800035a2:	48 98       	lddpc	r8,800035c4 <udi_cdc_data_recevied+0x28>
800035a4:	11 88       	ld.ub	r8,r8[0x0]
	udi_cdc_rx_buf_nb[buf_sel_trans] = n;
800035a6:	58 08       	cp.w	r8,0
800035a8:	f9 b8 01 00 	movne	r8,0
800035ac:	f9 b8 00 02 	moveq	r8,2
800035b0:	48 69       	lddpc	r9,800035c8 <udi_cdc_data_recevied+0x2c>
800035b2:	f2 08 0a 0b 	st.h	r9[r8],r11
	udi_cdc_rx_trans_ongoing = false;
800035b6:	30 09       	mov	r9,0
800035b8:	48 58       	lddpc	r8,800035cc <udi_cdc_data_recevied+0x30>
800035ba:	b0 89       	st.b	r8[0x0],r9
	udi_cdc_rx_start();
800035bc:	f0 1f 00 05 	mcall	800035d0 <udi_cdc_data_recevied+0x34>
800035c0:	d8 02       	popm	pc
800035c2:	00 00       	add	r0,r0
800035c4:	00 00       	add	r0,r0
800035c6:	07 ec       	ld.ub	r12,r3[0x6]
800035c8:	00 00       	add	r0,r0
800035ca:	07 e4       	ld.ub	r4,r3[0x6]
800035cc:	00 00       	add	r0,r0
800035ce:	08 70       	tst	r0,r4
800035d0:	80 00       	ld.sh	r0,r0[0x0]
800035d2:	34 9c       	mov	r12,73

800035d4 <udi_cdc_tx_send>:
	udi_cdc_tx_send();
}


static void udi_cdc_tx_send(void)
{
800035d4:	eb cd 40 e0 	pushm	r5-r7,lr
	irqflags_t flags;
	uint8_t buf_sel_trans;
	bool b_short_packet;

	if (udi_cdc_tx_trans_ongoing) {
800035d8:	4a a8       	lddpc	r8,80003680 <udi_cdc_tx_send+0xac>
800035da:	11 88       	ld.ub	r8,r8[0x0]
800035dc:	58 08       	cp.w	r8,0
800035de:	c4 f1       	brne	8000367c <udi_cdc_tx_send+0xa8>
		return; // Already on going or wait next SOF to send next data
	}
	if (udd_is_high_speed()) {
800035e0:	f0 1f 00 29 	mcall	80003684 <udi_cdc_tx_send+0xb0>
800035e4:	c0 a0       	breq	800035f8 <udi_cdc_tx_send+0x24>
		if (udi_cdc_tx_sof_num == udd_get_micro_frame_number()) {
800035e6:	f0 1f 00 29 	mcall	80003688 <udi_cdc_tx_send+0xb4>
800035ea:	4a 98       	lddpc	r8,8000368c <udi_cdc_tx_send+0xb8>
800035ec:	90 08       	ld.sh	r8,r8[0x0]
800035ee:	f8 08 19 00 	cp.h	r8,r12
800035f2:	c0 a1       	brne	80003606 <udi_cdc_tx_send+0x32>
800035f4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			return; // Wait next SOF to send next data
		}
	}else{
		if (udi_cdc_tx_sof_num == udd_get_frame_number()) {
800035f8:	f0 1f 00 26 	mcall	80003690 <udi_cdc_tx_send+0xbc>
800035fc:	4a 48       	lddpc	r8,8000368c <udi_cdc_tx_send+0xb8>
800035fe:	90 08       	ld.sh	r8,r8[0x0]
80003600:	f8 08 19 00 	cp.h	r8,r12
80003604:	c3 c0       	breq	8000367c <udi_cdc_tx_send+0xa8>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80003606:	e1 b8 00 00 	mfsr	r8,0x0
	cpu_irq_disable();
8000360a:	d3 03       	ssrf	0x10
			return; // Wait next SOF to send next data
		}
	}

	flags = cpu_irq_save();	// to protect udi_cdc_tx_buf_sel
	buf_sel_trans = udi_cdc_tx_buf_sel;
8000360c:	4a 29       	lddpc	r9,80003694 <udi_cdc_tx_send+0xc0>
8000360e:	13 87       	ld.ub	r7,r9[0x0]
	if (!udi_cdc_tx_both_buf_to_send) {
80003610:	4a 29       	lddpc	r9,80003698 <udi_cdc_tx_send+0xc4>
80003612:	13 89       	ld.ub	r9,r9[0x0]
80003614:	58 09       	cp.w	r9,0
80003616:	c0 61       	brne	80003622 <udi_cdc_tx_send+0x4e>
		// Send current Buffer
		// and switch the current buffer
		udi_cdc_tx_buf_sel = (buf_sel_trans==0)?1:0;
80003618:	58 07       	cp.w	r7,0
8000361a:	5f 0a       	sreq	r10
8000361c:	49 e9       	lddpc	r9,80003694 <udi_cdc_tx_send+0xc0>
8000361e:	b2 8a       	st.b	r9[0x0],r10
80003620:	c0 38       	rjmp	80003626 <udi_cdc_tx_send+0x52>
	}else{
		// Send the other Buffer
		// and no switch the current buffer
		buf_sel_trans = (buf_sel_trans==0)?1:0;
80003622:	58 07       	cp.w	r7,0
80003624:	5f 07       	sreq	r7
	}
	udi_cdc_tx_trans_ongoing = true;
80003626:	30 1a       	mov	r10,1
80003628:	49 69       	lddpc	r9,80003680 <udi_cdc_tx_send+0xac>
8000362a:	b2 8a       	st.b	r9[0x0],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
8000362c:	e3 b8 00 00 	mtsr	0x0,r8
	cpu_irq_restore(flags);

	b_short_packet = (udi_cdc_tx_buf_nb[buf_sel_trans] != UDI_CDC_TX_BUFFERS);
80003630:	0e 95       	mov	r5,r7
80003632:	49 b8       	lddpc	r8,8000369c <udi_cdc_tx_send+0xc8>
80003634:	f0 07 04 19 	ld.sh	r9,r8[r7<<0x1]
80003638:	34 08       	mov	r8,64
8000363a:	f0 09 19 00 	cp.h	r9,r8
8000363e:	5f 16       	srne	r6
	if (b_short_packet) {
80003640:	58 06       	cp.w	r6,0
80003642:	c0 e0       	breq	8000365e <udi_cdc_tx_send+0x8a>
		if (udd_is_high_speed()) {
80003644:	f0 1f 00 10 	mcall	80003684 <udi_cdc_tx_send+0xb0>
80003648:	c0 60       	breq	80003654 <udi_cdc_tx_send+0x80>
			udi_cdc_tx_sof_num = udd_get_micro_frame_number();
8000364a:	f0 1f 00 10 	mcall	80003688 <udi_cdc_tx_send+0xb4>
8000364e:	49 08       	lddpc	r8,8000368c <udi_cdc_tx_send+0xb8>
80003650:	b0 0c       	st.h	r8[0x0],r12
80003652:	c0 98       	rjmp	80003664 <udi_cdc_tx_send+0x90>
		}else{
			udi_cdc_tx_sof_num = udd_get_frame_number();
80003654:	f0 1f 00 0f 	mcall	80003690 <udi_cdc_tx_send+0xbc>
80003658:	48 d8       	lddpc	r8,8000368c <udi_cdc_tx_send+0xb8>
8000365a:	b0 0c       	st.h	r8[0x0],r12
8000365c:	c0 48       	rjmp	80003664 <udi_cdc_tx_send+0x90>
		}
	}else{
		udi_cdc_tx_sof_num = 0; // Force next transfer without wait SOF
8000365e:	30 09       	mov	r9,0
80003660:	48 b8       	lddpc	r8,8000368c <udi_cdc_tx_send+0xb8>
80003662:	b0 09       	st.h	r8[0x0],r9
	}

	// Send the buffer with enable of short packet
	udd_ep_run( UDI_CDC_DATA_EP_IN,
80003664:	a7 67       	lsl	r7,0x6
80003666:	48 f8       	lddpc	r8,800036a0 <udi_cdc_tx_send+0xcc>
80003668:	48 d9       	lddpc	r9,8000369c <udi_cdc_tx_send+0xc8>
8000366a:	f2 05 05 19 	ld.uh	r9,r9[r5<<0x1]
8000366e:	48 ea       	lddpc	r10,800036a4 <udi_cdc_tx_send+0xd0>
80003670:	0e 0a       	add	r10,r7
80003672:	0c 9b       	mov	r11,r6
80003674:	e0 6c 00 81 	mov	r12,129
80003678:	f0 1f 00 0c 	mcall	800036a8 <udi_cdc_tx_send+0xd4>
8000367c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003680:	00 00       	add	r0,r0
80003682:	07 ee       	ld.ub	lr,r3[0x6]
80003684:	80 00       	ld.sh	r0,r0[0x0]
80003686:	23 ca       	sub	r10,60
80003688:	80 00       	ld.sh	r0,r0[0x0]
8000368a:	24 06       	sub	r6,64
8000368c:	00 00       	add	r0,r0
8000368e:	07 ea       	ld.ub	r10,r3[0x6]
80003690:	80 00       	ld.sh	r0,r0[0x0]
80003692:	23 fa       	sub	r10,63
80003694:	00 00       	add	r0,r0
80003696:	07 5f       	ld.sh	pc,--r3
80003698:	00 00       	add	r0,r0
8000369a:	08 71       	tst	r1,r4
8000369c:	00 00       	add	r0,r0
8000369e:	07 60       	ld.uh	r0,--r3
800036a0:	80 00       	ld.sh	r0,r0[0x0]
800036a2:	36 ac       	mov	r12,106
800036a4:	00 00       	add	r0,r0
800036a6:	07 64       	ld.uh	r4,--r3
800036a8:	80 00       	ld.sh	r0,r0[0x0]
800036aa:	25 c0       	sub	r0,92

800036ac <udi_cdc_data_sent>:
	udi_cdc_rx_start();
}


void udi_cdc_data_sent(udd_ep_status_t status, iram_size_t n)
{
800036ac:	d4 01       	pushm	lr
	if (UDD_EP_TRANSFER_OK != status) {
800036ae:	58 0c       	cp.w	r12,0
800036b0:	c1 21       	brne	800036d4 <udi_cdc_data_sent+0x28>
		// Abort transfer
		return;
	}
	udi_cdc_tx_buf_nb[(udi_cdc_tx_buf_sel==0)?1:0] = 0;
800036b2:	48 a8       	lddpc	r8,800036d8 <udi_cdc_data_sent+0x2c>
800036b4:	11 88       	ld.ub	r8,r8[0x0]
800036b6:	58 08       	cp.w	r8,0
800036b8:	f9 b9 01 00 	movne	r9,0
800036bc:	f9 b9 00 02 	moveq	r9,2
800036c0:	30 08       	mov	r8,0
800036c2:	48 7a       	lddpc	r10,800036dc <udi_cdc_data_sent+0x30>
800036c4:	f4 09 0a 08 	st.h	r10[r9],r8
	udi_cdc_tx_both_buf_to_send = false;
800036c8:	48 69       	lddpc	r9,800036e0 <udi_cdc_data_sent+0x34>
800036ca:	b2 88       	st.b	r9[0x0],r8
	udi_cdc_tx_trans_ongoing = false;
800036cc:	48 69       	lddpc	r9,800036e4 <udi_cdc_data_sent+0x38>
800036ce:	b2 88       	st.b	r9[0x0],r8
	udi_cdc_tx_send();
800036d0:	f0 1f 00 06 	mcall	800036e8 <udi_cdc_data_sent+0x3c>
800036d4:	d8 02       	popm	pc
800036d6:	00 00       	add	r0,r0
800036d8:	00 00       	add	r0,r0
800036da:	07 5f       	ld.sh	pc,--r3
800036dc:	00 00       	add	r0,r0
800036de:	07 60       	ld.uh	r0,--r3
800036e0:	00 00       	add	r0,r0
800036e2:	08 71       	tst	r1,r4
800036e4:	00 00       	add	r0,r0
800036e6:	07 ee       	ld.ub	lr,r3[0x6]
800036e8:	80 00       	ld.sh	r0,r0[0x0]
800036ea:	35 d4       	mov	r4,93

800036ec <udi_cdc_data_sof_notify>:
{
	return 0;      // CDC don't have multiple alternate setting
}

void udi_cdc_data_sof_notify(void)
{
800036ec:	d4 01       	pushm	lr
	udi_cdc_tx_send();
800036ee:	f0 1f 00 02 	mcall	800036f4 <udi_cdc_data_sof_notify+0x8>
}
800036f2:	d8 02       	popm	pc
800036f4:	80 00       	ld.sh	r0,r0[0x0]
800036f6:	35 d4       	mov	r4,93

800036f8 <udi_cdc_data_enable>:
	// to initialize memories or indicate that interface is enabled
	return UDI_CDC_ENABLE_EXT();
}

bool udi_cdc_data_enable(void)
{
800036f8:	eb cd 40 c0 	pushm	r6-r7,lr
	// Initialize TX management
	udi_cdc_tx_trans_ongoing = false;
800036fc:	30 06       	mov	r6,0
800036fe:	48 f8       	lddpc	r8,80003738 <udi_cdc_data_enable+0x40>
80003700:	b0 86       	st.b	r8[0x0],r6
	udi_cdc_tx_both_buf_to_send = false;
80003702:	48 f8       	lddpc	r8,8000373c <udi_cdc_data_enable+0x44>
80003704:	b0 86       	st.b	r8[0x0],r6
	udi_cdc_tx_buf_sel = 0;
80003706:	48 f8       	lddpc	r8,80003740 <udi_cdc_data_enable+0x48>
80003708:	b0 86       	st.b	r8[0x0],r6
	udi_cdc_tx_buf_nb[0] = 0;
8000370a:	48 f8       	lddpc	r8,80003744 <udi_cdc_data_enable+0x4c>
8000370c:	30 07       	mov	r7,0
8000370e:	b0 07       	st.h	r8[0x0],r7
	udi_cdc_tx_buf_nb[1] = 0;
80003710:	b0 17       	st.h	r8[0x2],r7
	udi_cdc_tx_sof_num = 0;
80003712:	48 e8       	lddpc	r8,80003748 <udi_cdc_data_enable+0x50>
80003714:	b0 07       	st.h	r8[0x0],r7
	udi_cdc_tx_send();
80003716:	f0 1f 00 0e 	mcall	8000374c <udi_cdc_data_enable+0x54>

	// Initialize RX management
	udi_cdc_rx_trans_ongoing = false;
8000371a:	48 e8       	lddpc	r8,80003750 <udi_cdc_data_enable+0x58>
8000371c:	b0 86       	st.b	r8[0x0],r6
	udi_cdc_rx_buf_sel = 0;
8000371e:	48 e8       	lddpc	r8,80003754 <udi_cdc_data_enable+0x5c>
80003720:	b0 86       	st.b	r8[0x0],r6
	udi_cdc_rx_buf_nb[0] = 0;
80003722:	48 e8       	lddpc	r8,80003758 <udi_cdc_data_enable+0x60>
80003724:	b0 07       	st.h	r8[0x0],r7
	udi_cdc_rx_pos = 0;
80003726:	48 e8       	lddpc	r8,8000375c <udi_cdc_data_enable+0x64>
80003728:	b0 07       	st.h	r8[0x0],r7
	udi_cdc_running = udi_cdc_rx_start();
8000372a:	f0 1f 00 0e 	mcall	80003760 <udi_cdc_data_enable+0x68>
8000372e:	48 e8       	lddpc	r8,80003764 <udi_cdc_data_enable+0x6c>
80003730:	b0 8c       	st.b	r8[0x0],r12
	return udi_cdc_running;
80003732:	11 8c       	ld.ub	r12,r8[0x0]
}
80003734:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003738:	00 00       	add	r0,r0
8000373a:	07 ee       	ld.ub	lr,r3[0x6]
8000373c:	00 00       	add	r0,r0
8000373e:	08 71       	tst	r1,r4
80003740:	00 00       	add	r0,r0
80003742:	07 5f       	ld.sh	pc,--r3
80003744:	00 00       	add	r0,r0
80003746:	07 60       	ld.uh	r0,--r3
80003748:	00 00       	add	r0,r0
8000374a:	07 ea       	ld.ub	r10,r3[0x6]
8000374c:	80 00       	ld.sh	r0,r0[0x0]
8000374e:	35 d4       	mov	r4,93
80003750:	00 00       	add	r0,r0
80003752:	08 70       	tst	r0,r4
80003754:	00 00       	add	r0,r0
80003756:	07 ec       	ld.ub	r12,r3[0x6]
80003758:	00 00       	add	r0,r0
8000375a:	07 e4       	ld.ub	r4,r3[0x6]
8000375c:	00 00       	add	r0,r0
8000375e:	07 e8       	ld.ub	r8,r3[0x6]
80003760:	80 00       	ld.sh	r0,r0[0x0]
80003762:	34 9c       	mov	r12,73
80003764:	00 00       	add	r0,r0
80003766:	07 ed       	ld.ub	sp,r3[0x6]

80003768 <udi_cdc_comm_disable>:


void udi_cdc_comm_disable(void)
{
80003768:	d4 01       	pushm	lr
	udi_cdc_running = false;
8000376a:	30 09       	mov	r9,0
8000376c:	48 38       	lddpc	r8,80003778 <udi_cdc_comm_disable+0x10>
8000376e:	b0 89       	st.b	r8[0x0],r9
	UDI_CDC_DISABLE_EXT();
80003770:	f0 1f 00 03 	mcall	8000377c <udi_cdc_comm_disable+0x14>
}
80003774:	d8 02       	popm	pc
80003776:	00 00       	add	r0,r0
80003778:	00 00       	add	r0,r0
8000377a:	07 ed       	ld.ub	sp,r3[0x6]
8000377c:	80 00       	ld.sh	r0,r0[0x0]
8000377e:	3f 30       	mov	r0,-13

80003780 <udi_cdc_comm_enable>:

//@}


bool udi_cdc_comm_enable(void)
{
80003780:	d4 01       	pushm	lr
	// Initialize control signal management
	udi_cdc_state = CPU_TO_LE16(0);
80003782:	30 0a       	mov	r10,0
80003784:	48 a8       	lddpc	r8,800037ac <udi_cdc_comm_enable+0x2c>
80003786:	b0 0a       	st.h	r8[0x0],r10
	uid_cdc_state_msg.value = CPU_TO_LE16(0);
80003788:	48 a8       	lddpc	r8,800037b0 <udi_cdc_comm_enable+0x30>
8000378a:	b0 4a       	st.h	r8[0x8],r10

	udi_cdc_line_coding.dwDTERate = CPU_TO_LE32(UDI_CDC_DEFAULT_RATE);
8000378c:	48 a8       	lddpc	r8,800037b4 <udi_cdc_comm_enable+0x34>
8000378e:	30 09       	mov	r9,0
80003790:	b0 8a       	st.b	r8[0x0],r10
80003792:	3c 2a       	mov	r10,-62
80003794:	b0 9a       	st.b	r8[0x1],r10
80003796:	30 1a       	mov	r10,1
80003798:	b0 aa       	st.b	r8[0x2],r10
8000379a:	b0 b9       	st.b	r8[0x3],r9
	udi_cdc_line_coding.bCharFormat = UDI_CDC_DEFAULT_STOPBITS;
8000379c:	b0 c9       	st.b	r8[0x4],r9
	udi_cdc_line_coding.bParityType = UDI_CDC_DEFAULT_PARITY;
8000379e:	b0 d9       	st.b	r8[0x5],r9
	udi_cdc_line_coding.bDataBits = UDI_CDC_DEFAULT_DATABITS;
800037a0:	30 89       	mov	r9,8
800037a2:	b0 e9       	st.b	r8[0x6],r9
	UDI_CDC_SET_CODING_EXT((&udi_cdc_line_coding));

	// Call application callback
	// to initialize memories or indicate that interface is enabled
	return UDI_CDC_ENABLE_EXT();
800037a4:	f0 1f 00 05 	mcall	800037b8 <udi_cdc_comm_enable+0x38>
}
800037a8:	d8 02       	popm	pc
800037aa:	00 00       	add	r0,r0
800037ac:	00 00       	add	r0,r0
800037ae:	08 72       	tst	r2,r4
800037b0:	00 00       	add	r0,r0
800037b2:	00 50       	eor	r0,r0
800037b4:	00 00       	add	r0,r0
800037b6:	07 58       	ld.sh	r8,--r3
800037b8:	80 00       	ld.sh	r0,r0[0x0]
800037ba:	3f 24       	mov	r4,-14

800037bc <udc_sof_notify>:
			CPU_TO_LE16(USB_DEV_STATUS_BUS_POWERED);
#endif
}

void udc_sof_notify(void)
{
800037bc:	eb cd 40 c0 	pushm	r6-r7,lr
	uint8_t iface_num;

	if (udc_num_configuration) {
800037c0:	49 18       	lddpc	r8,80003804 <udc_sof_notify+0x48>
800037c2:	11 89       	ld.ub	r9,r8[0x0]
800037c4:	30 08       	mov	r8,0
800037c6:	f0 09 18 00 	cp.b	r9,r8
800037ca:	c1 b0       	breq	80003800 <udc_sof_notify+0x44>
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
800037cc:	48 f8       	lddpc	r8,80003808 <udc_sof_notify+0x4c>
800037ce:	70 08       	ld.w	r8,r8[0x0]
void udc_sof_notify(void)
{
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
800037d0:	70 09       	ld.w	r9,r8[0x0]
800037d2:	13 ca       	ld.ub	r10,r9[0x4]
800037d4:	30 09       	mov	r9,0
800037d6:	f2 0a 18 00 	cp.b	r10,r9
800037da:	c1 30       	breq	80003800 <udc_sof_notify+0x44>
800037dc:	30 07       	mov	r7,0
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
800037de:	48 b6       	lddpc	r6,80003808 <udc_sof_notify+0x4c>
				iface_num++) {
			if (udc_ptr_conf->udi_apis[iface_num]->sof_notify != NULL) {
800037e0:	70 18       	ld.w	r8,r8[0x4]
800037e2:	f0 07 03 28 	ld.w	r8,r8[r7<<0x2]
800037e6:	70 48       	ld.w	r8,r8[0x10]
800037e8:	58 08       	cp.w	r8,0
800037ea:	c0 20       	breq	800037ee <udc_sof_notify+0x32>
				udc_ptr_conf->udi_apis[iface_num]->sof_notify();
800037ec:	5d 18       	icall	r8
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
				iface_num++) {
800037ee:	2f f7       	sub	r7,-1
800037f0:	5c 57       	castu.b	r7
{
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
800037f2:	6c 08       	ld.w	r8,r6[0x0]
void udc_sof_notify(void)
{
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
800037f4:	70 09       	ld.w	r9,r8[0x0]
800037f6:	13 c9       	ld.ub	r9,r9[0x4]
800037f8:	ee 09 18 00 	cp.b	r9,r7
800037fc:	fe 9b ff f2 	brhi	800037e0 <udc_sof_notify+0x24>
80003800:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003804:	00 00       	add	r0,r0
80003806:	08 7e       	tst	lr,r4
80003808:	00 00       	add	r0,r0
8000380a:	08 78       	tst	r8,r4

8000380c <udc_get_eof_conf>:
 */
static usb_conf_desc_t UDC_DESC_STORAGE *udc_get_eof_conf(void)
{
	return (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *)
			udc_ptr_conf->desc +
			le16_to_cpu(udc_ptr_conf->desc->wTotalLength));
8000380c:	48 78       	lddpc	r8,80003828 <udc_get_eof_conf+0x1c>
8000380e:	70 08       	ld.w	r8,r8[0x0]
80003810:	70 08       	ld.w	r8,r8[0x0]
80003812:	11 aa       	ld.ub	r10,r8[0x2]
80003814:	11 b9       	ld.ub	r9,r8[0x3]
80003816:	f3 ea 10 89 	or	r9,r9,r10<<0x8
8000381a:	5c c9       	swap.bh	r9
8000381c:	f9 d9 c0 10 	bfextu	r12,r9,0x0,0x10
}
80003820:	f0 0c 00 0c 	add	r12,r8,r12
80003824:	5e fc       	retal	r12
80003826:	00 00       	add	r0,r0
80003828:	00 00       	add	r0,r0
8000382a:	08 78       	tst	r8,r4

8000382c <udc_update_iface_desc>:
 * \param setting_num   Setting number of interface to find
 *
 * \return 1 if found or 0 if not found
 */
static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num)
{
8000382c:	eb cd 40 e0 	pushm	r5-r7,lr
80003830:	18 97       	mov	r7,r12
80003832:	16 96       	mov	r6,r11
	usb_conf_desc_t UDC_DESC_STORAGE *ptr_end_desc;

	if (0 == udc_num_configuration)
80003834:	49 b8       	lddpc	r8,800038a0 <udc_update_iface_desc+0x74>
80003836:	11 89       	ld.ub	r9,r8[0x0]
80003838:	30 08       	mov	r8,0
8000383a:	f0 09 18 00 	cp.b	r9,r8
8000383e:	c2 f0       	breq	8000389c <udc_update_iface_desc+0x70>
		return false;

	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces)
80003840:	49 98       	lddpc	r8,800038a4 <udc_update_iface_desc+0x78>
80003842:	70 08       	ld.w	r8,r8[0x0]
80003844:	70 08       	ld.w	r8,r8[0x0]
80003846:	11 c9       	ld.ub	r9,r8[0x4]
80003848:	18 9e       	mov	lr,r12
8000384a:	f8 09 18 00 	cp.b	r9,r12
8000384e:	e0 88 00 27 	brls	8000389c <udc_update_iface_desc+0x70>
		return false;

	// Start at the beginning of configuration descriptor
	udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *)
80003852:	49 65       	lddpc	r5,800038a8 <udc_update_iface_desc+0x7c>
80003854:	8b 08       	st.w	r5[0x0],r8
			udc_ptr_conf->desc;

	// Check the end of configuration descriptor
	ptr_end_desc = udc_get_eof_conf();
80003856:	f0 1f 00 16 	mcall	800038ac <udc_update_iface_desc+0x80>
	while (ptr_end_desc >
8000385a:	6a 08       	ld.w	r8,r5[0x0]
8000385c:	10 3c       	cp.w	r12,r8
8000385e:	e0 88 00 1f 	brls	8000389c <udc_update_iface_desc+0x70>
			(UDC_DESC_STORAGE usb_conf_desc_t *) udc_ptr_iface) {
		if (USB_DT_INTERFACE == udc_ptr_iface->bDescriptorType) {
80003862:	30 4b       	mov	r11,4
	udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *)
			udc_ptr_conf->desc;

	// Check the end of configuration descriptor
	ptr_end_desc = udc_get_eof_conf();
	while (ptr_end_desc >
80003864:	10 99       	mov	r9,r8
			(UDC_DESC_STORAGE usb_conf_desc_t *) udc_ptr_iface) {
		if (USB_DT_INTERFACE == udc_ptr_iface->bDescriptorType) {
80003866:	11 9a       	ld.ub	r10,r8[0x1]
80003868:	f6 0a 18 00 	cp.b	r10,r11
8000386c:	c0 a1       	brne	80003880 <udc_update_iface_desc+0x54>
			// A interface descriptor is found
			// Check interface and alternate setting number
			if ((iface_num == udc_ptr_iface->bInterfaceNumber)
8000386e:	11 aa       	ld.ub	r10,r8[0x2]
80003870:	0e 9e       	mov	lr,r7
80003872:	ee 0a 18 00 	cp.b	r10,r7
80003876:	c0 51       	brne	80003880 <udc_update_iface_desc+0x54>
					&& (setting_num ==
							udc_ptr_iface->
80003878:	11 ba       	ld.ub	r10,r8[0x3]
8000387a:	ec 0a 18 00 	cp.b	r10,r6
8000387e:	c0 b0       	breq	80003894 <udc_update_iface_desc+0x68>
							bAlternateSetting))
				return true;	// Interface found
		}
		// Go to next descriptor
		udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *) ((uint8_t
80003880:	13 88       	ld.ub	r8,r9[0x0]
80003882:	f2 08 00 08 	add	r8,r9,r8
	udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *)
			udc_ptr_conf->desc;

	// Check the end of configuration descriptor
	ptr_end_desc = udc_get_eof_conf();
	while (ptr_end_desc >
80003886:	10 3c       	cp.w	r12,r8
80003888:	fe 9b ff ee 	brhi	80003864 <udc_update_iface_desc+0x38>
8000388c:	48 79       	lddpc	r9,800038a8 <udc_update_iface_desc+0x7c>
8000388e:	93 08       	st.w	r9[0x0],r8
80003890:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
80003894:	48 59       	lddpc	r9,800038a8 <udc_update_iface_desc+0x7c>
80003896:	93 08       	st.w	r9[0x0],r8
80003898:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
8000389c:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
800038a0:	00 00       	add	r0,r0
800038a2:	08 7e       	tst	lr,r4
800038a4:	00 00       	add	r0,r0
800038a6:	08 78       	tst	r8,r4
800038a8:	00 00       	add	r0,r0
800038aa:	08 84       	andn	r4,r4
800038ac:	80 00       	ld.sh	r0,r0[0x0]
800038ae:	38 0c       	mov	r12,-128

800038b0 <udc_next_desc_in_iface>:
 * \return address of specific descriptor found
 * \return NULL if it is the end of global interface descriptor
 */
static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t
		UDC_DESC_STORAGE * desc, uint8_t desc_id)
{
800038b0:	eb cd 40 c0 	pushm	r6-r7,lr
800038b4:	18 96       	mov	r6,r12
800038b6:	16 97       	mov	r7,r11
	usb_conf_desc_t UDC_DESC_STORAGE *ptr_eof_desc;

	ptr_eof_desc = udc_get_eof_conf();
800038b8:	f0 1f 00 11 	mcall	800038fc <udc_next_desc_in_iface+0x4c>
	// Go to next descriptor
	desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
800038bc:	0d 88       	ld.ub	r8,r6[0x0]
800038be:	10 06       	add	r6,r8
			desc->bLength);
	// Check the end of configuration descriptor
	while (ptr_eof_desc > desc) {
800038c0:	0c 3c       	cp.w	r12,r6
800038c2:	e0 88 00 19 	brls	800038f4 <udc_next_desc_in_iface+0x44>
		// If new interface descriptor is found,
		// then it is the end of the current global interface descriptor
		if (USB_DT_INTERFACE == desc->bDescriptorType)
800038c6:	0d 98       	ld.ub	r8,r6[0x1]
800038c8:	30 49       	mov	r9,4
800038ca:	f2 08 18 00 	cp.b	r8,r9
800038ce:	c1 30       	breq	800038f4 <udc_next_desc_in_iface+0x44>
			break;	// End of global interface descriptor
		if (desc_id == desc->bDescriptorType)
800038d0:	ee 08 18 00 	cp.b	r8,r7
800038d4:	c0 a1       	brne	800038e8 <udc_next_desc_in_iface+0x38>
800038d6:	c1 08       	rjmp	800038f6 <udc_next_desc_in_iface+0x46>
			desc->bLength);
	// Check the end of configuration descriptor
	while (ptr_eof_desc > desc) {
		// If new interface descriptor is found,
		// then it is the end of the current global interface descriptor
		if (USB_DT_INTERFACE == desc->bDescriptorType)
800038d8:	0d 98       	ld.ub	r8,r6[0x1]
800038da:	f2 08 18 00 	cp.b	r8,r9
800038de:	c0 b0       	breq	800038f4 <udc_next_desc_in_iface+0x44>
			break;	// End of global interface descriptor
		if (desc_id == desc->bDescriptorType)
800038e0:	ee 08 18 00 	cp.b	r8,r7
800038e4:	c0 31       	brne	800038ea <udc_next_desc_in_iface+0x3a>
800038e6:	c0 88       	rjmp	800038f6 <udc_next_desc_in_iface+0x46>
			desc->bLength);
	// Check the end of configuration descriptor
	while (ptr_eof_desc > desc) {
		// If new interface descriptor is found,
		// then it is the end of the current global interface descriptor
		if (USB_DT_INTERFACE == desc->bDescriptorType)
800038e8:	30 49       	mov	r9,4
			break;	// End of global interface descriptor
		if (desc_id == desc->bDescriptorType)
			return desc;	// Specific descriptor found
		// Go to next descriptor
		desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
800038ea:	0d 88       	ld.ub	r8,r6[0x0]
800038ec:	10 06       	add	r6,r8
	ptr_eof_desc = udc_get_eof_conf();
	// Go to next descriptor
	desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
			desc->bLength);
	// Check the end of configuration descriptor
	while (ptr_eof_desc > desc) {
800038ee:	0c 3c       	cp.w	r12,r6
800038f0:	fe 9b ff f4 	brhi	800038d8 <udc_next_desc_in_iface+0x28>
800038f4:	30 06       	mov	r6,0
		// Go to next descriptor
		desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
				desc->bLength);
	}
	return NULL;	// No specific descriptor found
}
800038f6:	0c 9c       	mov	r12,r6
800038f8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800038fc:	80 00       	ld.sh	r0,r0[0x0]
800038fe:	38 0c       	mov	r12,-128

80003900 <udc_valid_address>:
/**
 * \brief Change the address of device
 * Callback called at the end of request set address
 */
static void udc_valid_address(void)
{
80003900:	d4 01       	pushm	lr
	udd_set_address(udd_g_ctrlreq.req.wValue & 0x7F);
80003902:	48 48       	lddpc	r8,80003910 <udc_valid_address+0x10>
80003904:	11 bc       	ld.ub	r12,r8[0x3]
80003906:	f9 dc c0 07 	bfextu	r12,r12,0x0,0x7
8000390a:	f0 1f 00 03 	mcall	80003914 <udc_valid_address+0x14>
}
8000390e:	d8 02       	popm	pc
80003910:	00 00       	add	r0,r0
80003912:	0a 00       	add	r0,r5
80003914:	80 00       	ld.sh	r0,r0[0x0]
80003916:	23 cc       	sub	r12,60

80003918 <udc_iface_enable>:
 * \param setting_num   Setting number to enable
 *
 * \return 1 if it is done or 0 if interface is not found
 */
static bool udc_iface_enable(uint8_t iface_num, uint8_t setting_num)
{
80003918:	eb cd 40 e0 	pushm	r5-r7,lr
8000391c:	18 95       	mov	r5,r12
	// Select the interface descriptor
	if (!udc_update_iface_desc(iface_num, setting_num))
8000391e:	f0 1f 00 12 	mcall	80003964 <udc_iface_enable+0x4c>
80003922:	c1 f0       	breq	80003960 <udc_iface_enable+0x48>

#if (0!=USB_DEVICE_MAX_EP)
	usb_ep_desc_t UDC_DESC_STORAGE *ep_desc;

	// Start at the beginning of the global interface descriptor
	ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *) udc_ptr_iface;
80003924:	49 18       	lddpc	r8,80003968 <udc_iface_enable+0x50>
80003926:	70 07       	ld.w	r7,r8[0x0]
	while (1) {
		// Search Endpoint descriptor included in the global interface descriptor
		ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *)
80003928:	30 56       	mov	r6,5
8000392a:	0c 9b       	mov	r11,r6
8000392c:	0e 9c       	mov	r12,r7
8000392e:	f0 1f 00 10 	mcall	8000396c <udc_iface_enable+0x54>
80003932:	18 97       	mov	r7,r12
				udc_next_desc_in_iface((UDC_DESC_STORAGE
						usb_conf_desc_t *) ep_desc,
				USB_DT_ENDPOINT);
		if (NULL == ep_desc)
80003934:	c0 d0       	breq	8000394e <udc_iface_enable+0x36>
			break;
		// Alloc the endpoint used by the interface
		if (!udd_ep_alloc(ep_desc->bEndpointAddress,
						ep_desc->bmAttributes,
						le16_to_cpu
80003936:	19 ca       	ld.ub	r10,r12[0x4]
80003938:	19 d8       	ld.ub	r8,r12[0x5]
8000393a:	f1 ea 10 8a 	or	r10,r8,r10<<0x8
8000393e:	5c ca       	swap.bh	r10
						usb_conf_desc_t *) ep_desc,
				USB_DT_ENDPOINT);
		if (NULL == ep_desc)
			break;
		// Alloc the endpoint used by the interface
		if (!udd_ep_alloc(ep_desc->bEndpointAddress,
80003940:	5c 7a       	castu.h	r10
80003942:	19 bb       	ld.ub	r11,r12[0x3]
80003944:	19 ac       	ld.ub	r12,r12[0x2]
80003946:	f0 1f 00 0b 	mcall	80003970 <udc_iface_enable+0x58>
8000394a:	cf 01       	brne	8000392a <udc_iface_enable+0x12>
8000394c:	c0 a8       	rjmp	80003960 <udc_iface_enable+0x48>
						(ep_desc->wMaxPacketSize)))
			return false;
	}
#endif
	// Enable the interface
	return udc_ptr_conf->udi_apis[iface_num]->enable();
8000394e:	48 a8       	lddpc	r8,80003974 <udc_iface_enable+0x5c>
80003950:	70 08       	ld.w	r8,r8[0x0]
80003952:	70 18       	ld.w	r8,r8[0x4]
80003954:	f0 05 03 28 	ld.w	r8,r8[r5<<0x2]
80003958:	70 0c       	ld.w	r12,r8[0x0]
8000395a:	5d 1c       	icall	r12
8000395c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003960:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
80003964:	80 00       	ld.sh	r0,r0[0x0]
80003966:	38 2c       	mov	r12,-126
80003968:	00 00       	add	r0,r0
8000396a:	08 84       	andn	r4,r4
8000396c:	80 00       	ld.sh	r0,r0[0x0]
8000396e:	38 b0       	mov	r0,-117
80003970:	80 00       	ld.sh	r0,r0[0x0]
80003972:	29 18       	sub	r8,-111
80003974:	00 00       	add	r0,r0
80003976:	08 78       	tst	r8,r4

80003978 <udc_iface_disable>:
 * \param iface_num     Interface number to disable
 *
 * \return 1 if it is done or 0 if interface is not found
 */
static bool udc_iface_disable(uint8_t iface_num)
{
80003978:	eb cd 40 e0 	pushm	r5-r7,lr
8000397c:	18 96       	mov	r6,r12
	udi_api_t UDC_DESC_STORAGE *udi_api;

	// Select first alternate setting of the interface to update udc_ptr_iface
	// before call iface->getsetting()
	if (!udc_update_iface_desc(iface_num, 0))
8000397e:	18 97       	mov	r7,r12
80003980:	30 0b       	mov	r11,0
80003982:	f0 1f 00 12 	mcall	800039c8 <udc_iface_disable+0x50>
80003986:	c1 e0       	breq	800039c2 <udc_iface_disable+0x4a>
		return false;

	// Select the interface with the current alternate setting
	udi_api = udc_ptr_conf->udi_apis[iface_num];
80003988:	49 18       	lddpc	r8,800039cc <udc_iface_disable+0x54>
8000398a:	70 08       	ld.w	r8,r8[0x0]
8000398c:	70 18       	ld.w	r8,r8[0x4]
8000398e:	f0 06 03 25 	ld.w	r5,r8[r6<<0x2]

#if (0!=USB_DEVICE_MAX_EP)
	if (!udc_update_iface_desc(iface_num, udi_api->getsetting()))
80003992:	6a 3c       	ld.w	r12,r5[0xc]
80003994:	5d 1c       	icall	r12
80003996:	18 9b       	mov	r11,r12
80003998:	0c 9c       	mov	r12,r6
8000399a:	f0 1f 00 0c 	mcall	800039c8 <udc_iface_disable+0x50>
8000399e:	c1 20       	breq	800039c2 <udc_iface_disable+0x4a>
		return false;

	// Start at the beginning of interface descriptor
	{
		usb_ep_desc_t UDC_DESC_STORAGE *ep_desc;
		ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *) udc_ptr_iface;
800039a0:	48 c8       	lddpc	r8,800039d0 <udc_iface_disable+0x58>
800039a2:	70 07       	ld.w	r7,r8[0x0]
		while (1) {
			// Search Endpoint descriptor included in global interface descriptor
			ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *)
800039a4:	30 56       	mov	r6,5
800039a6:	0c 9b       	mov	r11,r6
800039a8:	0e 9c       	mov	r12,r7
800039aa:	f0 1f 00 0b 	mcall	800039d4 <udc_iface_disable+0x5c>
800039ae:	18 97       	mov	r7,r12
					udc_next_desc_in_iface((UDC_DESC_STORAGE
							usb_conf_desc_t *)
					ep_desc, USB_DT_ENDPOINT);
			if (NULL == ep_desc)
800039b0:	c0 50       	breq	800039ba <udc_iface_disable+0x42>
				break;
			// Free the endpoint used by the interface
			udd_ep_free(ep_desc->bEndpointAddress);
800039b2:	19 ac       	ld.ub	r12,r12[0x2]
800039b4:	f0 1f 00 09 	mcall	800039d8 <udc_iface_disable+0x60>
		}
800039b8:	cf 7b       	rjmp	800039a6 <udc_iface_disable+0x2e>
	}
#endif

	// Disable interface
	udi_api->disable();
800039ba:	6a 18       	ld.w	r8,r5[0x4]
800039bc:	5d 18       	icall	r8
800039be:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
	return true;
800039c2:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
800039c6:	00 00       	add	r0,r0
800039c8:	80 00       	ld.sh	r0,r0[0x0]
800039ca:	38 2c       	mov	r12,-126
800039cc:	00 00       	add	r0,r0
800039ce:	08 78       	tst	r8,r4
800039d0:	00 00       	add	r0,r0
800039d2:	08 84       	andn	r4,r4
800039d4:	80 00       	ld.sh	r0,r0[0x0]
800039d6:	38 b0       	mov	r0,-117
800039d8:	80 00       	ld.sh	r0,r0[0x0]
800039da:	25 90       	sub	r0,89

800039dc <udc_reset>:
/**
 * \brief Reset the current configuration of the USB device, 
 * This routines can be called by UDD when a RESET on the USB line occurs.
 */
void udc_reset(void)
{
800039dc:	eb cd 40 c0 	pushm	r6-r7,lr
	uint8_t iface_num;

	if (udc_num_configuration) {
800039e0:	49 38       	lddpc	r8,80003a2c <udc_reset+0x50>
800039e2:	11 89       	ld.ub	r9,r8[0x0]
800039e4:	30 08       	mov	r8,0
800039e6:	f0 09 18 00 	cp.b	r9,r8
800039ea:	c1 70       	breq	80003a18 <udc_reset+0x3c>
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
800039ec:	49 18       	lddpc	r8,80003a30 <udc_reset+0x54>
800039ee:	70 08       	ld.w	r8,r8[0x0]
800039f0:	70 08       	ld.w	r8,r8[0x0]
800039f2:	11 c9       	ld.ub	r9,r8[0x4]
800039f4:	30 08       	mov	r8,0
800039f6:	f0 09 18 00 	cp.b	r9,r8
800039fa:	c0 f0       	breq	80003a18 <udc_reset+0x3c>
800039fc:	30 07       	mov	r7,0
800039fe:	48 d6       	lddpc	r6,80003a30 <udc_reset+0x54>
				iface_num++) {
			udc_iface_disable(iface_num);
80003a00:	0e 9c       	mov	r12,r7
80003a02:	f0 1f 00 0d 	mcall	80003a34 <udc_reset+0x58>
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
				iface_num++) {
80003a06:	2f f7       	sub	r7,-1
80003a08:	5c 57       	castu.b	r7
{
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
80003a0a:	6c 08       	ld.w	r8,r6[0x0]
80003a0c:	70 08       	ld.w	r8,r8[0x0]
80003a0e:	11 c8       	ld.ub	r8,r8[0x4]
80003a10:	ee 08 18 00 	cp.b	r8,r7
80003a14:	fe 9b ff f6 	brhi	80003a00 <udc_reset+0x24>
				iface_num++) {
			udc_iface_disable(iface_num);
		}
	}
	udc_num_configuration = 0;
80003a18:	30 09       	mov	r9,0
80003a1a:	48 58       	lddpc	r8,80003a2c <udc_reset+0x50>
80003a1c:	b0 89       	st.b	r8[0x0],r9
	if (0 != (CPU_TO_LE16(USB_DEV_STATUS_REMOTEWAKEUP) & udc_device_status)) {
		// Remote wakeup is enabled then disable it
		UDC_REMOTEWAKEUP_DISABLE();
	}
#endif
	udc_device_status =
80003a1e:	e0 69 01 00 	mov	r9,256
80003a22:	48 68       	lddpc	r8,80003a38 <udc_reset+0x5c>
80003a24:	b0 09       	st.h	r8[0x0],r9
#if (USB_DEVICE_ATTR & USB_CONFIG_ATTR_SELF_POWERED)
			CPU_TO_LE16(USB_DEV_STATUS_SELF_POWERED);
#else
			CPU_TO_LE16(USB_DEV_STATUS_BUS_POWERED);
#endif
}
80003a26:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003a2a:	00 00       	add	r0,r0
80003a2c:	00 00       	add	r0,r0
80003a2e:	08 7e       	tst	lr,r4
80003a30:	00 00       	add	r0,r0
80003a32:	08 78       	tst	r8,r4
80003a34:	80 00       	ld.sh	r0,r0[0x0]
80003a36:	39 78       	mov	r8,-105
80003a38:	00 00       	add	r0,r0
80003a3a:	08 7c       	tst	r12,r4

80003a3c <udc_process_setup>:
 * sent to a specific application callback.
 *
 * \return true if the request is supported, else the request is stalled by UDD
 */
bool udc_process_setup(void)
{
80003a3c:	eb cd 40 e0 	pushm	r5-r7,lr
	// By default no data (receive/send) and no callbacks registered
	udd_g_ctrlreq.payload_size = 0;
80003a40:	fe f8 04 3c 	ld.w	r8,pc[1084]
80003a44:	30 09       	mov	r9,0
80003a46:	b0 69       	st.h	r8[0xc],r9
	udd_g_ctrlreq.callback = NULL;
80003a48:	30 0a       	mov	r10,0
80003a4a:	91 4a       	st.w	r8[0x10],r10
	udd_g_ctrlreq.over_under_run = NULL;
80003a4c:	91 5a       	st.w	r8[0x14],r10

	if (Udd_setup_is_in()) {
80003a4e:	11 88       	ld.ub	r8,r8[0x0]
80003a50:	10 9a       	mov	r10,r8
80003a52:	f2 08 18 00 	cp.b	r8,r9
80003a56:	c0 94       	brge	80003a68 <udc_process_setup+0x2c>
		if (udd_g_ctrlreq.req.wLength == 0)
80003a58:	fe f9 04 24 	ld.w	r9,pc[1060]
80003a5c:	92 3b       	ld.sh	r11,r9[0x6]
80003a5e:	30 09       	mov	r9,0
80003a60:	f2 0b 19 00 	cp.h	r11,r9
80003a64:	e0 80 02 0a 	breq	80003e78 <udc_process_setup+0x43c>
			return false;	// Error from USB host
	}
	
	// If standard request then try to decode it in UDC
	if (Udd_setup_type() == USB_REQ_TYPE_STANDARD) {
80003a68:	10 99       	mov	r9,r8
80003a6a:	e2 19 00 60 	andl	r9,0x60,COH
80003a6e:	e0 81 01 d9 	brne	80003e20 <udc_process_setup+0x3e4>
 *
 * \return true if the request is supported
 */
static bool udc_reqstd(void)
{
	if (Udd_setup_is_in()) {
80003a72:	f2 0a 18 00 	cp.b	r10,r9
80003a76:	e0 84 01 01 	brge	80003c78 <udc_process_setup+0x23c>
		// GET Standard Requests 
		if (udd_g_ctrlreq.req.wLength == 0)
80003a7a:	fe f9 04 02 	ld.w	r9,pc[1026]
80003a7e:	92 39       	ld.sh	r9,r9[0x6]
80003a80:	58 09       	cp.w	r9,0
80003a82:	e0 80 01 cf 	breq	80003e20 <udc_process_setup+0x3e4>
			return false;	// Error for USB host

		if (USB_REQ_RECIP_DEVICE == Udd_setup_recipient()) {
80003a86:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003a8a:	e0 81 00 9e 	brne	80003bc6 <udc_process_setup+0x18a>
			// Standard Get Device request
			switch (udd_g_ctrlreq.req.bRequest) {
80003a8e:	fe fa 03 ee 	ld.w	r10,pc[1006]
80003a92:	15 9a       	ld.ub	r10,r10[0x1]
80003a94:	30 6b       	mov	r11,6
80003a96:	f6 0a 18 00 	cp.b	r10,r11
80003a9a:	c1 a0       	breq	80003ace <udc_process_setup+0x92>
80003a9c:	30 8b       	mov	r11,8
80003a9e:	f6 0a 18 00 	cp.b	r10,r11
80003aa2:	e0 80 00 85 	breq	80003bac <udc_process_setup+0x170>
80003aa6:	30 0b       	mov	r11,0
80003aa8:	f6 0a 18 00 	cp.b	r10,r11
80003aac:	e0 81 00 8d 	brne	80003bc6 <udc_process_setup+0x18a>
 *
 * \return true if success
 */
static bool udc_req_std_dev_get_status(void)
{
	if (udd_g_ctrlreq.req.wLength != sizeof(udc_device_status))
80003ab0:	30 28       	mov	r8,2
80003ab2:	f0 09 19 00 	cp.h	r9,r8
80003ab6:	c0 40       	breq	80003abe <udc_process_setup+0x82>
80003ab8:	30 0c       	mov	r12,0
80003aba:	e0 8f 01 af 	bral	80003e18 <udc_process_setup+0x3dc>
		return false;

	udd_set_setup_payload(
80003abe:	30 2b       	mov	r11,2
80003ac0:	fe fc 03 c0 	ld.w	r12,pc[960]
80003ac4:	f0 1f 00 f0 	mcall	80003e84 <udc_process_setup+0x448>
80003ac8:	30 1c       	mov	r12,1
80003aca:	e0 8f 01 a7 	bral	80003e18 <udc_process_setup+0x3dc>
 */
static bool udc_req_std_dev_get_descriptor(void)
{
	uint8_t conf_num;

	conf_num = udd_g_ctrlreq.req.wValue & 0xff;
80003ace:	fe f8 03 ae 	ld.w	r8,pc[942]
80003ad2:	90 19       	ld.sh	r9,r8[0x2]

	// Check descriptor ID
	switch ((uint8_t) (udd_g_ctrlreq.req.wValue >> 8)) {
80003ad4:	f2 08 16 08 	lsr	r8,r9,0x8
80003ad8:	30 2a       	mov	r10,2
80003ada:	f4 08 18 00 	cp.b	r8,r10
80003ade:	c1 00       	breq	80003afe <udc_process_setup+0xc2>
80003ae0:	30 3a       	mov	r10,3
80003ae2:	f4 08 18 00 	cp.b	r8,r10
80003ae6:	c2 a0       	breq	80003b3a <udc_process_setup+0xfe>
80003ae8:	30 19       	mov	r9,1
80003aea:	f2 08 18 00 	cp.b	r8,r9
80003aee:	c5 d1       	brne	80003ba8 <udc_process_setup+0x16c>
		} else
#endif
		{
			udd_set_setup_payload(
				(uint8_t *) udc_config.confdev_lsfs,
				udc_config.confdev_lsfs->bLength);
80003af0:	fe f8 03 98 	ld.w	r8,pc[920]
80003af4:	70 0c       	ld.w	r12,r8[0x0]
				(uint8_t *) udc_config.confdev_hs,
				udc_config.confdev_hs->bLength);
		} else
#endif
		{
			udd_set_setup_payload(
80003af6:	19 8b       	ld.ub	r11,r12[0x0]
80003af8:	f0 1f 00 e3 	mcall	80003e84 <udc_process_setup+0x448>
80003afc:	c4 78       	rjmp	80003b8a <udc_process_setup+0x14e>
 */
static bool udc_req_std_dev_get_descriptor(void)
{
	uint8_t conf_num;

	conf_num = udd_g_ctrlreq.req.wValue & 0xff;
80003afe:	5c 59       	castu.b	r9
				le16_to_cpu(udc_config.conf_hs[conf_num].desc->wTotalLength));
		} else
#endif
		{
			// FS descriptor
			if (conf_num >= udc_config.confdev_lsfs->
80003b00:	fe f8 03 88 	ld.w	r8,pc[904]
80003b04:	70 08       	ld.w	r8,r8[0x0]
80003b06:	f1 38 00 11 	ld.ub	r8,r8[17]
80003b0a:	f2 08 18 00 	cp.b	r8,r9
80003b0e:	e0 88 00 4d 	brls	80003ba8 <udc_process_setup+0x16c>
					bNumConfigurations)
				return false;
			udd_set_setup_payload(
				(uint8_t *)udc_config.conf_lsfs[conf_num].desc,
				le16_to_cpu(udc_config.conf_lsfs[conf_num].desc->wTotalLength));
80003b12:	fe f8 03 76 	ld.w	r8,pc[886]
80003b16:	70 18       	ld.w	r8,r8[0x4]
80003b18:	f0 09 03 3c 	ld.w	r12,r8[r9<<0x3]
80003b1c:	19 a9       	ld.ub	r9,r12[0x2]
80003b1e:	19 b8       	ld.ub	r8,r12[0x3]
80003b20:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80003b24:	5c c8       	swap.bh	r8
		{
			// FS descriptor
			if (conf_num >= udc_config.confdev_lsfs->
					bNumConfigurations)
				return false;
			udd_set_setup_payload(
80003b26:	f7 d8 c0 10 	bfextu	r11,r8,0x0,0x10
80003b2a:	f0 1f 00 d7 	mcall	80003e84 <udc_process_setup+0x448>
				(uint8_t *)udc_config.conf_lsfs[conf_num].desc,
				le16_to_cpu(udc_config.conf_lsfs[conf_num].desc->wTotalLength));
		}
		((usb_conf_desc_t *) udd_g_ctrlreq.payload)->bDescriptorType =
80003b2e:	fe f8 03 4e 	ld.w	r8,pc[846]
80003b32:	70 28       	ld.w	r8,r8[0x8]
80003b34:	30 29       	mov	r9,2
80003b36:	b0 99       	st.b	r8[0x1],r9
80003b38:	c2 98       	rjmp	80003b8a <udc_process_setup+0x14e>
	uint8_t i;
	uint8_t *str;
	uint8_t str_lgt=0;

	// Link payload pointer to the string corresponding at request
	switch (udd_g_ctrlreq.req.wValue & 0xff) {
80003b3a:	5c 59       	castu.b	r9
80003b3c:	58 19       	cp.w	r9,1
80003b3e:	c1 00       	breq	80003b5e <udc_process_setup+0x122>
80003b40:	58 29       	cp.w	r9,2
80003b42:	c0 40       	breq	80003b4a <udc_process_setup+0x10e>
80003b44:	58 09       	cp.w	r9,0
80003b46:	c0 60       	breq	80003b52 <udc_process_setup+0x116>
80003b48:	c3 08       	rjmp	80003ba8 <udc_process_setup+0x16c>
80003b4a:	fe fc 03 42 	ld.w	r12,pc[834]
80003b4e:	30 3b       	mov	r11,3
80003b50:	c0 a8       	rjmp	80003b64 <udc_process_setup+0x128>
	case 0:
		udd_set_setup_payload(
80003b52:	30 4b       	mov	r11,4
80003b54:	fe fc 03 3c 	ld.w	r12,pc[828]
80003b58:	f0 1f 00 cb 	mcall	80003e84 <udc_process_setup+0x448>
80003b5c:	c1 78       	rjmp	80003b8a <udc_process_setup+0x14e>
80003b5e:	fe fc 03 36 	ld.w	r12,pc[822]
80003b62:	30 9b       	mov	r11,9
80003b64:	fe fa 03 34 	ld.w	r10,pc[820]
80003b68:	2f ea       	sub	r10,-2
80003b6a:	18 98       	mov	r8,r12
		return false;
	}

	if (str_lgt != 0) {
		for(i = 0; i < str_lgt; i++) {
			udc_string_desc.string[i] = cpu_to_le16((le16_t)str[i]);
80003b6c:	11 39       	ld.ub	r9,r8++
80003b6e:	5c c9       	swap.bh	r9
80003b70:	14 b9       	st.h	r10++,r9
#endif
		return false;
	}

	if (str_lgt != 0) {
		for(i = 0; i < str_lgt; i++) {
80003b72:	f0 0c 01 09 	sub	r9,r8,r12
80003b76:	f6 09 18 00 	cp.b	r9,r11
80003b7a:	cf 93       	brcs	80003b6c <udc_process_setup+0x130>
			udc_string_desc.string[i] = cpu_to_le16((le16_t)str[i]);
		}
		
		udc_string_desc.header.bLength = 2 + (str_lgt) * 2;
80003b7c:	a1 7b       	lsl	r11,0x1
80003b7e:	2f eb       	sub	r11,-2
80003b80:	fe fc 03 18 	ld.w	r12,pc[792]
80003b84:	b8 8b       	st.b	r12[0x0],r11
		udd_set_setup_payload(
80003b86:	f0 1f 00 c0 	mcall	80003e84 <udc_process_setup+0x448>
	default:
		// Unknown descriptor requested
		return false;
	}
	// if the descriptor is larger than length requested, then reduce it
	if (udd_g_ctrlreq.req.wLength < udd_g_ctrlreq.payload_size)
80003b8a:	fe f8 02 f2 	ld.w	r8,pc[754]
80003b8e:	90 39       	ld.sh	r9,r8[0x6]
80003b90:	90 68       	ld.sh	r8,r8[0xc]
80003b92:	f2 08 19 00 	cp.h	r8,r9
80003b96:	e0 8b 00 04 	brhi	80003b9e <udc_process_setup+0x162>
80003b9a:	30 1c       	mov	r12,1
80003b9c:	c3 e9       	rjmp	80003e18 <udc_process_setup+0x3dc>
		udd_g_ctrlreq.payload_size = udd_g_ctrlreq.req.wLength;
80003b9e:	fe f8 02 de 	ld.w	r8,pc[734]
80003ba2:	b0 69       	st.h	r8[0xc],r9
80003ba4:	30 1c       	mov	r12,1
80003ba6:	c3 99       	rjmp	80003e18 <udc_process_setup+0x3dc>
80003ba8:	30 0c       	mov	r12,0
80003baa:	c3 79       	rjmp	80003e18 <udc_process_setup+0x3dc>
 *
 * \return true if success 
 */
static bool udc_req_std_dev_get_configuration(void)
{
	if (udd_g_ctrlreq.req.wLength != 1)
80003bac:	30 18       	mov	r8,1
80003bae:	f0 09 19 00 	cp.h	r9,r8
80003bb2:	c0 30       	breq	80003bb8 <udc_process_setup+0x17c>
80003bb4:	30 0c       	mov	r12,0
80003bb6:	c3 19       	rjmp	80003e18 <udc_process_setup+0x3dc>
		return false;

	udd_set_setup_payload(&udc_num_configuration,1);
80003bb8:	30 1b       	mov	r11,1
80003bba:	fe fc 02 e2 	ld.w	r12,pc[738]
80003bbe:	f0 1f 00 b2 	mcall	80003e84 <udc_process_setup+0x448>
80003bc2:	30 1c       	mov	r12,1
80003bc4:	c2 a9       	rjmp	80003e18 <udc_process_setup+0x3dc>
			case USB_REQ_GET_CONFIGURATION:
				return udc_req_std_dev_get_configuration();
			}
		}

		if (USB_REQ_RECIP_INTERFACE == Udd_setup_recipient()) {
80003bc6:	58 18       	cp.w	r8,1
80003bc8:	c3 61       	brne	80003c34 <udc_process_setup+0x1f8>
			// Standard Get Interface request
			switch (udd_g_ctrlreq.req.bRequest) {
80003bca:	fe fa 02 b2 	ld.w	r10,pc[690]
80003bce:	15 9b       	ld.ub	r11,r10[0x1]
80003bd0:	30 aa       	mov	r10,10
80003bd2:	f4 0b 18 00 	cp.b	r11,r10
80003bd6:	c2 f1       	brne	80003c34 <udc_process_setup+0x1f8>
{
	static uint8_t udc_iface_setting;
	uint8_t iface_num;
	udi_api_t UDC_DESC_STORAGE *udi_api;

	if (udd_g_ctrlreq.req.wLength != 1)
80003bd8:	f0 09 19 00 	cp.h	r9,r8
80003bdc:	c2 a1       	brne	80003c30 <udc_process_setup+0x1f4>
		return false;	// Error in request
	if (!udc_num_configuration)
80003bde:	fe f8 02 be 	ld.w	r8,pc[702]
80003be2:	11 89       	ld.ub	r9,r8[0x0]
80003be4:	30 08       	mov	r8,0
80003be6:	f0 09 18 00 	cp.b	r9,r8
80003bea:	c2 30       	breq	80003c30 <udc_process_setup+0x1f4>
		return false;	// The device is not is configured state yet

	// Check the interface number included in the request
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
80003bec:	fe f8 02 90 	ld.w	r8,pc[656]
80003bf0:	11 d7       	ld.ub	r7,r8[0x5]
	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces)
80003bf2:	fe f8 02 ae 	ld.w	r8,pc[686]
80003bf6:	70 08       	ld.w	r8,r8[0x0]
80003bf8:	70 08       	ld.w	r8,r8[0x0]
80003bfa:	11 c8       	ld.ub	r8,r8[0x4]
80003bfc:	ee 08 18 00 	cp.b	r8,r7
80003c00:	e0 88 00 18 	brls	80003c30 <udc_process_setup+0x1f4>
		return false;

	// Select first alternate setting of the interface to update udc_ptr_iface
	// before call iface->getsetting()
	if (!udc_update_iface_desc(iface_num, 0))
80003c04:	30 0b       	mov	r11,0
80003c06:	0e 9c       	mov	r12,r7
80003c08:	f0 1f 00 a7 	mcall	80003ea4 <udc_process_setup+0x468>
80003c0c:	c1 20       	breq	80003c30 <udc_process_setup+0x1f4>
		return false;
	// Get alternate setting from UDI
	udi_api = udc_ptr_conf->udi_apis[iface_num];
	udc_iface_setting = udi_api->getsetting();
80003c0e:	fe f8 02 92 	ld.w	r8,pc[658]
80003c12:	70 08       	ld.w	r8,r8[0x0]
80003c14:	70 18       	ld.w	r8,r8[0x4]
80003c16:	f0 07 03 28 	ld.w	r8,r8[r7<<0x2]
80003c1a:	70 3c       	ld.w	r12,r8[0xc]
80003c1c:	5d 1c       	icall	r12
80003c1e:	fe f8 02 8a 	ld.w	r8,pc[650]
80003c22:	b0 8c       	st.b	r8[0x0],r12
	// Link value to payload pointer of request
	udd_set_setup_payload(&udc_iface_setting,1);
80003c24:	30 1b       	mov	r11,1
80003c26:	10 9c       	mov	r12,r8
80003c28:	f0 1f 00 97 	mcall	80003e84 <udc_process_setup+0x448>
80003c2c:	30 1c       	mov	r12,1
80003c2e:	cf 58       	rjmp	80003e18 <udc_process_setup+0x3dc>
80003c30:	30 0c       	mov	r12,0
80003c32:	cf 38       	rjmp	80003e18 <udc_process_setup+0x3dc>
			case USB_REQ_GET_INTERFACE:
				return udc_req_std_iface_get_setting();
			}
		}
#if (0!=USB_DEVICE_MAX_EP)
		if (USB_REQ_RECIP_ENDPOINT == Udd_setup_recipient()) {
80003c34:	58 28       	cp.w	r8,2
80003c36:	e0 81 00 f5 	brne	80003e20 <udc_process_setup+0x3e4>
			// Standard Get Endpoint request
			switch (udd_g_ctrlreq.req.bRequest) {
80003c3a:	fe f8 02 42 	ld.w	r8,pc[578]
80003c3e:	11 9a       	ld.ub	r10,r8[0x1]
80003c40:	30 08       	mov	r8,0
80003c42:	f0 0a 18 00 	cp.b	r10,r8
80003c46:	e0 81 00 e8 	brne	80003e16 <udc_process_setup+0x3da>
 */
static bool udc_req_std_ep_get_status(void)
{
	static le16_t udc_ep_status;

	if (udd_g_ctrlreq.req.wLength != sizeof(udc_ep_status))
80003c4a:	30 28       	mov	r8,2
80003c4c:	f0 09 19 00 	cp.h	r9,r8
80003c50:	c0 30       	breq	80003c56 <udc_process_setup+0x21a>
80003c52:	30 0c       	mov	r12,0
80003c54:	ce 28       	rjmp	80003e18 <udc_process_setup+0x3dc>
		return false;

	udc_ep_status = udd_ep_is_halted(udd_g_ctrlreq.req.
80003c56:	fe f8 02 26 	ld.w	r8,pc[550]
80003c5a:	11 dc       	ld.ub	r12,r8[0x5]
80003c5c:	f0 1f 00 94 	mcall	80003eac <udc_process_setup+0x470>
80003c60:	e0 68 01 00 	mov	r8,256
80003c64:	f9 b8 00 00 	moveq	r8,0
80003c68:	fe fc 02 48 	ld.w	r12,pc[584]
80003c6c:	b8 08       	st.h	r12[0x0],r8
			wIndex & 0xFF) ? CPU_TO_LE16(USB_EP_STATUS_HALTED) : 0;

	udd_set_setup_payload(
80003c6e:	30 2b       	mov	r11,2
80003c70:	f0 1f 00 85 	mcall	80003e84 <udc_process_setup+0x448>
80003c74:	30 1c       	mov	r12,1
80003c76:	cd 18       	rjmp	80003e18 <udc_process_setup+0x3dc>
			}
		}
#endif
	} else {
		// SET Standard Requests  
		if (USB_REQ_RECIP_DEVICE == Udd_setup_recipient()) {
80003c78:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003c7c:	c7 71       	brne	80003d6a <udc_process_setup+0x32e>
			// Standard Set Device request
			switch (udd_g_ctrlreq.req.bRequest) {
80003c7e:	fe f9 01 fe 	ld.w	r9,pc[510]
80003c82:	13 99       	ld.ub	r9,r9[0x1]
80003c84:	30 3a       	mov	r10,3
80003c86:	f4 09 18 00 	cp.b	r9,r10
80003c8a:	e0 80 00 c6 	breq	80003e16 <udc_process_setup+0x3da>
80003c8e:	e0 8b 00 07 	brhi	80003c9c <udc_process_setup+0x260>
80003c92:	30 1a       	mov	r10,1
80003c94:	f4 09 18 00 	cp.b	r9,r10
80003c98:	c6 91       	brne	80003d6a <udc_process_setup+0x32e>
80003c9a:	c1 78       	rjmp	80003cc8 <udc_process_setup+0x28c>
80003c9c:	30 5a       	mov	r10,5
80003c9e:	f4 09 18 00 	cp.b	r9,r10
80003ca2:	c0 60       	breq	80003cae <udc_process_setup+0x272>
80003ca4:	30 9a       	mov	r10,9
80003ca6:	f4 09 18 00 	cp.b	r9,r10
80003caa:	c6 01       	brne	80003d6a <udc_process_setup+0x32e>
80003cac:	c2 28       	rjmp	80003cf0 <udc_process_setup+0x2b4>
 *
 * \return true if success 
 */
static bool udc_req_std_dev_set_address(void)
{
	if (udd_g_ctrlreq.req.wLength != 0)
80003cae:	4f 48       	lddpc	r8,80003e7c <udc_process_setup+0x440>
80003cb0:	90 39       	ld.sh	r9,r8[0x6]
80003cb2:	30 08       	mov	r8,0
80003cb4:	f0 09 19 00 	cp.h	r9,r8
80003cb8:	c0 30       	breq	80003cbe <udc_process_setup+0x282>
80003cba:	30 0c       	mov	r12,0
80003cbc:	ca e8       	rjmp	80003e18 <udc_process_setup+0x3dc>
		return false;

	// The address must be changed at the end of setup request after the handshake
	// then we use a callback to change address
	udd_g_ctrlreq.callback = udc_valid_address;
80003cbe:	4f e9       	lddpc	r9,80003eb4 <udc_process_setup+0x478>
80003cc0:	4e f8       	lddpc	r8,80003e7c <udc_process_setup+0x440>
80003cc2:	91 49       	st.w	r8[0x10],r9
80003cc4:	30 1c       	mov	r12,1
80003cc6:	ca 98       	rjmp	80003e18 <udc_process_setup+0x3dc>
 *
 * \return true if success 
 */
static bool udc_req_std_dev_clear_feature(void)
{
	if (udd_g_ctrlreq.req.wLength != 0)
80003cc8:	4e d8       	lddpc	r8,80003e7c <udc_process_setup+0x440>
80003cca:	90 39       	ld.sh	r9,r8[0x6]
80003ccc:	30 08       	mov	r8,0
80003cce:	f0 09 19 00 	cp.h	r9,r8
80003cd2:	c0 d1       	brne	80003cec <udc_process_setup+0x2b0>
		return false;

	if (udd_g_ctrlreq.req.wValue == USB_DEV_FEATURE_REMOTE_WAKEUP) {
80003cd4:	4e a8       	lddpc	r8,80003e7c <udc_process_setup+0x440>
80003cd6:	90 19       	ld.sh	r9,r8[0x2]
80003cd8:	30 18       	mov	r8,1
80003cda:	f0 09 19 00 	cp.h	r9,r8
80003cde:	c0 71       	brne	80003cec <udc_process_setup+0x2b0>
		udc_device_status &= CPU_TO_LE16(~USB_DEV_STATUS_REMOTEWAKEUP);
80003ce0:	4e 88       	lddpc	r8,80003e80 <udc_process_setup+0x444>
80003ce2:	90 09       	ld.sh	r9,r8[0x0]
80003ce4:	a9 d9       	cbr	r9,0x9
80003ce6:	b0 09       	st.h	r8[0x0],r9
80003ce8:	30 1c       	mov	r12,1
80003cea:	c9 78       	rjmp	80003e18 <udc_process_setup+0x3dc>
80003cec:	30 0c       	mov	r12,0
80003cee:	c9 58       	rjmp	80003e18 <udc_process_setup+0x3dc>
static bool udc_req_std_dev_set_configuration(void)
{
	uint8_t iface_num;

	// Check request length
	if (udd_g_ctrlreq.req.wLength != 0)
80003cf0:	4e 38       	lddpc	r8,80003e7c <udc_process_setup+0x440>
80003cf2:	90 39       	ld.sh	r9,r8[0x6]
80003cf4:	30 08       	mov	r8,0
80003cf6:	f0 09 19 00 	cp.h	r9,r8
80003cfa:	c3 41       	brne	80003d62 <udc_process_setup+0x326>
		return false;
	// Authorize configuration only if the address is valid
	if (!udd_getaddress())
80003cfc:	f0 1f 00 6f 	mcall	80003eb8 <udc_process_setup+0x47c>
80003d00:	c3 10       	breq	80003d62 <udc_process_setup+0x326>
			return false;
	} else
#endif
	{
		// FS descriptor
		if ((udd_g_ctrlreq.req.wValue & 0xFF) >
80003d02:	4d f8       	lddpc	r8,80003e7c <udc_process_setup+0x440>
80003d04:	11 b9       	ld.ub	r9,r8[0x3]
80003d06:	4e 18       	lddpc	r8,80003e88 <udc_process_setup+0x44c>
80003d08:	70 08       	ld.w	r8,r8[0x0]
80003d0a:	f1 38 00 11 	ld.ub	r8,r8[17]
80003d0e:	10 39       	cp.w	r9,r8
80003d10:	e0 89 00 29 	brgt	80003d62 <udc_process_setup+0x326>
				udc_config.confdev_lsfs->bNumConfigurations)
			return false;
	}

	// Reset current configuration
	udc_reset();
80003d14:	f0 1f 00 6a 	mcall	80003ebc <udc_process_setup+0x480>

	// Enable new configuration
	udc_num_configuration = udd_g_ctrlreq.req.wValue & 0xFF;
80003d18:	4d 98       	lddpc	r8,80003e7c <udc_process_setup+0x440>
80003d1a:	11 b8       	ld.ub	r8,r8[0x3]
80003d1c:	4e 09       	lddpc	r9,80003e9c <udc_process_setup+0x460>
80003d1e:	b2 88       	st.b	r9[0x0],r8
	if (udc_num_configuration == 0) {
80003d20:	58 08       	cp.w	r8,0
80003d22:	c2 20       	breq	80003d66 <udc_process_setup+0x32a>
		udc_ptr_conf = &udc_config.conf_hs[udc_num_configuration - 1];
	} else
#endif
	{
		// FS descriptor
		udc_ptr_conf = &udc_config.conf_lsfs[udc_num_configuration - 1];
80003d24:	20 18       	sub	r8,1
80003d26:	4d 99       	lddpc	r9,80003e88 <udc_process_setup+0x44c>
80003d28:	72 19       	ld.w	r9,r9[0x4]
80003d2a:	f2 08 00 38 	add	r8,r9,r8<<0x3
80003d2e:	4d d9       	lddpc	r9,80003ea0 <udc_process_setup+0x464>
80003d30:	93 08       	st.w	r9[0x0],r8
	}
	// Enable all interfaces of the selected configuration
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
80003d32:	70 08       	ld.w	r8,r8[0x0]
80003d34:	11 c9       	ld.ub	r9,r8[0x4]
80003d36:	30 08       	mov	r8,0
80003d38:	f0 09 18 00 	cp.b	r9,r8
80003d3c:	c1 50       	breq	80003d66 <udc_process_setup+0x32a>
80003d3e:	30 07       	mov	r7,0
			iface_num++) {
		if (!udc_iface_enable(iface_num, 0))
80003d40:	0e 95       	mov	r5,r7
	{
		// FS descriptor
		udc_ptr_conf = &udc_config.conf_lsfs[udc_num_configuration - 1];
	}
	// Enable all interfaces of the selected configuration
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
80003d42:	4d 86       	lddpc	r6,80003ea0 <udc_process_setup+0x464>
			iface_num++) {
		if (!udc_iface_enable(iface_num, 0))
80003d44:	0a 9b       	mov	r11,r5
80003d46:	0e 9c       	mov	r12,r7
80003d48:	f0 1f 00 5e 	mcall	80003ec0 <udc_process_setup+0x484>
80003d4c:	c0 b0       	breq	80003d62 <udc_process_setup+0x326>
		// FS descriptor
		udc_ptr_conf = &udc_config.conf_lsfs[udc_num_configuration - 1];
	}
	// Enable all interfaces of the selected configuration
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
			iface_num++) {
80003d4e:	2f f7       	sub	r7,-1
80003d50:	5c 57       	castu.b	r7
	{
		// FS descriptor
		udc_ptr_conf = &udc_config.conf_lsfs[udc_num_configuration - 1];
	}
	// Enable all interfaces of the selected configuration
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
80003d52:	6c 08       	ld.w	r8,r6[0x0]
80003d54:	70 08       	ld.w	r8,r8[0x0]
80003d56:	11 c8       	ld.ub	r8,r8[0x4]
80003d58:	ee 08 18 00 	cp.b	r8,r7
80003d5c:	fe 9b ff f4 	brhi	80003d44 <udc_process_setup+0x308>
80003d60:	c0 38       	rjmp	80003d66 <udc_process_setup+0x32a>
80003d62:	30 0c       	mov	r12,0
80003d64:	c5 a8       	rjmp	80003e18 <udc_process_setup+0x3dc>
80003d66:	30 1c       	mov	r12,1
80003d68:	c5 88       	rjmp	80003e18 <udc_process_setup+0x3dc>
				/* Not supported (defined as optional by the USB 2.0 spec) */
				break;
			}
		}

		if (USB_REQ_RECIP_INTERFACE == Udd_setup_recipient()) {
80003d6a:	58 18       	cp.w	r8,1
80003d6c:	c2 21       	brne	80003db0 <udc_process_setup+0x374>
			// Standard Set Interface request
			switch (udd_g_ctrlreq.req.bRequest) {
80003d6e:	4c 49       	lddpc	r9,80003e7c <udc_process_setup+0x440>
80003d70:	13 9a       	ld.ub	r10,r9[0x1]
80003d72:	30 b9       	mov	r9,11
80003d74:	f2 0a 18 00 	cp.b	r10,r9
80003d78:	c1 c1       	brne	80003db0 <udc_process_setup+0x374>
 */
static bool udc_req_std_iface_set_setting(void)
{
	uint8_t iface_num, setting_num;

	if (udd_g_ctrlreq.req.wLength != 0)
80003d7a:	4c 18       	lddpc	r8,80003e7c <udc_process_setup+0x440>
80003d7c:	90 39       	ld.sh	r9,r8[0x6]
80003d7e:	30 08       	mov	r8,0
80003d80:	f0 09 19 00 	cp.h	r9,r8
80003d84:	c1 41       	brne	80003dac <udc_process_setup+0x370>
		return false;	// Error in request
	if (!udc_num_configuration)
80003d86:	4c 68       	lddpc	r8,80003e9c <udc_process_setup+0x460>
80003d88:	11 89       	ld.ub	r9,r8[0x0]
80003d8a:	30 08       	mov	r8,0
80003d8c:	f0 09 18 00 	cp.b	r9,r8
80003d90:	c0 e0       	breq	80003dac <udc_process_setup+0x370>
		return false;	// The device is not is configured state yet


	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
	setting_num = udd_g_ctrlreq.req.wValue & 0xFF;
80003d92:	4b b8       	lddpc	r8,80003e7c <udc_process_setup+0x440>
80003d94:	90 16       	ld.sh	r6,r8[0x2]

	// Disable current setting
	if (!udc_iface_disable(iface_num))
80003d96:	11 d7       	ld.ub	r7,r8[0x5]
80003d98:	0e 9c       	mov	r12,r7
80003d9a:	f0 1f 00 4b 	mcall	80003ec4 <udc_process_setup+0x488>
80003d9e:	c0 70       	breq	80003dac <udc_process_setup+0x370>
		return false;

	// Enable new setting
	return udc_iface_enable(iface_num, setting_num);
80003da0:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
80003da4:	0e 9c       	mov	r12,r7
80003da6:	f0 1f 00 47 	mcall	80003ec0 <udc_process_setup+0x484>
80003daa:	c3 78       	rjmp	80003e18 <udc_process_setup+0x3dc>
80003dac:	30 0c       	mov	r12,0
80003dae:	c3 58       	rjmp	80003e18 <udc_process_setup+0x3dc>
			case USB_REQ_SET_INTERFACE:
				return udc_req_std_iface_set_setting();
			}
		}
#if (0!=USB_DEVICE_MAX_EP)
		if (USB_REQ_RECIP_ENDPOINT == Udd_setup_recipient()) {
80003db0:	58 28       	cp.w	r8,2
80003db2:	c3 71       	brne	80003e20 <udc_process_setup+0x3e4>
			// Standard Set Endpoint request
			switch (udd_g_ctrlreq.req.bRequest) {
80003db4:	4b 28       	lddpc	r8,80003e7c <udc_process_setup+0x440>
80003db6:	11 98       	ld.ub	r8,r8[0x1]
80003db8:	30 19       	mov	r9,1
80003dba:	f2 08 18 00 	cp.b	r8,r9
80003dbe:	c0 60       	breq	80003dca <udc_process_setup+0x38e>
80003dc0:	30 39       	mov	r9,3
80003dc2:	f2 08 18 00 	cp.b	r8,r9
80003dc6:	c2 81       	brne	80003e16 <udc_process_setup+0x3da>
80003dc8:	c1 48       	rjmp	80003df0 <udc_process_setup+0x3b4>
 *
 * \return true if success 
 */
static bool udc_req_std_ep_clear_feature(void)
{
	if (udd_g_ctrlreq.req.wLength != 0)
80003dca:	4a d8       	lddpc	r8,80003e7c <udc_process_setup+0x440>
80003dcc:	90 39       	ld.sh	r9,r8[0x6]
80003dce:	30 08       	mov	r8,0
80003dd0:	f0 09 19 00 	cp.h	r9,r8
80003dd4:	c0 c1       	brne	80003dec <udc_process_setup+0x3b0>
		return false;

	if (udd_g_ctrlreq.req.wValue == USB_EP_FEATURE_HALT) {
80003dd6:	4a a8       	lddpc	r8,80003e7c <udc_process_setup+0x440>
80003dd8:	90 19       	ld.sh	r9,r8[0x2]
80003dda:	30 08       	mov	r8,0
80003ddc:	f0 09 19 00 	cp.h	r9,r8
80003de0:	c0 61       	brne	80003dec <udc_process_setup+0x3b0>
		return udd_ep_clear_halt(udd_g_ctrlreq.req.wIndex & 0xFF);
80003de2:	4a 78       	lddpc	r8,80003e7c <udc_process_setup+0x440>
80003de4:	11 dc       	ld.ub	r12,r8[0x5]
80003de6:	f0 1f 00 39 	mcall	80003ec8 <udc_process_setup+0x48c>
80003dea:	c1 78       	rjmp	80003e18 <udc_process_setup+0x3dc>
80003dec:	30 0c       	mov	r12,0
80003dee:	c1 58       	rjmp	80003e18 <udc_process_setup+0x3dc>
 * \return true if success 
 */
#if (0!=USB_DEVICE_MAX_EP)
static bool udc_req_std_epset_feature(void)
{
	if (udd_g_ctrlreq.req.wLength != 0)
80003df0:	4a 38       	lddpc	r8,80003e7c <udc_process_setup+0x440>
80003df2:	90 39       	ld.sh	r9,r8[0x6]
80003df4:	30 08       	mov	r8,0
80003df6:	f0 09 19 00 	cp.h	r9,r8
80003dfa:	c0 c1       	brne	80003e12 <udc_process_setup+0x3d6>
		return false;
	if (udd_g_ctrlreq.req.wValue == USB_EP_FEATURE_HALT) {
80003dfc:	4a 08       	lddpc	r8,80003e7c <udc_process_setup+0x440>
80003dfe:	90 19       	ld.sh	r9,r8[0x2]
80003e00:	30 08       	mov	r8,0
80003e02:	f0 09 19 00 	cp.h	r9,r8
80003e06:	c0 61       	brne	80003e12 <udc_process_setup+0x3d6>
		return udd_ep_set_halt(udd_g_ctrlreq.req.wIndex & 0xFF);
80003e08:	49 d8       	lddpc	r8,80003e7c <udc_process_setup+0x440>
80003e0a:	11 dc       	ld.ub	r12,r8[0x5]
80003e0c:	f0 1f 00 30 	mcall	80003ecc <udc_process_setup+0x490>
80003e10:	c0 48       	rjmp	80003e18 <udc_process_setup+0x3dc>
80003e12:	30 0c       	mov	r12,0
80003e14:	c0 28       	rjmp	80003e18 <udc_process_setup+0x3dc>
80003e16:	30 0c       	mov	r12,0
			return false;	// Error from USB host
	}
	
	// If standard request then try to decode it in UDC
	if (Udd_setup_type() == USB_REQ_TYPE_STANDARD) {
		if (udc_reqstd())
80003e18:	58 0c       	cp.w	r12,0
80003e1a:	c0 30       	breq	80003e20 <udc_process_setup+0x3e4>
80003e1c:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
			return true;
	}

	// If interface request then try to decode it in UDI
	if (Udd_setup_recipient() == USB_REQ_RECIP_INTERFACE) {
80003e20:	49 78       	lddpc	r8,80003e7c <udc_process_setup+0x440>
80003e22:	11 88       	ld.ub	r8,r8[0x0]
80003e24:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003e28:	58 18       	cp.w	r8,1
80003e2a:	c2 71       	brne	80003e78 <udc_process_setup+0x43c>
static bool udc_req_iface(void)
{
	uint8_t iface_num;
	udi_api_t UDC_DESC_STORAGE *udi_api;

	if (0 == udc_num_configuration)
80003e2c:	49 c8       	lddpc	r8,80003e9c <udc_process_setup+0x460>
80003e2e:	11 89       	ld.ub	r9,r8[0x0]
80003e30:	30 08       	mov	r8,0
80003e32:	f0 09 18 00 	cp.b	r9,r8
80003e36:	c2 10       	breq	80003e78 <udc_process_setup+0x43c>
		return false;	// The device is not is configured state yet
	// Check interface number
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
80003e38:	49 18       	lddpc	r8,80003e7c <udc_process_setup+0x440>
80003e3a:	11 d7       	ld.ub	r7,r8[0x5]
	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces)
80003e3c:	49 98       	lddpc	r8,80003ea0 <udc_process_setup+0x464>
80003e3e:	70 08       	ld.w	r8,r8[0x0]
80003e40:	70 08       	ld.w	r8,r8[0x0]
80003e42:	11 c8       	ld.ub	r8,r8[0x4]
80003e44:	ee 08 18 00 	cp.b	r8,r7
80003e48:	e0 88 00 18 	brls	80003e78 <udc_process_setup+0x43c>
		return false;

	//* To update udc_ptr_iface with the selected interface in request
	// Select first alternate setting of interface to update udc_ptr_iface
	// before calling udi_api->getsetting()
	if (!udc_update_iface_desc(iface_num, 0))
80003e4c:	0e 96       	mov	r6,r7
80003e4e:	30 0b       	mov	r11,0
80003e50:	0e 9c       	mov	r12,r7
80003e52:	f0 1f 00 15 	mcall	80003ea4 <udc_process_setup+0x468>
80003e56:	c1 10       	breq	80003e78 <udc_process_setup+0x43c>
		return false;
	// Select the interface with the current alternate setting
	udi_api = udc_ptr_conf->udi_apis[iface_num];
80003e58:	49 28       	lddpc	r8,80003ea0 <udc_process_setup+0x464>
80003e5a:	70 08       	ld.w	r8,r8[0x0]
80003e5c:	70 18       	ld.w	r8,r8[0x4]
80003e5e:	f0 07 03 27 	ld.w	r7,r8[r7<<0x2]
	if (!udc_update_iface_desc(iface_num, udi_api->getsetting()))
80003e62:	6e 3c       	ld.w	r12,r7[0xc]
80003e64:	5d 1c       	icall	r12
80003e66:	18 9b       	mov	r11,r12
80003e68:	0c 9c       	mov	r12,r6
80003e6a:	f0 1f 00 0f 	mcall	80003ea4 <udc_process_setup+0x468>
80003e6e:	c0 50       	breq	80003e78 <udc_process_setup+0x43c>
		return false;

	// Send the SETUP request to the UDI corresponding to the interface number
	return udi_api->setup();
80003e70:	6e 2c       	ld.w	r12,r7[0x8]
80003e72:	5d 1c       	icall	r12
80003e74:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003e78:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
80003e7c:	00 00       	add	r0,r0
80003e7e:	0a 00       	add	r0,r5
80003e80:	00 00       	add	r0,r0
80003e82:	08 7c       	tst	r12,r4
80003e84:	80 00       	ld.sh	r0,r0[0x0]
80003e86:	24 14       	sub	r4,65
80003e88:	00 00       	add	r0,r0
80003e8a:	00 b0       	st.h	r0++,r0
80003e8c:	00 00       	add	r0,r0
80003e8e:	00 cc       	st.b	r0++,r12
80003e90:	00 00       	add	r0,r0
80003e92:	00 f0       	st.b	--r0,r0
80003e94:	00 00       	add	r0,r0
80003e96:	00 d0       	st.w	--r0,r0
80003e98:	00 00       	add	r0,r0
80003e9a:	00 dc       	st.w	--r0,r12
80003e9c:	00 00       	add	r0,r0
80003e9e:	08 7e       	tst	lr,r4
80003ea0:	00 00       	add	r0,r0
80003ea2:	08 78       	tst	r8,r4
80003ea4:	80 00       	ld.sh	r0,r0[0x0]
80003ea6:	38 2c       	mov	r12,-126
80003ea8:	00 00       	add	r0,r0
80003eaa:	08 74       	tst	r4,r4
80003eac:	80 00       	ld.sh	r0,r0[0x0]
80003eae:	24 20       	sub	r0,66
80003eb0:	00 00       	add	r0,r0
80003eb2:	08 80       	andn	r0,r4
80003eb4:	80 00       	ld.sh	r0,r0[0x0]
80003eb6:	39 00       	mov	r0,-112
80003eb8:	80 00       	ld.sh	r0,r0[0x0]
80003eba:	23 ee       	sub	lr,62
80003ebc:	80 00       	ld.sh	r0,r0[0x0]
80003ebe:	39 dc       	mov	r12,-99
80003ec0:	80 00       	ld.sh	r0,r0[0x0]
80003ec2:	39 18       	mov	r8,-111
80003ec4:	80 00       	ld.sh	r0,r0[0x0]
80003ec6:	39 78       	mov	r8,-105
80003ec8:	80 00       	ld.sh	r0,r0[0x0]
80003eca:	24 b0       	sub	r0,75
80003ecc:	80 00       	ld.sh	r0,r0[0x0]
80003ece:	24 34       	sub	r4,67

80003ed0 <_read>:
#elif (defined(__GNUC__) && !defined(XMEGA))


int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80003ed0:	eb cd 40 fc 	pushm	r2-r7,lr
80003ed4:	20 1d       	sub	sp,4
80003ed6:	16 94       	mov	r4,r11
80003ed8:	14 95       	mov	r5,r10
	int nChars = 0;

	if (file != 0)
80003eda:	58 0c       	cp.w	r12,0
80003edc:	c0 30       	breq	80003ee2 <_read+0x12>
80003ede:	3f f7       	mov	r7,-1
80003ee0:	c1 98       	rjmp	80003f12 <_read+0x42>
		return -1;

	for (; len > 0; --len) {
80003ee2:	58 0a       	cp.w	r10,0
80003ee4:	e0 89 00 04 	brgt	80003eec <_read+0x1c>
80003ee8:	30 07       	mov	r7,0
80003eea:	c1 48       	rjmp	80003f12 <_read+0x42>
80003eec:	30 07       	mov	r7,0
		int c;
		ptr_get(stdio_base,&c);
80003eee:	48 c3       	lddpc	r3,80003f1c <_read+0x4c>
80003ef0:	48 c6       	lddpc	r6,80003f20 <_read+0x50>
80003ef2:	1a 92       	mov	r2,sp
80003ef4:	66 0c       	ld.w	r12,r3[0x0]
80003ef6:	6c 08       	ld.w	r8,r6[0x0]
80003ef8:	1a 9b       	mov	r11,sp
80003efa:	5d 18       	icall	r8
		if (c < 0)
80003efc:	40 08       	lddsp	r8,sp[0x0]
80003efe:	58 08       	cp.w	r8,0
80003f00:	c0 95       	brlt	80003f12 <_read+0x42>
		break;
		*ptr++ = c;
80003f02:	e8 07 0b 08 	st.b	r4[r7],r8
		++nChars;
80003f06:	2f f7       	sub	r7,-1
// GCC AVR32 implementation
#elif (defined(__GNUC__) && !defined(XMEGA))


int __attribute__((weak))
_read (int file, char * ptr, int len)
80003f08:	ea 07 01 08 	sub	r8,r5,r7
	int nChars = 0;

	if (file != 0)
		return -1;

	for (; len > 0; --len) {
80003f0c:	58 08       	cp.w	r8,0
80003f0e:	fe 99 ff f3 	brgt	80003ef4 <_read+0x24>
		break;
		*ptr++ = c;
		++nChars;
	}
	return nChars;
}
80003f12:	0e 9c       	mov	r12,r7
80003f14:	2f fd       	sub	sp,-4
80003f16:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80003f1a:	00 00       	add	r0,r0
80003f1c:	00 00       	add	r0,r0
80003f1e:	0a 28       	rsub	r8,r5
80003f20:	00 00       	add	r0,r0
80003f22:	0a 20       	rsub	r0,r5

80003f24 <stdio_usb_enable>:
	}
}

bool stdio_usb_enable(void)
{
	stdio_usb_interface_enable = true;
80003f24:	30 19       	mov	r9,1
80003f26:	48 28       	lddpc	r8,80003f2c <stdio_usb_enable+0x8>
80003f28:	b0 89       	st.b	r8[0x0],r9
	return true;
}
80003f2a:	5e ff       	retal	1
80003f2c:	00 00       	add	r0,r0
80003f2e:	08 88       	andn	r8,r4

80003f30 <stdio_usb_disable>:

void stdio_usb_disable(void)
{
	stdio_usb_interface_enable = false;
80003f30:	30 09       	mov	r9,0
80003f32:	48 28       	lddpc	r8,80003f38 <stdio_usb_disable+0x8>
80003f34:	b0 89       	st.b	r8[0x0],r9
}
80003f36:	5e fc       	retal	r12
80003f38:	00 00       	add	r0,r0
80003f3a:	08 88       	andn	r8,r4

80003f3c <stdio_usb_vbus_event>:
	
	*data = udi_cdc_getc ();
}

void stdio_usb_vbus_event(bool b_high)
{
80003f3c:	d4 01       	pushm	lr
	if (b_high) {
80003f3e:	58 0c       	cp.w	r12,0
80003f40:	c0 40       	breq	80003f48 <stdio_usb_vbus_event+0xc>
 * then it will attach device when an acceptable Vbus
 * level from the host is detected.
 */
static inline void udc_attach(void)
{
	udd_attach();
80003f42:	f0 1f 00 04 	mcall	80003f50 <stdio_usb_vbus_event+0x14>
80003f46:	d8 02       	popm	pc
 *
 * The driver must remove pull-up on USB line D- or D+.
 */
static inline void udc_detach(void)
{
	udd_detach();
80003f48:	f0 1f 00 03 	mcall	80003f54 <stdio_usb_vbus_event+0x18>
80003f4c:	d8 02       	popm	pc
80003f4e:	00 00       	add	r0,r0
80003f50:	80 00       	ld.sh	r0,r0[0x0]
80003f52:	2a a8       	sub	r8,-86
80003f54:	80 00       	ld.sh	r0,r0[0x0]
80003f56:	27 58       	sub	r8,117

80003f58 <stdio_usb_init>:
{
	stdio_usb_interface_enable = false;
}

void stdio_usb_init (volatile void * usart)
{
80003f58:	d4 01       	pushm	lr
	stdio_base = usart;
80003f5a:	48 98       	lddpc	r8,80003f7c <stdio_usb_init+0x24>
80003f5c:	91 0c       	st.w	r8[0x0],r12
	ptr_put = stdio_usb_putchar;
80003f5e:	48 99       	lddpc	r9,80003f80 <stdio_usb_init+0x28>
80003f60:	48 98       	lddpc	r8,80003f84 <stdio_usb_init+0x2c>
80003f62:	91 09       	st.w	r8[0x0],r9
	ptr_get = stdio_usb_getchar;
80003f64:	48 99       	lddpc	r9,80003f88 <stdio_usb_init+0x30>
80003f66:	48 a8       	lddpc	r8,80003f8c <stdio_usb_init+0x34>
80003f68:	91 09       	st.w	r8[0x0],r9

/*! \brief Start the USB Device stack
 */
static inline void udc_start(void)
{
	udd_enable();
80003f6a:	f0 1f 00 0a 	mcall	80003f90 <stdio_usb_init+0x38>
 *        udc_attach(); \n
 *     }  \n
 */
static inline bool udc_include_vbus_monitoring(void)
{
	return udd_include_vbus_monitoring();
80003f6e:	f0 1f 00 0a 	mcall	80003f94 <stdio_usb_init+0x3c>
	 * integrated USB interfaces.  Assume the VBUS is present if
	 * VBUS monitoring is not available.
	 */
	udc_start ();

	if (! udc_include_vbus_monitoring ()) {
80003f72:	c0 41       	brne	80003f7a <stdio_usb_init+0x22>
		stdio_usb_vbus_event (true);
80003f74:	30 1c       	mov	r12,1
80003f76:	f0 1f 00 09 	mcall	80003f98 <stdio_usb_init+0x40>
80003f7a:	d8 02       	popm	pc
80003f7c:	00 00       	add	r0,r0
80003f7e:	0a 28       	rsub	r8,r5
80003f80:	80 00       	ld.sh	r0,r0[0x0]
80003f82:	3f c8       	mov	r8,-4
80003f84:	00 00       	add	r0,r0
80003f86:	0a 24       	rsub	r4,r5
80003f88:	80 00       	ld.sh	r0,r0[0x0]
80003f8a:	3f 9c       	mov	r12,-7
80003f8c:	00 00       	add	r0,r0
80003f8e:	0a 20       	rsub	r0,r5
80003f90:	80 00       	ld.sh	r0,r0[0x0]
80003f92:	2b 18       	sub	r8,-79
80003f94:	80 00       	ld.sh	r0,r0[0x0]
80003f96:	23 c8       	sub	r8,60
80003f98:	80 00       	ld.sh	r0,r0[0x0]
80003f9a:	3f 3c       	mov	r12,-13

80003f9c <stdio_usb_getchar>:

	return udi_cdc_putc (data) ? 0 : -1;
}

void stdio_usb_getchar (void volatile * usart, int * data)
{
80003f9c:	eb cd 40 80 	pushm	r7,lr
80003fa0:	16 97       	mov	r7,r11
	/* A negative return value should be used to indicate that data
	 * was not read, but this doesn't seem to work with GCC libc.
	 */
	if (!stdio_usb_interface_enable) {
80003fa2:	48 88       	lddpc	r8,80003fc0 <stdio_usb_getchar+0x24>
80003fa4:	11 89       	ld.ub	r9,r8[0x0]
80003fa6:	30 08       	mov	r8,0
80003fa8:	f0 09 18 00 	cp.b	r9,r8
80003fac:	c0 51       	brne	80003fb6 <stdio_usb_getchar+0x1a>
		*data = 0;  // -1
80003fae:	30 08       	mov	r8,0
80003fb0:	97 08       	st.w	r11[0x0],r8
		return;
80003fb2:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	
	*data = udi_cdc_getc ();
80003fb6:	f0 1f 00 04 	mcall	80003fc4 <stdio_usb_getchar+0x28>
80003fba:	8f 0c       	st.w	r7[0x0],r12
80003fbc:	e3 cd 80 80 	ldm	sp++,r7,pc
80003fc0:	00 00       	add	r0,r0
80003fc2:	08 88       	andn	r8,r4
80003fc4:	80 00       	ld.sh	r0,r0[0x0]
80003fc6:	35 20       	mov	r0,82

80003fc8 <stdio_usb_putchar>:
#include "stdio_usb.h"

static bool stdio_usb_interface_enable = false;

int stdio_usb_putchar (volatile void * usart, int data)
{
80003fc8:	d4 01       	pushm	lr
	/* A negative return value should be used to indicate that data
	 * was not written, but this doesn't seem to work with GCC libc.
	 */
	if (!stdio_usb_interface_enable) {
80003fca:	48 78       	lddpc	r8,80003fe4 <stdio_usb_putchar+0x1c>
80003fcc:	11 89       	ld.ub	r9,r8[0x0]
80003fce:	30 08       	mov	r8,0
80003fd0:	f0 09 18 00 	cp.b	r9,r8
80003fd4:	c0 60       	breq	80003fe0 <stdio_usb_putchar+0x18>
		return 0;  // -1
	}

	return udi_cdc_putc (data) ? 0 : -1;
80003fd6:	16 9c       	mov	r12,r11
80003fd8:	f0 1f 00 04 	mcall	80003fe8 <stdio_usb_putchar+0x20>
80003fdc:	c0 21       	brne	80003fe0 <stdio_usb_putchar+0x18>
80003fde:	dc 0a       	popm	pc,r12=-1
80003fe0:	d8 0a       	popm	pc,r12=0
80003fe2:	00 00       	add	r0,r0
80003fe4:	00 00       	add	r0,r0
80003fe6:	08 88       	andn	r8,r4
80003fe8:	80 00       	ld.sh	r0,r0[0x0]
80003fea:	34 20       	mov	r0,66

80003fec <_write>:

#elif (defined(__GNUC__) && !defined(XMEGA))

	int __attribute__((weak))
	_write (int file, char * ptr, int len)
	{
80003fec:	eb cd 40 f8 	pushm	r3-r7,lr
80003ff0:	16 94       	mov	r4,r11
80003ff2:	14 95       	mov	r5,r10
		int nChars = 0;
	
		if ( (file != 1)
80003ff4:	20 1c       	sub	r12,1
80003ff6:	58 2c       	cp.w	r12,2
80003ff8:	e0 8b 00 13 	brhi	8000401e <_write+0x32>
			&& (file != 2) && (file!=3))
		return -1;
	
		for (; len != 0; --len) {
80003ffc:	58 0a       	cp.w	r10,0
80003ffe:	c0 31       	brne	80004004 <_write+0x18>
80004000:	30 07       	mov	r7,0
80004002:	c0 f8       	rjmp	80004020 <_write+0x34>
80004004:	30 07       	mov	r7,0
			if (ptr_put(stdio_base, *ptr++) < 0) {
80004006:	48 93       	lddpc	r3,80004028 <_write+0x3c>
80004008:	48 96       	lddpc	r6,8000402c <_write+0x40>
8000400a:	66 0c       	ld.w	r12,r3[0x0]
8000400c:	6c 08       	ld.w	r8,r6[0x0]
8000400e:	e8 07 07 0b 	ld.ub	r11,r4[r7]
80004012:	5d 18       	icall	r8
80004014:	c0 55       	brlt	8000401e <_write+0x32>
				return -1;
			}
			++nChars;
80004016:	2f f7       	sub	r7,-1
	
		if ( (file != 1)
			&& (file != 2) && (file!=3))
		return -1;
	
		for (; len != 0; --len) {
80004018:	0e 35       	cp.w	r5,r7
8000401a:	cf 81       	brne	8000400a <_write+0x1e>
8000401c:	c0 28       	rjmp	80004020 <_write+0x34>
8000401e:	3f f7       	mov	r7,-1
				return -1;
			}
			++nChars;
		}
		return nChars;
	}
80004020:	0e 9c       	mov	r12,r7
80004022:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80004026:	00 00       	add	r0,r0
80004028:	00 00       	add	r0,r0
8000402a:	0a 28       	rsub	r8,r5
8000402c:	00 00       	add	r0,r0
8000402e:	0a 24       	rsub	r4,r5

80004030 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80004030:	f8 c8 ff f8 	sub	r8,r12,-8
80004034:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80004036:	3f f9       	mov	r9,-1
80004038:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
8000403a:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
8000403c:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
8000403e:	30 08       	mov	r8,0
80004040:	99 08       	st.w	r12[0x0],r8
}
80004042:	5e fc       	retal	r12

80004044 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80004044:	30 08       	mov	r8,0
80004046:	99 48       	st.w	r12[0x10],r8
}
80004048:	5e fc       	retal	r12

8000404a <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
8000404a:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
8000404c:	70 19       	ld.w	r9,r8[0x4]
8000404e:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80004050:	78 19       	ld.w	r9,r12[0x4]
80004052:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80004054:	70 19       	ld.w	r9,r8[0x4]
80004056:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80004058:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
8000405a:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
8000405c:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
8000405e:	78 08       	ld.w	r8,r12[0x0]
80004060:	2f f8       	sub	r8,-1
80004062:	99 08       	st.w	r12[0x0],r8
}
80004064:	5e fc       	retal	r12

80004066 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80004066:	78 18       	ld.w	r8,r12[0x4]
80004068:	78 29       	ld.w	r9,r12[0x8]
8000406a:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
8000406c:	78 28       	ld.w	r8,r12[0x8]
8000406e:	78 19       	ld.w	r9,r12[0x4]
80004070:	91 19       	st.w	r8[0x4],r9
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80004072:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80004074:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80004076:	18 39       	cp.w	r9,r12
80004078:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
8000407c:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80004080:	30 09       	mov	r9,0
80004082:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80004084:	70 09       	ld.w	r9,r8[0x0]
80004086:	20 19       	sub	r9,1
80004088:	91 09       	st.w	r8[0x0],r9
}
8000408a:	5e fc       	retal	r12

8000408c <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
8000408c:	e0 68 08 08 	mov	r8,2056
80004090:	ea 18 08 08 	orh	r8,0x808
80004094:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80004096:	e0 68 09 09 	mov	r8,2313
8000409a:	ea 18 09 09 	orh	r8,0x909
8000409e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
800040a0:	e0 68 0a 0a 	mov	r8,2570
800040a4:	ea 18 0a 0a 	orh	r8,0xa0a
800040a8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
800040aa:	e0 68 0b 0b 	mov	r8,2827
800040ae:	ea 18 0b 0b 	orh	r8,0xb0b
800040b2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
800040b4:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
800040b6:	e0 68 be ef 	mov	r8,48879
800040ba:	ea 18 de ad 	orh	r8,0xdead
800040be:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
800040c0:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
800040c2:	fc 18 00 40 	movh	r8,0x40
800040c6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
800040c8:	e0 68 00 ff 	mov	r8,255
800040cc:	ea 18 ff 00 	orh	r8,0xff00
800040d0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
800040d2:	e0 68 01 01 	mov	r8,257
800040d6:	ea 18 01 01 	orh	r8,0x101
800040da:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
800040dc:	e0 68 02 02 	mov	r8,514
800040e0:	ea 18 02 02 	orh	r8,0x202
800040e4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
800040e6:	e0 68 03 03 	mov	r8,771
800040ea:	ea 18 03 03 	orh	r8,0x303
800040ee:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
800040f0:	e0 68 04 04 	mov	r8,1028
800040f4:	ea 18 04 04 	orh	r8,0x404
800040f8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
800040fa:	e0 68 05 05 	mov	r8,1285
800040fe:	ea 18 05 05 	orh	r8,0x505
80004102:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80004104:	e0 68 06 06 	mov	r8,1542
80004108:	ea 18 06 06 	orh	r8,0x606
8000410c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
8000410e:	e0 68 07 07 	mov	r8,1799
80004112:	ea 18 07 07 	orh	r8,0x707
80004116:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80004118:	30 08       	mov	r8,0
8000411a:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
8000411c:	5e fc       	retal	r12
8000411e:	d7 03       	nop

80004120 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80004120:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80004122:	48 38       	lddpc	r8,8000412c <vPortEnterCritical+0xc>
80004124:	70 09       	ld.w	r9,r8[0x0]
80004126:	2f f9       	sub	r9,-1
80004128:	91 09       	st.w	r8[0x0],r9
}
8000412a:	5e fc       	retal	r12
8000412c:	00 00       	add	r0,r0
8000412e:	00 f4       	st.b	--r0,r4

80004130 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80004130:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80004132:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80004134:	30 0a       	mov	r10,0
80004136:	14 9b       	mov	r11,r10
80004138:	49 2c       	lddpc	r12,80004180 <xPortStartScheduler+0x50>
8000413a:	f0 1f 00 13 	mcall	80004184 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);
8000413e:	e0 68 2e e0 	mov	r8,12000
80004142:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80004146:	30 08       	mov	r8,0
80004148:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
8000414c:	e0 68 09 5c 	mov	r8,2396
80004150:	ea 18 00 00 	orh	r8,0x0
80004154:	70 00       	ld.w	r0,r8[0x0]
80004156:	60 0d       	ld.w	sp,r0[0x0]
80004158:	1b 00       	ld.w	r0,sp++
8000415a:	e0 68 00 f4 	mov	r8,244
8000415e:	ea 18 00 00 	orh	r8,0x0
80004162:	91 00       	st.w	r8[0x0],r0
80004164:	e3 cd 00 ff 	ldm	sp++,r0-r7
80004168:	2f ed       	sub	sp,-8
8000416a:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
8000416e:	fa f0 ff e0 	ld.w	r0,sp[-32]
80004172:	e3 b0 00 00 	mtsr	0x0,r0
80004176:	fa f0 ff dc 	ld.w	r0,sp[-36]
8000417a:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
8000417e:	d8 0a       	popm	pc,r12=0
80004180:	80 00       	ld.sh	r0,r0[0x0]
80004182:	42 4c       	lddsp	r12,sp[0x90]
80004184:	80 00       	ld.sh	r0,r0[0x0]
80004186:	22 38       	sub	r8,35

80004188 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80004188:	20 6d       	sub	sp,24
8000418a:	eb cd 00 ff 	pushm	r0-r7
8000418e:	fa c7 ff c0 	sub	r7,sp,-64
80004192:	ee f0 ff f8 	ld.w	r0,r7[-8]
80004196:	ef 40 ff e0 	st.w	r7[-32],r0
8000419a:	ee f0 ff fc 	ld.w	r0,r7[-4]
8000419e:	ef 40 ff e4 	st.w	r7[-28],r0
800041a2:	eb c7 5f 00 	stm	--r7,r8-r12,lr
800041a6:	e0 68 00 f4 	mov	r8,244
800041aa:	ea 18 00 00 	orh	r8,0x0
800041ae:	70 00       	ld.w	r0,r8[0x0]
800041b0:	1a d0       	st.w	--sp,r0
800041b2:	f0 1f 00 1a 	mcall	80004218 <LABEL_RET_SCALL_266+0x14>
800041b6:	e0 68 09 5c 	mov	r8,2396
800041ba:	ea 18 00 00 	orh	r8,0x0
800041be:	70 00       	ld.w	r0,r8[0x0]
800041c0:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
800041c2:	f0 1f 00 17 	mcall	8000421c <LABEL_RET_SCALL_266+0x18>
	portRESTORE_CONTEXT_SCALL();
800041c6:	e0 68 09 5c 	mov	r8,2396
800041ca:	ea 18 00 00 	orh	r8,0x0
800041ce:	70 00       	ld.w	r0,r8[0x0]
800041d0:	60 0d       	ld.w	sp,r0[0x0]
800041d2:	1b 00       	ld.w	r0,sp++
800041d4:	e0 68 00 f4 	mov	r8,244
800041d8:	ea 18 00 00 	orh	r8,0x0
800041dc:	91 00       	st.w	r8[0x0],r0
800041de:	fa c7 ff d8 	sub	r7,sp,-40
800041e2:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
800041e6:	ee f0 ff e0 	ld.w	r0,r7[-32]
800041ea:	e0 61 00 f4 	mov	r1,244
800041ee:	ea 11 00 00 	orh	r1,0x0
800041f2:	62 02       	ld.w	r2,r1[0x0]
800041f4:	58 02       	cp.w	r2,0
800041f6:	c0 70       	breq	80004204 <LABEL_RET_SCALL_266>
800041f8:	e4 c2 00 01 	sub	r2,r2,1
800041fc:	83 02       	st.w	r1[0x0],r2
800041fe:	58 02       	cp.w	r2,0
80004200:	c0 21       	brne	80004204 <LABEL_RET_SCALL_266>
80004202:	b1 c0       	cbr	r0,0x10

80004204 <LABEL_RET_SCALL_266>:
80004204:	ef 40 ff f8 	st.w	r7[-8],r0
80004208:	ee f0 ff e4 	ld.w	r0,r7[-28]
8000420c:	ef 40 ff fc 	st.w	r7[-4],r0
80004210:	e3 cd 00 ff 	ldm	sp++,r0-r7
80004214:	2f ad       	sub	sp,-24
80004216:	d6 13       	rets
80004218:	80 00       	ld.sh	r0,r0[0x0]
8000421a:	41 20       	lddsp	r0,sp[0x48]
8000421c:	80 00       	ld.sh	r0,r0[0x0]
8000421e:	43 60       	lddsp	r0,sp[0xd8]

80004220 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80004220:	e1 b8 00 43 	mfsr	r8,0x10c
80004224:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80004228:	5e fc       	retal	r12
8000422a:	d7 03       	nop

8000422c <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
8000422c:	48 78       	lddpc	r8,80004248 <vPortExitCritical+0x1c>
8000422e:	70 08       	ld.w	r8,r8[0x0]
80004230:	58 08       	cp.w	r8,0
80004232:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80004234:	48 58       	lddpc	r8,80004248 <vPortExitCritical+0x1c>
80004236:	70 09       	ld.w	r9,r8[0x0]
80004238:	20 19       	sub	r9,1
8000423a:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
8000423c:	70 08       	ld.w	r8,r8[0x0]
8000423e:	58 08       	cp.w	r8,0
80004240:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80004242:	d5 03       	csrf	0x10
80004244:	5e fc       	retal	r12
80004246:	00 00       	add	r0,r0
80004248:	00 00       	add	r0,r0
8000424a:	00 f4       	st.b	--r0,r4

8000424c <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
8000424c:	eb cd 00 ff 	pushm	r0-r7
80004250:	e0 68 00 f4 	mov	r8,244
80004254:	ea 18 00 00 	orh	r8,0x0
80004258:	70 00       	ld.w	r0,r8[0x0]
8000425a:	1a d0       	st.w	--sp,r0
8000425c:	7a 90       	ld.w	r0,sp[0x24]
8000425e:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80004262:	58 10       	cp.w	r0,1
80004264:	e0 8b 00 08 	brhi	80004274 <LABEL_INT_SKIP_SAVE_CONTEXT_240>
80004268:	e0 68 09 5c 	mov	r8,2396
8000426c:	ea 18 00 00 	orh	r8,0x0
80004270:	70 00       	ld.w	r0,r8[0x0]
80004272:	81 0d       	st.w	r0[0x0],sp

80004274 <LABEL_INT_SKIP_SAVE_CONTEXT_240>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80004274:	f0 1f 00 12 	mcall	800042bc <LABEL_INT_SKIP_RESTORE_CONTEXT_257+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80004278:	f0 1f 00 12 	mcall	800042c0 <LABEL_INT_SKIP_RESTORE_CONTEXT_257+0x18>
		vTaskIncrementTick();
8000427c:	f0 1f 00 12 	mcall	800042c4 <LABEL_INT_SKIP_RESTORE_CONTEXT_257+0x1c>
	portEXIT_CRITICAL();
80004280:	f0 1f 00 12 	mcall	800042c8 <LABEL_INT_SKIP_RESTORE_CONTEXT_257+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80004284:	7a 90       	ld.w	r0,sp[0x24]
80004286:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
8000428a:	58 10       	cp.w	r0,1
8000428c:	e0 8b 00 0e 	brhi	800042a8 <LABEL_INT_SKIP_RESTORE_CONTEXT_257>
80004290:	f0 1f 00 0c 	mcall	800042c0 <LABEL_INT_SKIP_RESTORE_CONTEXT_257+0x18>
80004294:	f0 1f 00 0e 	mcall	800042cc <LABEL_INT_SKIP_RESTORE_CONTEXT_257+0x24>
80004298:	f0 1f 00 0c 	mcall	800042c8 <LABEL_INT_SKIP_RESTORE_CONTEXT_257+0x20>
8000429c:	e0 68 09 5c 	mov	r8,2396
800042a0:	ea 18 00 00 	orh	r8,0x0
800042a4:	70 00       	ld.w	r0,r8[0x0]
800042a6:	60 0d       	ld.w	sp,r0[0x0]

800042a8 <LABEL_INT_SKIP_RESTORE_CONTEXT_257>:
800042a8:	1b 00       	ld.w	r0,sp++
800042aa:	e0 68 00 f4 	mov	r8,244
800042ae:	ea 18 00 00 	orh	r8,0x0
800042b2:	91 00       	st.w	r8[0x0],r0
800042b4:	e3 cd 00 ff 	ldm	sp++,r0-r7
800042b8:	d6 03       	rete
800042ba:	00 00       	add	r0,r0
800042bc:	80 00       	ld.sh	r0,r0[0x0]
800042be:	42 20       	lddsp	r0,sp[0x88]
800042c0:	80 00       	ld.sh	r0,r0[0x0]
800042c2:	41 20       	lddsp	r0,sp[0x48]
800042c4:	80 00       	ld.sh	r0,r0[0x0]
800042c6:	43 dc       	lddsp	r12,sp[0xf4]
800042c8:	80 00       	ld.sh	r0,r0[0x0]
800042ca:	42 2c       	lddsp	r12,sp[0x88]
800042cc:	80 00       	ld.sh	r0,r0[0x0]
800042ce:	43 60       	lddsp	r0,sp[0xd8]

800042d0 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
800042d0:	d4 01       	pushm	lr
	vTaskSuspendAll();
800042d2:	f0 1f 00 02 	mcall	800042d8 <__malloc_lock+0x8>
}
800042d6:	d8 02       	popm	pc
800042d8:	80 00       	ld.sh	r0,r0[0x0]
800042da:	43 50       	lddsp	r0,sp[0xd4]

800042dc <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
800042dc:	d4 01       	pushm	lr
	xTaskResumeAll();
800042de:	f0 1f 00 02 	mcall	800042e4 <__malloc_unlock+0x8>
}
800042e2:	d8 02       	popm	pc
800042e4:	80 00       	ld.sh	r0,r0[0x0]
800042e6:	44 f4       	lddsp	r4,sp[0x13c]

800042e8 <_init_startup>:
 * exception vectors are not compatible with the SCALL management in the current
 * FreeRTOS port. More low-level initializations are besides added here.
 */
int _init_startup(void);
int _init_startup(void)
{
800042e8:	d4 01       	pushm	lr
		extern void __heap_end__;
		portBASE_TYPE *pxMem;
	#endif

	/* Load the Exception Vector Base Address in the corresponding system register. */
	Set_system_register( AVR32_EVBA, ( int ) &_evba );
800042ea:	48 48       	lddpc	r8,800042f8 <_init_startup+0x10>
800042ec:	e3 b8 00 01 	mtsr	0x4,r8

	/* Enable exceptions. */
	ENABLE_ALL_EXCEPTIONS();
800042f0:	d5 53       	csrf	0x15

	/* Initialize interrupt handling. */
	INTC_init_interrupts();
800042f2:	f0 1f 00 03 	mcall	800042fc <_init_startup+0x14>
	}
	#endif

  // Don't-care value for GCC.
  return 1;
}
800042f6:	da 0a       	popm	pc,r12=1
800042f8:	80 00       	ld.sh	r0,r0[0x0]
800042fa:	5a 00       	cp.w	r0,-32
800042fc:	80 00       	ld.sh	r0,r0[0x0]
800042fe:	22 68       	sub	r8,38

80004300 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80004300:	eb cd 40 80 	pushm	r7,lr
80004304:	18 97       	mov	r7,r12
	if( pv )
80004306:	58 0c       	cp.w	r12,0
80004308:	c0 80       	breq	80004318 <vPortFree+0x18>
	{
		vTaskSuspendAll();
8000430a:	f0 1f 00 05 	mcall	8000431c <vPortFree+0x1c>
		{
			free( pv );
8000430e:	0e 9c       	mov	r12,r7
80004310:	f0 1f 00 04 	mcall	80004320 <vPortFree+0x20>
		}
		xTaskResumeAll();
80004314:	f0 1f 00 04 	mcall	80004324 <vPortFree+0x24>
80004318:	e3 cd 80 80 	ldm	sp++,r7,pc
8000431c:	80 00       	ld.sh	r0,r0[0x0]
8000431e:	43 50       	lddsp	r0,sp[0xd4]
80004320:	80 00       	ld.sh	r0,r0[0x0]
80004322:	4a 44       	lddpc	r4,800043b0 <vTaskSwitchContext+0x50>
80004324:	80 00       	ld.sh	r0,r0[0x0]
80004326:	44 f4       	lddsp	r4,sp[0x13c]

80004328 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80004328:	eb cd 40 80 	pushm	r7,lr
8000432c:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
8000432e:	f0 1f 00 06 	mcall	80004344 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80004332:	0e 9c       	mov	r12,r7
80004334:	f0 1f 00 05 	mcall	80004348 <pvPortMalloc+0x20>
80004338:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
8000433a:	f0 1f 00 05 	mcall	8000434c <pvPortMalloc+0x24>
		}
	}
	#endif
	
	return pvReturn;
}
8000433e:	0e 9c       	mov	r12,r7
80004340:	e3 cd 80 80 	ldm	sp++,r7,pc
80004344:	80 00       	ld.sh	r0,r0[0x0]
80004346:	43 50       	lddsp	r0,sp[0xd4]
80004348:	80 00       	ld.sh	r0,r0[0x0]
8000434a:	4a 5c       	lddpc	r12,800043dc <vTaskIncrementTick>
8000434c:	80 00       	ld.sh	r0,r0[0x0]
8000434e:	44 f4       	lddsp	r4,sp[0x13c]

80004350 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80004350:	48 38       	lddpc	r8,8000435c <vTaskSuspendAll+0xc>
80004352:	70 09       	ld.w	r9,r8[0x0]
80004354:	2f f9       	sub	r9,-1
80004356:	91 09       	st.w	r8[0x0],r9
}
80004358:	5e fc       	retal	r12
8000435a:	00 00       	add	r0,r0
8000435c:	00 00       	add	r0,r0
8000435e:	09 8c       	ld.ub	r12,r4[0x0]

80004360 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80004360:	49 a8       	lddpc	r8,800043c8 <vTaskSwitchContext+0x68>
80004362:	70 08       	ld.w	r8,r8[0x0]
80004364:	58 08       	cp.w	r8,0
80004366:	c0 b1       	brne	8000437c <vTaskSwitchContext+0x1c>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80004368:	49 98       	lddpc	r8,800043cc <vTaskSwitchContext+0x6c>
8000436a:	70 08       	ld.w	r8,r8[0x0]
8000436c:	f0 08 00 28 	add	r8,r8,r8<<0x2
80004370:	49 89       	lddpc	r9,800043d0 <vTaskSwitchContext+0x70>
80004372:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80004376:	58 08       	cp.w	r8,0
80004378:	c0 60       	breq	80004384 <vTaskSwitchContext+0x24>
8000437a:	c1 18       	rjmp	8000439c <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
8000437c:	30 19       	mov	r9,1
8000437e:	49 68       	lddpc	r8,800043d4 <vTaskSwitchContext+0x74>
80004380:	91 09       	st.w	r8[0x0],r9
80004382:	5e fc       	retal	r12
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80004384:	49 28       	lddpc	r8,800043cc <vTaskSwitchContext+0x6c>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80004386:	49 3a       	lddpc	r10,800043d0 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80004388:	70 09       	ld.w	r9,r8[0x0]
8000438a:	20 19       	sub	r9,1
8000438c:	91 09       	st.w	r8[0x0],r9
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000438e:	70 09       	ld.w	r9,r8[0x0]
80004390:	f2 09 00 29 	add	r9,r9,r9<<0x2
80004394:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
80004398:	58 09       	cp.w	r9,0
8000439a:	cf 70       	breq	80004388 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
8000439c:	48 c8       	lddpc	r8,800043cc <vTaskSwitchContext+0x6c>
8000439e:	70 08       	ld.w	r8,r8[0x0]
800043a0:	f0 08 00 28 	add	r8,r8,r8<<0x2
800043a4:	48 b9       	lddpc	r9,800043d0 <vTaskSwitchContext+0x70>
800043a6:	f2 08 00 28 	add	r8,r9,r8<<0x2
800043aa:	70 19       	ld.w	r9,r8[0x4]
800043ac:	72 19       	ld.w	r9,r9[0x4]
800043ae:	91 19       	st.w	r8[0x4],r9
800043b0:	f0 ca ff f8 	sub	r10,r8,-8
800043b4:	14 39       	cp.w	r9,r10
800043b6:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
800043ba:	f1 f9 0a 01 	st.weq	r8[0x4],r9
800043be:	70 18       	ld.w	r8,r8[0x4]
800043c0:	70 39       	ld.w	r9,r8[0xc]
800043c2:	48 68       	lddpc	r8,800043d8 <vTaskSwitchContext+0x78>
800043c4:	91 09       	st.w	r8[0x0],r9
800043c6:	5e fc       	retal	r12
800043c8:	00 00       	add	r0,r0
800043ca:	09 8c       	ld.ub	r12,r4[0x0]
800043cc:	00 00       	add	r0,r0
800043ce:	09 c4       	ld.ub	r4,r4[0x4]
800043d0:	00 00       	add	r0,r0
800043d2:	08 a8       	st.w	r4++,r8
800043d4:	00 00       	add	r0,r0
800043d6:	09 ac       	ld.ub	r12,r4[0x2]
800043d8:	00 00       	add	r0,r0
800043da:	09 5c       	ld.sh	r12,--r4

800043dc <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
800043dc:	eb cd 40 fe 	pushm	r1-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800043e0:	4b a8       	lddpc	r8,800044c8 <vTaskIncrementTick+0xec>
800043e2:	70 08       	ld.w	r8,r8[0x0]
800043e4:	58 08       	cp.w	r8,0
800043e6:	c6 a1       	brne	800044ba <vTaskIncrementTick+0xde>
	{
		++xTickCount;
800043e8:	4b 98       	lddpc	r8,800044cc <vTaskIncrementTick+0xf0>
800043ea:	70 09       	ld.w	r9,r8[0x0]
800043ec:	2f f9       	sub	r9,-1
800043ee:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
800043f0:	70 08       	ld.w	r8,r8[0x0]
800043f2:	58 08       	cp.w	r8,0
800043f4:	c1 a1       	brne	80004428 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
800043f6:	4b 78       	lddpc	r8,800044d0 <vTaskIncrementTick+0xf4>
800043f8:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
800043fa:	4b 79       	lddpc	r9,800044d4 <vTaskIncrementTick+0xf8>
800043fc:	72 0b       	ld.w	r11,r9[0x0]
800043fe:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
80004400:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
80004402:	4b 69       	lddpc	r9,800044d8 <vTaskIncrementTick+0xfc>
80004404:	72 0a       	ld.w	r10,r9[0x0]
80004406:	2f fa       	sub	r10,-1
80004408:	93 0a       	st.w	r9[0x0],r10
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
8000440a:	70 08       	ld.w	r8,r8[0x0]
8000440c:	70 08       	ld.w	r8,r8[0x0]
8000440e:	58 08       	cp.w	r8,0
80004410:	c0 51       	brne	8000441a <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set 
				xNextTaskUnblockTime to the maximum possible value so it is 
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until 
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
80004412:	3f f9       	mov	r9,-1
80004414:	4b 28       	lddpc	r8,800044dc <vTaskIncrementTick+0x100>
80004416:	91 09       	st.w	r8[0x0],r9
80004418:	c0 88       	rjmp	80004428 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of 
				the item at the head of the delayed list.  This is the time at 
				which the task at the head of the delayed list should be removed 
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
8000441a:	4a e8       	lddpc	r8,800044d0 <vTaskIncrementTick+0xf4>
8000441c:	70 08       	ld.w	r8,r8[0x0]
8000441e:	70 38       	ld.w	r8,r8[0xc]
80004420:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
80004422:	70 19       	ld.w	r9,r8[0x4]
80004424:	4a e8       	lddpc	r8,800044dc <vTaskIncrementTick+0x100>
80004426:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80004428:	4a 98       	lddpc	r8,800044cc <vTaskIncrementTick+0xf0>
8000442a:	70 09       	ld.w	r9,r8[0x0]
8000442c:	4a c8       	lddpc	r8,800044dc <vTaskIncrementTick+0x100>
8000442e:	70 08       	ld.w	r8,r8[0x0]
80004430:	10 39       	cp.w	r9,r8
80004432:	c4 83       	brcs	800044c2 <vTaskIncrementTick+0xe6>
80004434:	4a 78       	lddpc	r8,800044d0 <vTaskIncrementTick+0xf4>
80004436:	70 08       	ld.w	r8,r8[0x0]
80004438:	70 08       	ld.w	r8,r8[0x0]
8000443a:	58 08       	cp.w	r8,0
8000443c:	c0 c0       	breq	80004454 <vTaskIncrementTick+0x78>
8000443e:	4a 58       	lddpc	r8,800044d0 <vTaskIncrementTick+0xf4>
80004440:	70 08       	ld.w	r8,r8[0x0]
80004442:	70 38       	ld.w	r8,r8[0xc]
80004444:	70 37       	ld.w	r7,r8[0xc]
80004446:	6e 18       	ld.w	r8,r7[0x4]
80004448:	4a 19       	lddpc	r9,800044cc <vTaskIncrementTick+0xf0>
8000444a:	72 09       	ld.w	r9,r9[0x0]
8000444c:	12 38       	cp.w	r8,r9
8000444e:	e0 88 00 14 	brls	80004476 <vTaskIncrementTick+0x9a>
80004452:	c0 e8       	rjmp	8000446e <vTaskIncrementTick+0x92>
80004454:	3f f9       	mov	r9,-1
80004456:	4a 28       	lddpc	r8,800044dc <vTaskIncrementTick+0x100>
80004458:	91 09       	st.w	r8[0x0],r9
8000445a:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
8000445e:	6a 08       	ld.w	r8,r5[0x0]
80004460:	70 38       	ld.w	r8,r8[0xc]
80004462:	70 37       	ld.w	r7,r8[0xc]
80004464:	6e 18       	ld.w	r8,r7[0x4]
80004466:	64 09       	ld.w	r9,r2[0x0]
80004468:	12 38       	cp.w	r8,r9
8000446a:	e0 88 00 0b 	brls	80004480 <vTaskIncrementTick+0xa4>
8000446e:	49 c9       	lddpc	r9,800044dc <vTaskIncrementTick+0x100>
80004470:	93 08       	st.w	r9[0x0],r8
80004472:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80004476:	49 b4       	lddpc	r4,800044e0 <vTaskIncrementTick+0x104>
80004478:	08 91       	mov	r1,r4
8000447a:	49 b3       	lddpc	r3,800044e4 <vTaskIncrementTick+0x108>
8000447c:	49 55       	lddpc	r5,800044d0 <vTaskIncrementTick+0xf4>
8000447e:	49 42       	lddpc	r2,800044cc <vTaskIncrementTick+0xf0>
80004480:	ee c6 ff fc 	sub	r6,r7,-4
80004484:	0c 9c       	mov	r12,r6
80004486:	f0 1f 00 19 	mcall	800044e8 <vTaskIncrementTick+0x10c>
8000448a:	6e a8       	ld.w	r8,r7[0x28]
8000448c:	58 08       	cp.w	r8,0
8000448e:	c0 50       	breq	80004498 <vTaskIncrementTick+0xbc>
80004490:	ee cc ff e8 	sub	r12,r7,-24
80004494:	f0 1f 00 15 	mcall	800044e8 <vTaskIncrementTick+0x10c>
80004498:	6e bc       	ld.w	r12,r7[0x2c]
8000449a:	68 08       	ld.w	r8,r4[0x0]
8000449c:	10 3c       	cp.w	r12,r8
8000449e:	e3 fc ba 00 	st.whi	r1[0x0],r12
800044a2:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800044a6:	0c 9b       	mov	r11,r6
800044a8:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
800044ac:	f0 1f 00 10 	mcall	800044ec <vTaskIncrementTick+0x110>
800044b0:	6a 08       	ld.w	r8,r5[0x0]
800044b2:	70 08       	ld.w	r8,r8[0x0]
800044b4:	58 08       	cp.w	r8,0
800044b6:	cd 41       	brne	8000445e <vTaskIncrementTick+0x82>
800044b8:	cc eb       	rjmp	80004454 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
800044ba:	48 e8       	lddpc	r8,800044f0 <vTaskIncrementTick+0x114>
800044bc:	70 09       	ld.w	r9,r8[0x0]
800044be:	2f f9       	sub	r9,-1
800044c0:	91 09       	st.w	r8[0x0],r9
800044c2:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
800044c6:	00 00       	add	r0,r0
800044c8:	00 00       	add	r0,r0
800044ca:	09 8c       	ld.ub	r12,r4[0x0]
800044cc:	00 00       	add	r0,r0
800044ce:	09 88       	ld.ub	r8,r4[0x0]
800044d0:	00 00       	add	r0,r0
800044d2:	08 94       	mov	r4,r4
800044d4:	00 00       	add	r0,r0
800044d6:	08 a4       	st.w	r4++,r4
800044d8:	00 00       	add	r0,r0
800044da:	08 a0       	st.w	r4++,r0
800044dc:	00 00       	add	r0,r0
800044de:	00 f8       	st.b	--r0,r8
800044e0:	00 00       	add	r0,r0
800044e2:	09 c4       	ld.ub	r4,r4[0x4]
800044e4:	00 00       	add	r0,r0
800044e6:	08 a8       	st.w	r4++,r8
800044e8:	80 00       	ld.sh	r0,r0[0x0]
800044ea:	40 66       	lddsp	r6,sp[0x18]
800044ec:	80 00       	ld.sh	r0,r0[0x0]
800044ee:	40 4a       	lddsp	r10,sp[0x10]
800044f0:	00 00       	add	r0,r0
800044f2:	08 8c       	andn	r12,r4

800044f4 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
800044f4:	d4 31       	pushm	r0-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
800044f6:	f0 1f 00 2c 	mcall	800045a4 <xTaskResumeAll+0xb0>
	{
		--uxSchedulerSuspended;
800044fa:	4a c8       	lddpc	r8,800045a8 <xTaskResumeAll+0xb4>
800044fc:	70 09       	ld.w	r9,r8[0x0]
800044fe:	20 19       	sub	r9,1
80004500:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80004502:	70 08       	ld.w	r8,r8[0x0]
80004504:	58 08       	cp.w	r8,0
80004506:	c4 a1       	brne	8000459a <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80004508:	4a 98       	lddpc	r8,800045ac <xTaskResumeAll+0xb8>
8000450a:	70 08       	ld.w	r8,r8[0x0]
8000450c:	58 08       	cp.w	r8,0
8000450e:	c4 60       	breq	8000459a <xTaskResumeAll+0xa6>
80004510:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80004512:	4a 85       	lddpc	r5,800045b0 <xTaskResumeAll+0xbc>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
80004514:	4a 83       	lddpc	r3,800045b4 <xTaskResumeAll+0xc0>
80004516:	06 90       	mov	r0,r3
80004518:	4a 82       	lddpc	r2,800045b8 <xTaskResumeAll+0xc4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000451a:	4a 91       	lddpc	r1,800045bc <xTaskResumeAll+0xc8>
8000451c:	c1 e8       	rjmp	80004558 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
8000451e:	6a 38       	ld.w	r8,r5[0xc]
80004520:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
80004522:	ee cc ff e8 	sub	r12,r7,-24
80004526:	f0 1f 00 27 	mcall	800045c0 <xTaskResumeAll+0xcc>
					vListRemove( &( pxTCB->xGenericListItem ) );
8000452a:	ee c6 ff fc 	sub	r6,r7,-4
8000452e:	0c 9c       	mov	r12,r6
80004530:	f0 1f 00 24 	mcall	800045c0 <xTaskResumeAll+0xcc>
					prvAddTaskToReadyQueue( pxTCB );
80004534:	6e bc       	ld.w	r12,r7[0x2c]
80004536:	66 08       	ld.w	r8,r3[0x0]
80004538:	10 3c       	cp.w	r12,r8
8000453a:	e1 fc ba 00 	st.whi	r0[0x0],r12
8000453e:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80004542:	0c 9b       	mov	r11,r6
80004544:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80004548:	f0 1f 00 1f 	mcall	800045c4 <xTaskResumeAll+0xd0>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000454c:	62 08       	ld.w	r8,r1[0x0]
8000454e:	6e b9       	ld.w	r9,r7[0x2c]
80004550:	70 b8       	ld.w	r8,r8[0x2c]
80004552:	10 39       	cp.w	r9,r8
80004554:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80004558:	6a 08       	ld.w	r8,r5[0x0]
8000455a:	58 08       	cp.w	r8,0
8000455c:	ce 11       	brne	8000451e <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000455e:	49 b8       	lddpc	r8,800045c8 <xTaskResumeAll+0xd4>
80004560:	70 08       	ld.w	r8,r8[0x0]
80004562:	58 08       	cp.w	r8,0
80004564:	c0 f0       	breq	80004582 <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80004566:	49 98       	lddpc	r8,800045c8 <xTaskResumeAll+0xd4>
80004568:	70 08       	ld.w	r8,r8[0x0]
8000456a:	58 08       	cp.w	r8,0
8000456c:	c1 10       	breq	8000458e <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
8000456e:	49 77       	lddpc	r7,800045c8 <xTaskResumeAll+0xd4>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80004570:	f0 1f 00 17 	mcall	800045cc <xTaskResumeAll+0xd8>
						--uxMissedTicks;
80004574:	6e 08       	ld.w	r8,r7[0x0]
80004576:	20 18       	sub	r8,1
80004578:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000457a:	6e 08       	ld.w	r8,r7[0x0]
8000457c:	58 08       	cp.w	r8,0
8000457e:	cf 91       	brne	80004570 <xTaskResumeAll+0x7c>
80004580:	c0 78       	rjmp	8000458e <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80004582:	58 14       	cp.w	r4,1
80004584:	c0 50       	breq	8000458e <xTaskResumeAll+0x9a>
80004586:	49 38       	lddpc	r8,800045d0 <xTaskResumeAll+0xdc>
80004588:	70 08       	ld.w	r8,r8[0x0]
8000458a:	58 18       	cp.w	r8,1
8000458c:	c0 71       	brne	8000459a <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
8000458e:	30 09       	mov	r9,0
80004590:	49 08       	lddpc	r8,800045d0 <xTaskResumeAll+0xdc>
80004592:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80004594:	d7 33       	scall
80004596:	30 17       	mov	r7,1
80004598:	c0 28       	rjmp	8000459c <xTaskResumeAll+0xa8>
8000459a:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
8000459c:	f0 1f 00 0e 	mcall	800045d4 <xTaskResumeAll+0xe0>

	return xAlreadyYielded;
}
800045a0:	0e 9c       	mov	r12,r7
800045a2:	d8 32       	popm	r0-r7,pc
800045a4:	80 00       	ld.sh	r0,r0[0x0]
800045a6:	41 20       	lddsp	r0,sp[0x48]
800045a8:	00 00       	add	r0,r0
800045aa:	09 8c       	ld.ub	r12,r4[0x0]
800045ac:	00 00       	add	r0,r0
800045ae:	09 a8       	ld.ub	r8,r4[0x2]
800045b0:	00 00       	add	r0,r0
800045b2:	09 60       	ld.uh	r0,--r4
800045b4:	00 00       	add	r0,r0
800045b6:	09 c4       	ld.ub	r4,r4[0x4]
800045b8:	00 00       	add	r0,r0
800045ba:	08 a8       	st.w	r4++,r8
800045bc:	00 00       	add	r0,r0
800045be:	09 5c       	ld.sh	r12,--r4
800045c0:	80 00       	ld.sh	r0,r0[0x0]
800045c2:	40 66       	lddsp	r6,sp[0x18]
800045c4:	80 00       	ld.sh	r0,r0[0x0]
800045c6:	40 4a       	lddsp	r10,sp[0x10]
800045c8:	00 00       	add	r0,r0
800045ca:	08 8c       	andn	r12,r4
800045cc:	80 00       	ld.sh	r0,r0[0x0]
800045ce:	43 dc       	lddsp	r12,sp[0xf4]
800045d0:	00 00       	add	r0,r0
800045d2:	09 ac       	ld.ub	r12,r4[0x2]
800045d4:	80 00       	ld.sh	r0,r0[0x0]
800045d6:	42 2c       	lddsp	r12,sp[0x88]

800045d8 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
800045d8:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
800045dc:	49 57       	lddpc	r7,80004630 <prvIdleTask+0x58>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
800045de:	49 64       	lddpc	r4,80004634 <prvIdleTask+0x5c>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
800045e0:	49 63       	lddpc	r3,80004638 <prvIdleTask+0x60>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
800045e2:	49 75       	lddpc	r5,8000463c <prvIdleTask+0x64>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
800045e4:	6e 08       	ld.w	r8,r7[0x0]
800045e6:	58 08       	cp.w	r8,0
800045e8:	c1 e0       	breq	80004624 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
800045ea:	f0 1f 00 16 	mcall	80004640 <prvIdleTask+0x68>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
800045ee:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
800045f0:	f0 1f 00 15 	mcall	80004644 <prvIdleTask+0x6c>

			if( xListIsEmpty == pdFALSE )
800045f4:	58 06       	cp.w	r6,0
800045f6:	c1 70       	breq	80004624 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
800045f8:	f0 1f 00 14 	mcall	80004648 <prvIdleTask+0x70>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
800045fc:	68 38       	ld.w	r8,r4[0xc]
800045fe:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80004600:	ec cc ff fc 	sub	r12,r6,-4
80004604:	f0 1f 00 12 	mcall	8000464c <prvIdleTask+0x74>
					--uxCurrentNumberOfTasks;
80004608:	66 08       	ld.w	r8,r3[0x0]
8000460a:	20 18       	sub	r8,1
8000460c:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
8000460e:	6e 08       	ld.w	r8,r7[0x0]
80004610:	20 18       	sub	r8,1
80004612:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80004614:	f0 1f 00 0f 	mcall	80004650 <prvIdleTask+0x78>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80004618:	6c cc       	ld.w	r12,r6[0x30]
8000461a:	f0 1f 00 0f 	mcall	80004654 <prvIdleTask+0x7c>
		vPortFree( pxTCB );
8000461e:	0c 9c       	mov	r12,r6
80004620:	f0 1f 00 0d 	mcall	80004654 <prvIdleTask+0x7c>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80004624:	6a 08       	ld.w	r8,r5[0x0]
80004626:	58 18       	cp.w	r8,1
80004628:	fe 98 ff de 	brls	800045e4 <prvIdleTask+0xc>
			{
				taskYIELD();
8000462c:	d7 33       	scall
8000462e:	cd bb       	rjmp	800045e4 <prvIdleTask+0xc>
80004630:	00 00       	add	r0,r0
80004632:	08 9c       	mov	r12,r4
80004634:	00 00       	add	r0,r0
80004636:	09 48       	ld.w	r8,--r4
80004638:	00 00       	add	r0,r0
8000463a:	09 a8       	ld.ub	r8,r4[0x2]
8000463c:	00 00       	add	r0,r0
8000463e:	08 a8       	st.w	r4++,r8
80004640:	80 00       	ld.sh	r0,r0[0x0]
80004642:	43 50       	lddsp	r0,sp[0xd4]
80004644:	80 00       	ld.sh	r0,r0[0x0]
80004646:	44 f4       	lddsp	r4,sp[0x13c]
80004648:	80 00       	ld.sh	r0,r0[0x0]
8000464a:	41 20       	lddsp	r0,sp[0x48]
8000464c:	80 00       	ld.sh	r0,r0[0x0]
8000464e:	40 66       	lddsp	r6,sp[0x18]
80004650:	80 00       	ld.sh	r0,r0[0x0]
80004652:	42 2c       	lddsp	r12,sp[0x88]
80004654:	80 00       	ld.sh	r0,r0[0x0]
80004656:	43 00       	lddsp	r0,sp[0xc0]

80004658 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80004658:	d4 31       	pushm	r0-r7,lr
8000465a:	20 1d       	sub	sp,4
8000465c:	fa c4 ff d8 	sub	r4,sp,-40
80004660:	50 0c       	stdsp	sp[0x0],r12
80004662:	16 91       	mov	r1,r11
80004664:	14 97       	mov	r7,r10
80004666:	12 90       	mov	r0,r9
80004668:	10 93       	mov	r3,r8
8000466a:	68 02       	ld.w	r2,r4[0x0]
8000466c:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
8000466e:	34 4c       	mov	r12,68
80004670:	f0 1f 00 5b 	mcall	800047dc <xTaskGenericCreate+0x184>
80004674:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80004676:	c0 31       	brne	8000467c <xTaskGenericCreate+0x24>
80004678:	3f fc       	mov	r12,-1
8000467a:	ca d8       	rjmp	800047d4 <xTaskGenericCreate+0x17c>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
8000467c:	58 06       	cp.w	r6,0
8000467e:	e0 81 00 ad 	brne	800047d8 <xTaskGenericCreate+0x180>
80004682:	0e 9c       	mov	r12,r7
80004684:	5c 7c       	castu.h	r12
80004686:	a3 6c       	lsl	r12,0x2
80004688:	f0 1f 00 55 	mcall	800047dc <xTaskGenericCreate+0x184>
8000468c:	18 96       	mov	r6,r12
8000468e:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80004690:	c0 61       	brne	8000469c <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80004692:	0a 9c       	mov	r12,r5
80004694:	f0 1f 00 53 	mcall	800047e0 <xTaskGenericCreate+0x188>
80004698:	3f fc       	mov	r12,-1
8000469a:	c9 d8       	rjmp	800047d4 <xTaskGenericCreate+0x17c>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
8000469c:	5c 77       	castu.h	r7
8000469e:	ee 0a 15 02 	lsl	r10,r7,0x2
800046a2:	e0 6b 00 a5 	mov	r11,165
800046a6:	0c 9c       	mov	r12,r6
800046a8:	f0 1f 00 4f 	mcall	800047e4 <xTaskGenericCreate+0x18c>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
800046ac:	ee c6 00 01 	sub	r6,r7,1
800046b0:	6a c8       	ld.w	r8,r5[0x30]
800046b2:	f0 06 00 26 	add	r6,r8,r6<<0x2
800046b6:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
800046ba:	31 0a       	mov	r10,16
800046bc:	02 9b       	mov	r11,r1
800046be:	ea cc ff cc 	sub	r12,r5,-52
800046c2:	f0 1f 00 4a 	mcall	800047e8 <xTaskGenericCreate+0x190>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
800046c6:	30 08       	mov	r8,0
800046c8:	eb 68 00 43 	st.b	r5[67],r8
800046cc:	58 73       	cp.w	r3,7
800046ce:	e6 07 17 80 	movls	r7,r3
800046d2:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
800046d6:	8b b7       	st.w	r5[0x2c],r7
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
800046d8:	ea c4 ff fc 	sub	r4,r5,-4
800046dc:	08 9c       	mov	r12,r4
800046de:	f0 1f 00 44 	mcall	800047ec <xTaskGenericCreate+0x194>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
800046e2:	ea cc ff e8 	sub	r12,r5,-24
800046e6:	f0 1f 00 42 	mcall	800047ec <xTaskGenericCreate+0x194>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
800046ea:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
800046ec:	ee 07 11 08 	rsub	r7,r7,8
800046f0:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
800046f2:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
800046f4:	00 9a       	mov	r10,r0
800046f6:	40 0b       	lddsp	r11,sp[0x0]
800046f8:	0c 9c       	mov	r12,r6
800046fa:	f0 1f 00 3e 	mcall	800047f0 <xTaskGenericCreate+0x198>
800046fe:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80004700:	58 02       	cp.w	r2,0
80004702:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80004706:	f0 1f 00 3c 	mcall	800047f4 <xTaskGenericCreate+0x19c>
		{
			uxCurrentNumberOfTasks++;
8000470a:	4b c8       	lddpc	r8,800047f8 <xTaskGenericCreate+0x1a0>
8000470c:	70 09       	ld.w	r9,r8[0x0]
8000470e:	2f f9       	sub	r9,-1
80004710:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80004712:	4b b8       	lddpc	r8,800047fc <xTaskGenericCreate+0x1a4>
80004714:	70 08       	ld.w	r8,r8[0x0]
80004716:	58 08       	cp.w	r8,0
80004718:	c2 61       	brne	80004764 <xTaskGenericCreate+0x10c>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
8000471a:	4b 98       	lddpc	r8,800047fc <xTaskGenericCreate+0x1a4>
8000471c:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
8000471e:	4b 78       	lddpc	r8,800047f8 <xTaskGenericCreate+0x1a0>
80004720:	70 08       	ld.w	r8,r8[0x0]
80004722:	58 18       	cp.w	r8,1
80004724:	c2 b1       	brne	8000477a <xTaskGenericCreate+0x122>
80004726:	4b 77       	lddpc	r7,80004800 <xTaskGenericCreate+0x1a8>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80004728:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
8000472c:	0e 9c       	mov	r12,r7
8000472e:	f0 1f 00 36 	mcall	80004804 <xTaskGenericCreate+0x1ac>
80004732:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80004734:	0c 37       	cp.w	r7,r6
80004736:	cf b1       	brne	8000472c <xTaskGenericCreate+0xd4>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80004738:	4b 47       	lddpc	r7,80004808 <xTaskGenericCreate+0x1b0>
8000473a:	0e 9c       	mov	r12,r7
8000473c:	f0 1f 00 32 	mcall	80004804 <xTaskGenericCreate+0x1ac>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80004740:	4b 36       	lddpc	r6,8000480c <xTaskGenericCreate+0x1b4>
80004742:	0c 9c       	mov	r12,r6
80004744:	f0 1f 00 30 	mcall	80004804 <xTaskGenericCreate+0x1ac>
	vListInitialise( ( xList * ) &xPendingReadyList );
80004748:	4b 2c       	lddpc	r12,80004810 <xTaskGenericCreate+0x1b8>
8000474a:	f0 1f 00 2f 	mcall	80004804 <xTaskGenericCreate+0x1ac>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
8000474e:	4b 2c       	lddpc	r12,80004814 <xTaskGenericCreate+0x1bc>
80004750:	f0 1f 00 2d 	mcall	80004804 <xTaskGenericCreate+0x1ac>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80004754:	4b 1c       	lddpc	r12,80004818 <xTaskGenericCreate+0x1c0>
80004756:	f0 1f 00 2c 	mcall	80004804 <xTaskGenericCreate+0x1ac>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
8000475a:	4b 18       	lddpc	r8,8000481c <xTaskGenericCreate+0x1c4>
8000475c:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
8000475e:	4b 18       	lddpc	r8,80004820 <xTaskGenericCreate+0x1c8>
80004760:	91 06       	st.w	r8[0x0],r6
80004762:	c0 c8       	rjmp	8000477a <xTaskGenericCreate+0x122>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80004764:	4b 08       	lddpc	r8,80004824 <xTaskGenericCreate+0x1cc>
80004766:	70 08       	ld.w	r8,r8[0x0]
80004768:	58 08       	cp.w	r8,0
8000476a:	c0 81       	brne	8000477a <xTaskGenericCreate+0x122>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
8000476c:	4a 48       	lddpc	r8,800047fc <xTaskGenericCreate+0x1a4>
8000476e:	70 08       	ld.w	r8,r8[0x0]
80004770:	70 b8       	ld.w	r8,r8[0x2c]
80004772:	10 33       	cp.w	r3,r8
80004774:	c0 33       	brcs	8000477a <xTaskGenericCreate+0x122>
					{
						pxCurrentTCB = pxNewTCB;
80004776:	4a 28       	lddpc	r8,800047fc <xTaskGenericCreate+0x1a4>
80004778:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
8000477a:	6a b8       	ld.w	r8,r5[0x2c]
8000477c:	4a b9       	lddpc	r9,80004828 <xTaskGenericCreate+0x1d0>
8000477e:	72 09       	ld.w	r9,r9[0x0]
80004780:	12 38       	cp.w	r8,r9
80004782:	e0 88 00 04 	brls	8000478a <xTaskGenericCreate+0x132>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80004786:	4a 99       	lddpc	r9,80004828 <xTaskGenericCreate+0x1d0>
80004788:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
8000478a:	4a 98       	lddpc	r8,8000482c <xTaskGenericCreate+0x1d4>
8000478c:	70 09       	ld.w	r9,r8[0x0]
8000478e:	2f f9       	sub	r9,-1
80004790:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80004792:	6a b8       	ld.w	r8,r5[0x2c]
80004794:	4a 79       	lddpc	r9,80004830 <xTaskGenericCreate+0x1d8>
80004796:	72 09       	ld.w	r9,r9[0x0]
80004798:	12 38       	cp.w	r8,r9
8000479a:	e0 88 00 04 	brls	800047a2 <xTaskGenericCreate+0x14a>
8000479e:	4a 59       	lddpc	r9,80004830 <xTaskGenericCreate+0x1d8>
800047a0:	93 08       	st.w	r9[0x0],r8
800047a2:	6a bc       	ld.w	r12,r5[0x2c]
800047a4:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800047a8:	08 9b       	mov	r11,r4
800047aa:	49 68       	lddpc	r8,80004800 <xTaskGenericCreate+0x1a8>
800047ac:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800047b0:	f0 1f 00 21 	mcall	80004834 <xTaskGenericCreate+0x1dc>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
800047b4:	f0 1f 00 21 	mcall	80004838 <xTaskGenericCreate+0x1e0>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
800047b8:	49 b8       	lddpc	r8,80004824 <xTaskGenericCreate+0x1cc>
800047ba:	70 08       	ld.w	r8,r8[0x0]
800047bc:	58 08       	cp.w	r8,0
800047be:	c0 a0       	breq	800047d2 <xTaskGenericCreate+0x17a>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
800047c0:	48 f8       	lddpc	r8,800047fc <xTaskGenericCreate+0x1a4>
800047c2:	70 08       	ld.w	r8,r8[0x0]
800047c4:	70 b8       	ld.w	r8,r8[0x2c]
800047c6:	10 33       	cp.w	r3,r8
800047c8:	e0 88 00 05 	brls	800047d2 <xTaskGenericCreate+0x17a>
			{
				portYIELD_WITHIN_API();
800047cc:	d7 33       	scall
800047ce:	30 1c       	mov	r12,1
800047d0:	c0 28       	rjmp	800047d4 <xTaskGenericCreate+0x17c>
800047d2:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
800047d4:	2f fd       	sub	sp,-4
800047d6:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
800047d8:	99 c6       	st.w	r12[0x30],r6
800047da:	c6 1b       	rjmp	8000469c <xTaskGenericCreate+0x44>
800047dc:	80 00       	ld.sh	r0,r0[0x0]
800047de:	43 28       	lddsp	r8,sp[0xc8]
800047e0:	80 00       	ld.sh	r0,r0[0x0]
800047e2:	43 00       	lddsp	r0,sp[0xc0]
800047e4:	80 00       	ld.sh	r0,r0[0x0]
800047e6:	4e c4       	lddpc	r4,80004994 <main+0x20>
800047e8:	80 00       	ld.sh	r0,r0[0x0]
800047ea:	50 38       	stdsp	sp[0xc],r8
800047ec:	80 00       	ld.sh	r0,r0[0x0]
800047ee:	40 44       	lddsp	r4,sp[0x10]
800047f0:	80 00       	ld.sh	r0,r0[0x0]
800047f2:	40 8c       	lddsp	r12,sp[0x20]
800047f4:	80 00       	ld.sh	r0,r0[0x0]
800047f6:	41 20       	lddsp	r0,sp[0x48]
800047f8:	00 00       	add	r0,r0
800047fa:	09 a8       	ld.ub	r8,r4[0x2]
800047fc:	00 00       	add	r0,r0
800047fe:	09 5c       	ld.sh	r12,--r4
80004800:	00 00       	add	r0,r0
80004802:	08 a8       	st.w	r4++,r8
80004804:	80 00       	ld.sh	r0,r0[0x0]
80004806:	40 30       	lddsp	r0,sp[0xc]
80004808:	00 00       	add	r0,r0
8000480a:	09 74       	ld.ub	r4,--r4
8000480c:	00 00       	add	r0,r0
8000480e:	09 90       	ld.ub	r0,r4[0x1]
80004810:	00 00       	add	r0,r0
80004812:	09 60       	ld.uh	r0,--r4
80004814:	00 00       	add	r0,r0
80004816:	09 48       	ld.w	r8,--r4
80004818:	00 00       	add	r0,r0
8000481a:	09 b0       	ld.ub	r0,r4[0x3]
8000481c:	00 00       	add	r0,r0
8000481e:	08 94       	mov	r4,r4
80004820:	00 00       	add	r0,r0
80004822:	08 a4       	st.w	r4++,r4
80004824:	00 00       	add	r0,r0
80004826:	08 98       	mov	r8,r4
80004828:	00 00       	add	r0,r0
8000482a:	08 90       	mov	r0,r4
8000482c:	00 00       	add	r0,r0
8000482e:	09 a4       	ld.ub	r4,r4[0x2]
80004830:	00 00       	add	r0,r0
80004832:	09 c4       	ld.ub	r4,r4[0x4]
80004834:	80 00       	ld.sh	r0,r0[0x0]
80004836:	40 4a       	lddsp	r10,sp[0x10]
80004838:	80 00       	ld.sh	r0,r0[0x0]
8000483a:	42 2c       	lddsp	r12,sp[0x88]

8000483c <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
8000483c:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
8000483e:	30 09       	mov	r9,0
80004840:	1a d9       	st.w	--sp,r9
80004842:	1a d9       	st.w	--sp,r9
80004844:	1a d9       	st.w	--sp,r9
80004846:	12 98       	mov	r8,r9
80004848:	e0 6a 01 00 	mov	r10,256
8000484c:	48 9b       	lddpc	r11,80004870 <vTaskStartScheduler+0x34>
8000484e:	48 ac       	lddpc	r12,80004874 <vTaskStartScheduler+0x38>
80004850:	f0 1f 00 0a 	mcall	80004878 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80004854:	2f dd       	sub	sp,-12
80004856:	58 1c       	cp.w	r12,1
80004858:	c0 a1       	brne	8000486c <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
8000485a:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
8000485c:	30 19       	mov	r9,1
8000485e:	48 88       	lddpc	r8,8000487c <vTaskStartScheduler+0x40>
80004860:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80004862:	30 09       	mov	r9,0
80004864:	48 78       	lddpc	r8,80004880 <vTaskStartScheduler+0x44>
80004866:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80004868:	f0 1f 00 07 	mcall	80004884 <vTaskStartScheduler+0x48>
8000486c:	d8 02       	popm	pc
8000486e:	00 00       	add	r0,r0
80004870:	80 00       	ld.sh	r0,r0[0x0]
80004872:	5d 08       	ror	r8
80004874:	80 00       	ld.sh	r0,r0[0x0]
80004876:	45 d8       	lddsp	r8,sp[0x174]
80004878:	80 00       	ld.sh	r0,r0[0x0]
8000487a:	46 58       	lddsp	r8,sp[0x194]
8000487c:	00 00       	add	r0,r0
8000487e:	08 98       	mov	r8,r4
80004880:	00 00       	add	r0,r0
80004882:	09 88       	ld.ub	r8,r4[0x0]
80004884:	80 00       	ld.sh	r0,r0[0x0]
80004886:	41 30       	lddsp	r0,sp[0x4c]

80004888 <busy_delay_ms>:
	//portTickType delay;
//};


void busy_delay_ms(int delay){
    for(; delay != 0; delay--){
80004888:	58 0c       	cp.w	r12,0
8000488a:	c0 91       	brne	8000489c <busy_delay_ms+0x14>
8000488c:	5e fc       	retal	r12
        for(int i = 0; i < 2108; i++){
8000488e:	2f f8       	sub	r8,-1
80004890:	e0 48 08 3c 	cp.w	r8,2108
80004894:	cf d1       	brne	8000488e <busy_delay_ms+0x6>
	//portTickType delay;
//};


void busy_delay_ms(int delay){
    for(; delay != 0; delay--){
80004896:	20 1c       	sub	r12,1
80004898:	c0 31       	brne	8000489e <busy_delay_ms+0x16>
8000489a:	5e fc       	retal	r12
8000489c:	30 09       	mov	r9,0
8000489e:	12 98       	mov	r8,r9
800048a0:	cf 7b       	rjmp	8000488e <busy_delay_ms+0x6>

800048a2 <busy_delay_short>:
            asm volatile ("" ::: "memory");
        }
    }
}

void busy_delay_short(void){
800048a2:	30 08       	mov	r8,0
    for(int i = 0; i < 10; i++){
800048a4:	2f f8       	sub	r8,-1
800048a6:	58 a8       	cp.w	r8,10
800048a8:	cf e1       	brne	800048a4 <busy_delay_short+0x2>
        asm volatile ("" ::: "memory");
    }
}
800048aa:	5e fc       	retal	r12

800048ac <response_busy>:
				gpio_set_pin_high(a.pin.response);
        }
    }
}

static void response_busy(void* args){
800048ac:	eb cd 40 e0 	pushm	r5-r7,lr
    struct responseTaskArgs a = *(struct responseTaskArgs*)args;
800048b0:	78 16       	ld.w	r6,r12[0x4]
800048b2:	78 07       	ld.w	r7,r12[0x0]
    while(1){
        if(gpio_pin_is_low(a.pin.test)){
				if(a.pin.test == TEST_C) busy_delay_ms(3);
800048b4:	30 35       	mov	r5,3
}

static void response_busy(void* args){
    struct responseTaskArgs a = *(struct responseTaskArgs*)args;
    while(1){
        if(gpio_pin_is_low(a.pin.test)){
800048b6:	0e 9c       	mov	r12,r7
800048b8:	f0 1f 00 09 	mcall	800048dc <response_busy+0x30>
800048bc:	cf d1       	brne	800048b6 <response_busy+0xa>
				if(a.pin.test == TEST_C) busy_delay_ms(3);
800048be:	59 b7       	cp.w	r7,27
800048c0:	c0 41       	brne	800048c8 <response_busy+0x1c>
800048c2:	0a 9c       	mov	r12,r5
800048c4:	f0 1f 00 07 	mcall	800048e0 <response_busy+0x34>
                gpio_set_pin_low(a.pin.response);
800048c8:	0c 9c       	mov	r12,r6
800048ca:	f0 1f 00 07 	mcall	800048e4 <response_busy+0x38>
                busy_delay_short();
800048ce:	f0 1f 00 07 	mcall	800048e8 <response_busy+0x3c>
				gpio_set_pin_high(a.pin.response);
800048d2:	0c 9c       	mov	r12,r6
800048d4:	f0 1f 00 06 	mcall	800048ec <response_busy+0x40>
800048d8:	ce fb       	rjmp	800048b6 <response_busy+0xa>
800048da:	00 00       	add	r0,r0
800048dc:	80 00       	ld.sh	r0,r0[0x0]
800048de:	21 f4       	sub	r4,31
800048e0:	80 00       	ld.sh	r0,r0[0x0]
800048e2:	48 88       	lddpc	r8,80004900 <init+0x10>
800048e4:	80 00       	ld.sh	r0,r0[0x0]
800048e6:	22 20       	sub	r0,34
800048e8:	80 00       	ld.sh	r0,r0[0x0]
800048ea:	48 a2       	lddpc	r2,80004910 <init+0x20>
800048ec:	80 00       	ld.sh	r0,r0[0x0]
800048ee:	22 0a       	sub	r10,32

800048f0 <init>:
    for(int i = 0; i < 10; i++){
        asm volatile ("" ::: "memory");
    }
}

void init(){
800048f0:	eb cd 40 80 	pushm	r7,lr
	board_init();
800048f4:	f0 1f 00 1a 	mcall	8000495c <init+0x6c>
	
    gpio_configure_pin(TEST_A, GPIO_DIR_INPUT);
800048f8:	30 0b       	mov	r11,0
800048fa:	31 fc       	mov	r12,31
800048fc:	f0 1f 00 19 	mcall	80004960 <init+0x70>
    gpio_configure_pin(TEST_B, GPIO_DIR_INPUT);
80004900:	30 0b       	mov	r11,0
80004902:	31 dc       	mov	r12,29
80004904:	f0 1f 00 17 	mcall	80004960 <init+0x70>
    gpio_configure_pin(TEST_C, GPIO_DIR_INPUT);
80004908:	30 0b       	mov	r11,0
8000490a:	31 bc       	mov	r12,27
8000490c:	f0 1f 00 15 	mcall	80004960 <init+0x70>
    gpio_configure_pin(RESPONSE_A, GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
80004910:	30 3b       	mov	r11,3
80004912:	31 ec       	mov	r12,30
80004914:	f0 1f 00 13 	mcall	80004960 <init+0x70>
    gpio_configure_pin(RESPONSE_B, GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
80004918:	30 3b       	mov	r11,3
8000491a:	31 cc       	mov	r12,28
8000491c:	f0 1f 00 11 	mcall	80004960 <init+0x70>
    gpio_configure_pin(RESPONSE_C, GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
80004920:	30 3b       	mov	r11,3
80004922:	32 0c       	mov	r12,32
80004924:	f0 1f 00 0f 	mcall	80004960 <init+0x70>

	pcl_switch_to_osc(PCL_OSC0, FOSC0, OSC0_STARTUP);
80004928:	30 3a       	mov	r10,3
8000492a:	e0 6b 1b 00 	mov	r11,6912
8000492e:	ea 1b 00 b7 	orh	r11,0xb7
80004932:	30 0c       	mov	r12,0
80004934:	f0 1f 00 0c 	mcall	80004964 <init+0x74>
	
	stdio_usb_init(&CONFIG_USART_IF);
80004938:	fe 7c 1c 00 	mov	r12,-58368
8000493c:	f0 1f 00 0b 	mcall	80004968 <init+0x78>

    #if defined(__GNUC__) && defined(__AVR32__)
	    setbuf(stdout, NULL);
80004940:	48 b7       	lddpc	r7,8000496c <init+0x7c>
80004942:	6e 08       	ld.w	r8,r7[0x0]
80004944:	30 0b       	mov	r11,0
80004946:	70 1c       	ld.w	r12,r8[0x4]
80004948:	f0 1f 00 0a 	mcall	80004970 <init+0x80>
	    setbuf(stdin,  NULL);
8000494c:	6e 08       	ld.w	r8,r7[0x0]
8000494e:	30 0b       	mov	r11,0
80004950:	70 0c       	ld.w	r12,r8[0x0]
80004952:	f0 1f 00 08 	mcall	80004970 <init+0x80>
    #endif
}
80004956:	e3 cd 80 80 	ldm	sp++,r7,pc
8000495a:	00 00       	add	r0,r0
8000495c:	80 00       	ld.sh	r0,r0[0x0]
8000495e:	21 0c       	sub	r12,16
80004960:	80 00       	ld.sh	r0,r0[0x0]
80004962:	21 3c       	sub	r12,19
80004964:	80 00       	ld.sh	r0,r0[0x0]
80004966:	23 ac       	sub	r12,58
80004968:	80 00       	ld.sh	r0,r0[0x0]
8000496a:	3f 58       	mov	r8,-11
8000496c:	00 00       	add	r0,r0
8000496e:	01 ec       	ld.ub	r12,r0[0x6]
80004970:	80 00       	ld.sh	r0,r0[0x0]
80004972:	4e fc       	lddpc	r12,80004b2c <_malloc_r+0xb8>

80004974 <main>:
				gpio_set_pin_high(a.pin.response);
        }
    }
}

int main(){
80004974:	eb cd 40 e0 	pushm	r5-r7,lr
80004978:	20 6d       	sub	sp,24
	init();
8000497a:	f0 1f 00 1f 	mcall	800049f4 <main+0x80>
    xTaskCreate(response_vTask, "", 1024, (&(struct responseTaskArgs){{TEST_A, RESPONSE_A}}), tskIDLE_PRIORITY + 1, NULL);
    xTaskCreate(response_vTask, "", 1024, (&(struct responseTaskArgs){{TEST_B, RESPONSE_B}}), tskIDLE_PRIORITY + 1, NULL);
    xTaskCreate(response_vTask, "", 1024, (&(struct responseTaskArgs){{TEST_C, RESPONSE_C}}), tskIDLE_PRIORITY + 1, NULL);*/


    xTaskCreate(response_busy, "", 1024, (&(struct responseTaskArgs){{TEST_A, RESPONSE_A}}), tskIDLE_PRIORITY + 1, NULL);
8000497e:	31 f8       	mov	r8,31
80004980:	50 08       	stdsp	sp[0x0],r8
80004982:	31 e8       	mov	r8,30
80004984:	50 18       	stdsp	sp[0x4],r8
80004986:	49 d6       	lddpc	r6,800049f8 <main+0x84>
80004988:	49 d5       	lddpc	r5,800049fc <main+0x88>
8000498a:	30 07       	mov	r7,0
8000498c:	1a d7       	st.w	--sp,r7
8000498e:	1a d7       	st.w	--sp,r7
80004990:	1a d7       	st.w	--sp,r7
80004992:	30 18       	mov	r8,1
80004994:	fa c9 ff f4 	sub	r9,sp,-12
80004998:	e0 6a 04 00 	mov	r10,1024
8000499c:	0c 9b       	mov	r11,r6
8000499e:	0a 9c       	mov	r12,r5
800049a0:	f0 1f 00 18 	mcall	80004a00 <main+0x8c>
    xTaskCreate(response_busy, "", 1024, (&(struct responseTaskArgs){{TEST_B, RESPONSE_B}}), tskIDLE_PRIORITY + 1, NULL);
800049a4:	31 d8       	mov	r8,29
800049a6:	50 58       	stdsp	sp[0x14],r8
800049a8:	31 c8       	mov	r8,28
800049aa:	50 68       	stdsp	sp[0x18],r8
800049ac:	1a d7       	st.w	--sp,r7
800049ae:	1a d7       	st.w	--sp,r7
800049b0:	1a d7       	st.w	--sp,r7
800049b2:	30 18       	mov	r8,1
800049b4:	fa c9 ff e0 	sub	r9,sp,-32
800049b8:	e0 6a 04 00 	mov	r10,1024
800049bc:	0c 9b       	mov	r11,r6
800049be:	0a 9c       	mov	r12,r5
800049c0:	f0 1f 00 10 	mcall	80004a00 <main+0x8c>
    xTaskCreate(response_busy, "", 1024, (&(struct responseTaskArgs){{TEST_C, RESPONSE_C}}), tskIDLE_PRIORITY + 1, NULL);
800049c4:	31 b8       	mov	r8,27
800049c6:	50 a8       	stdsp	sp[0x28],r8
800049c8:	32 08       	mov	r8,32
800049ca:	50 b8       	stdsp	sp[0x2c],r8
800049cc:	1a d7       	st.w	--sp,r7
800049ce:	1a d7       	st.w	--sp,r7
800049d0:	1a d7       	st.w	--sp,r7
800049d2:	30 18       	mov	r8,1
800049d4:	fa c9 ff cc 	sub	r9,sp,-52
800049d8:	e0 6a 04 00 	mov	r10,1024
800049dc:	0c 9b       	mov	r11,r6
800049de:	0a 9c       	mov	r12,r5
800049e0:	f0 1f 00 08 	mcall	80004a00 <main+0x8c>
	xTaskCreate(taskFn, "LED1", 1024, (&(struct led_s){LED1_GPIO, LED1_DELAY}), tskIDLE_PRIORITY + 1, NULL);* /
*/


	// Start the scheduler, anything after this will not run.
	vTaskStartScheduler();
800049e4:	2f 7d       	sub	sp,-36
800049e6:	f0 1f 00 08 	mcall	80004a04 <main+0x90>
    
800049ea:	0e 9c       	mov	r12,r7
800049ec:	2f ad       	sub	sp,-24
800049ee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800049f2:	00 00       	add	r0,r0
800049f4:	80 00       	ld.sh	r0,r0[0x0]
800049f6:	48 f0       	lddpc	r0,80004a30 <exit+0x14>
800049f8:	80 00       	ld.sh	r0,r0[0x0]
800049fa:	5d 0c       	ror	r12
800049fc:	80 00       	ld.sh	r0,r0[0x0]
800049fe:	48 ac       	lddpc	r12,80004a24 <exit+0x8>
80004a00:	80 00       	ld.sh	r0,r0[0x0]
80004a02:	46 58       	lddsp	r8,sp[0x194]
80004a04:	80 00       	ld.sh	r0,r0[0x0]
80004a06:	48 3c       	lddpc	r12,80004a10 <atexit+0x8>

80004a08 <atexit>:
80004a08:	d4 01       	pushm	lr
80004a0a:	30 09       	mov	r9,0
80004a0c:	18 9b       	mov	r11,r12
80004a0e:	12 9a       	mov	r10,r9
80004a10:	12 9c       	mov	r12,r9
80004a12:	f0 1f 00 02 	mcall	80004a18 <atexit+0x10>
80004a16:	d8 02       	popm	pc
80004a18:	80 00       	ld.sh	r0,r0[0x0]
80004a1a:	50 dc       	stdsp	sp[0x34],r12

80004a1c <exit>:
80004a1c:	d4 21       	pushm	r4-r7,lr
80004a1e:	30 0b       	mov	r11,0
80004a20:	18 97       	mov	r7,r12
80004a22:	f0 1f 00 06 	mcall	80004a38 <exit+0x1c>
80004a26:	48 68       	lddpc	r8,80004a3c <exit+0x20>
80004a28:	70 0c       	ld.w	r12,r8[0x0]
80004a2a:	78 a8       	ld.w	r8,r12[0x28]
80004a2c:	58 08       	cp.w	r8,0
80004a2e:	c0 20       	breq	80004a32 <exit+0x16>
80004a30:	5d 18       	icall	r8
80004a32:	0e 9c       	mov	r12,r7
80004a34:	f0 1f 00 03 	mcall	80004a40 <exit+0x24>
80004a38:	80 00       	ld.sh	r0,r0[0x0]
80004a3a:	51 88       	stdsp	sp[0x60],r8
80004a3c:	80 00       	ld.sh	r0,r0[0x0]
80004a3e:	5d 14       	icall	r4
80004a40:	80 00       	ld.sh	r0,r0[0x0]
80004a42:	50 62       	stdsp	sp[0x18],r2

80004a44 <free>:
80004a44:	d4 01       	pushm	lr
80004a46:	48 48       	lddpc	r8,80004a54 <free+0x10>
80004a48:	18 9b       	mov	r11,r12
80004a4a:	70 0c       	ld.w	r12,r8[0x0]
80004a4c:	f0 1f 00 03 	mcall	80004a58 <free+0x14>
80004a50:	d8 02       	popm	pc
80004a52:	00 00       	add	r0,r0
80004a54:	00 00       	add	r0,r0
80004a56:	01 ec       	ld.ub	r12,r0[0x6]
80004a58:	80 00       	ld.sh	r0,r0[0x0]
80004a5a:	55 9c       	stdsp	sp[0x164],r12

80004a5c <malloc>:
80004a5c:	d4 01       	pushm	lr
80004a5e:	48 48       	lddpc	r8,80004a6c <malloc+0x10>
80004a60:	18 9b       	mov	r11,r12
80004a62:	70 0c       	ld.w	r12,r8[0x0]
80004a64:	f0 1f 00 03 	mcall	80004a70 <malloc+0x14>
80004a68:	d8 02       	popm	pc
80004a6a:	00 00       	add	r0,r0
80004a6c:	00 00       	add	r0,r0
80004a6e:	01 ec       	ld.ub	r12,r0[0x6]
80004a70:	80 00       	ld.sh	r0,r0[0x0]
80004a72:	4a 74       	lddpc	r4,80004b0c <_malloc_r+0x98>

80004a74 <_malloc_r>:
80004a74:	d4 31       	pushm	r0-r7,lr
80004a76:	f6 c8 ff f5 	sub	r8,r11,-11
80004a7a:	18 95       	mov	r5,r12
80004a7c:	10 97       	mov	r7,r8
80004a7e:	e0 17 ff f8 	andl	r7,0xfff8
80004a82:	59 68       	cp.w	r8,22
80004a84:	f9 b7 08 10 	movls	r7,16
80004a88:	16 37       	cp.w	r7,r11
80004a8a:	5f 38       	srlo	r8
80004a8c:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80004a90:	c0 50       	breq	80004a9a <_malloc_r+0x26>
80004a92:	30 c8       	mov	r8,12
80004a94:	99 38       	st.w	r12[0xc],r8
80004a96:	e0 8f 01 f3 	bral	80004e7c <_malloc_r+0x408>
80004a9a:	f0 1f 00 50 	mcall	80004bd8 <_malloc_r+0x164>
80004a9e:	e0 47 01 f7 	cp.w	r7,503
80004aa2:	e0 8b 00 1c 	brhi	80004ada <_malloc_r+0x66>
80004aa6:	ee 03 16 03 	lsr	r3,r7,0x3
80004aaa:	4c d8       	lddpc	r8,80004bdc <_malloc_r+0x168>
80004aac:	f0 03 00 38 	add	r8,r8,r3<<0x3
80004ab0:	70 36       	ld.w	r6,r8[0xc]
80004ab2:	10 36       	cp.w	r6,r8
80004ab4:	c0 61       	brne	80004ac0 <_malloc_r+0x4c>
80004ab6:	ec c8 ff f8 	sub	r8,r6,-8
80004aba:	70 36       	ld.w	r6,r8[0xc]
80004abc:	10 36       	cp.w	r6,r8
80004abe:	c0 c0       	breq	80004ad6 <_malloc_r+0x62>
80004ac0:	6c 18       	ld.w	r8,r6[0x4]
80004ac2:	e0 18 ff fc 	andl	r8,0xfffc
80004ac6:	6c 3a       	ld.w	r10,r6[0xc]
80004ac8:	ec 08 00 09 	add	r9,r6,r8
80004acc:	0a 9c       	mov	r12,r5
80004ace:	6c 28       	ld.w	r8,r6[0x8]
80004ad0:	95 28       	st.w	r10[0x8],r8
80004ad2:	91 3a       	st.w	r8[0xc],r10
80004ad4:	c4 68       	rjmp	80004b60 <_malloc_r+0xec>
80004ad6:	2f e3       	sub	r3,-2
80004ad8:	c4 c8       	rjmp	80004b70 <_malloc_r+0xfc>
80004ada:	ee 03 16 09 	lsr	r3,r7,0x9
80004ade:	c0 41       	brne	80004ae6 <_malloc_r+0x72>
80004ae0:	ee 03 16 03 	lsr	r3,r7,0x3
80004ae4:	c2 68       	rjmp	80004b30 <_malloc_r+0xbc>
80004ae6:	58 43       	cp.w	r3,4
80004ae8:	e0 8b 00 06 	brhi	80004af4 <_malloc_r+0x80>
80004aec:	ee 03 16 06 	lsr	r3,r7,0x6
80004af0:	2c 83       	sub	r3,-56
80004af2:	c1 f8       	rjmp	80004b30 <_malloc_r+0xbc>
80004af4:	59 43       	cp.w	r3,20
80004af6:	e0 8b 00 04 	brhi	80004afe <_malloc_r+0x8a>
80004afa:	2a 53       	sub	r3,-91
80004afc:	c1 a8       	rjmp	80004b30 <_malloc_r+0xbc>
80004afe:	e0 43 00 54 	cp.w	r3,84
80004b02:	e0 8b 00 06 	brhi	80004b0e <_malloc_r+0x9a>
80004b06:	ee 03 16 0c 	lsr	r3,r7,0xc
80004b0a:	29 23       	sub	r3,-110
80004b0c:	c1 28       	rjmp	80004b30 <_malloc_r+0xbc>
80004b0e:	e0 43 01 54 	cp.w	r3,340
80004b12:	e0 8b 00 06 	brhi	80004b1e <_malloc_r+0xaa>
80004b16:	ee 03 16 0f 	lsr	r3,r7,0xf
80004b1a:	28 93       	sub	r3,-119
80004b1c:	c0 a8       	rjmp	80004b30 <_malloc_r+0xbc>
80004b1e:	e0 43 05 54 	cp.w	r3,1364
80004b22:	e0 88 00 04 	brls	80004b2a <_malloc_r+0xb6>
80004b26:	37 e3       	mov	r3,126
80004b28:	c0 48       	rjmp	80004b30 <_malloc_r+0xbc>
80004b2a:	ee 03 16 12 	lsr	r3,r7,0x12
80004b2e:	28 43       	sub	r3,-124
80004b30:	4a ba       	lddpc	r10,80004bdc <_malloc_r+0x168>
80004b32:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80004b36:	74 36       	ld.w	r6,r10[0xc]
80004b38:	c1 98       	rjmp	80004b6a <_malloc_r+0xf6>
80004b3a:	6c 19       	ld.w	r9,r6[0x4]
80004b3c:	e0 19 ff fc 	andl	r9,0xfffc
80004b40:	f2 07 01 0b 	sub	r11,r9,r7
80004b44:	58 fb       	cp.w	r11,15
80004b46:	e0 8a 00 04 	brle	80004b4e <_malloc_r+0xda>
80004b4a:	20 13       	sub	r3,1
80004b4c:	c1 18       	rjmp	80004b6e <_malloc_r+0xfa>
80004b4e:	6c 38       	ld.w	r8,r6[0xc]
80004b50:	58 0b       	cp.w	r11,0
80004b52:	c0 b5       	brlt	80004b68 <_malloc_r+0xf4>
80004b54:	6c 2a       	ld.w	r10,r6[0x8]
80004b56:	ec 09 00 09 	add	r9,r6,r9
80004b5a:	0a 9c       	mov	r12,r5
80004b5c:	91 2a       	st.w	r8[0x8],r10
80004b5e:	95 38       	st.w	r10[0xc],r8
80004b60:	72 18       	ld.w	r8,r9[0x4]
80004b62:	a1 a8       	sbr	r8,0x0
80004b64:	93 18       	st.w	r9[0x4],r8
80004b66:	cb c8       	rjmp	80004cde <_malloc_r+0x26a>
80004b68:	10 96       	mov	r6,r8
80004b6a:	14 36       	cp.w	r6,r10
80004b6c:	ce 71       	brne	80004b3a <_malloc_r+0xc6>
80004b6e:	2f f3       	sub	r3,-1
80004b70:	49 ba       	lddpc	r10,80004bdc <_malloc_r+0x168>
80004b72:	f4 cc ff f8 	sub	r12,r10,-8
80004b76:	78 26       	ld.w	r6,r12[0x8]
80004b78:	18 36       	cp.w	r6,r12
80004b7a:	c6 e0       	breq	80004c56 <_malloc_r+0x1e2>
80004b7c:	6c 19       	ld.w	r9,r6[0x4]
80004b7e:	e0 19 ff fc 	andl	r9,0xfffc
80004b82:	f2 07 01 08 	sub	r8,r9,r7
80004b86:	58 f8       	cp.w	r8,15
80004b88:	e0 89 00 90 	brgt	80004ca8 <_malloc_r+0x234>
80004b8c:	99 3c       	st.w	r12[0xc],r12
80004b8e:	99 2c       	st.w	r12[0x8],r12
80004b90:	58 08       	cp.w	r8,0
80004b92:	c0 55       	brlt	80004b9c <_malloc_r+0x128>
80004b94:	ec 09 00 09 	add	r9,r6,r9
80004b98:	0a 9c       	mov	r12,r5
80004b9a:	ce 3b       	rjmp	80004b60 <_malloc_r+0xec>
80004b9c:	e0 49 01 ff 	cp.w	r9,511
80004ba0:	e0 8b 00 13 	brhi	80004bc6 <_malloc_r+0x152>
80004ba4:	a3 99       	lsr	r9,0x3
80004ba6:	f4 09 00 38 	add	r8,r10,r9<<0x3
80004baa:	70 2b       	ld.w	r11,r8[0x8]
80004bac:	8d 38       	st.w	r6[0xc],r8
80004bae:	8d 2b       	st.w	r6[0x8],r11
80004bb0:	97 36       	st.w	r11[0xc],r6
80004bb2:	91 26       	st.w	r8[0x8],r6
80004bb4:	a3 49       	asr	r9,0x2
80004bb6:	74 18       	ld.w	r8,r10[0x4]
80004bb8:	30 1b       	mov	r11,1
80004bba:	f6 09 09 49 	lsl	r9,r11,r9
80004bbe:	f1 e9 10 09 	or	r9,r8,r9
80004bc2:	95 19       	st.w	r10[0x4],r9
80004bc4:	c4 98       	rjmp	80004c56 <_malloc_r+0x1e2>
80004bc6:	f2 0a 16 09 	lsr	r10,r9,0x9
80004bca:	58 4a       	cp.w	r10,4
80004bcc:	e0 8b 00 0a 	brhi	80004be0 <_malloc_r+0x16c>
80004bd0:	f2 0a 16 06 	lsr	r10,r9,0x6
80004bd4:	2c 8a       	sub	r10,-56
80004bd6:	c2 38       	rjmp	80004c1c <_malloc_r+0x1a8>
80004bd8:	80 00       	ld.sh	r0,r0[0x0]
80004bda:	42 d0       	lddsp	r0,sp[0xb4]
80004bdc:	00 00       	add	r0,r0
80004bde:	01 f0       	ld.ub	r0,r0[0x7]
80004be0:	59 4a       	cp.w	r10,20
80004be2:	e0 8b 00 04 	brhi	80004bea <_malloc_r+0x176>
80004be6:	2a 5a       	sub	r10,-91
80004be8:	c1 a8       	rjmp	80004c1c <_malloc_r+0x1a8>
80004bea:	e0 4a 00 54 	cp.w	r10,84
80004bee:	e0 8b 00 06 	brhi	80004bfa <_malloc_r+0x186>
80004bf2:	f2 0a 16 0c 	lsr	r10,r9,0xc
80004bf6:	29 2a       	sub	r10,-110
80004bf8:	c1 28       	rjmp	80004c1c <_malloc_r+0x1a8>
80004bfa:	e0 4a 01 54 	cp.w	r10,340
80004bfe:	e0 8b 00 06 	brhi	80004c0a <_malloc_r+0x196>
80004c02:	f2 0a 16 0f 	lsr	r10,r9,0xf
80004c06:	28 9a       	sub	r10,-119
80004c08:	c0 a8       	rjmp	80004c1c <_malloc_r+0x1a8>
80004c0a:	e0 4a 05 54 	cp.w	r10,1364
80004c0e:	e0 88 00 04 	brls	80004c16 <_malloc_r+0x1a2>
80004c12:	37 ea       	mov	r10,126
80004c14:	c0 48       	rjmp	80004c1c <_malloc_r+0x1a8>
80004c16:	f2 0a 16 12 	lsr	r10,r9,0x12
80004c1a:	28 4a       	sub	r10,-124
80004c1c:	4c 8b       	lddpc	r11,80004d3c <_malloc_r+0x2c8>
80004c1e:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80004c22:	68 28       	ld.w	r8,r4[0x8]
80004c24:	08 38       	cp.w	r8,r4
80004c26:	c0 e1       	brne	80004c42 <_malloc_r+0x1ce>
80004c28:	76 19       	ld.w	r9,r11[0x4]
80004c2a:	a3 4a       	asr	r10,0x2
80004c2c:	30 1e       	mov	lr,1
80004c2e:	fc 0a 09 4a 	lsl	r10,lr,r10
80004c32:	f3 ea 10 0a 	or	r10,r9,r10
80004c36:	10 99       	mov	r9,r8
80004c38:	97 1a       	st.w	r11[0x4],r10
80004c3a:	c0 a8       	rjmp	80004c4e <_malloc_r+0x1da>
80004c3c:	70 28       	ld.w	r8,r8[0x8]
80004c3e:	08 38       	cp.w	r8,r4
80004c40:	c0 60       	breq	80004c4c <_malloc_r+0x1d8>
80004c42:	70 1a       	ld.w	r10,r8[0x4]
80004c44:	e0 1a ff fc 	andl	r10,0xfffc
80004c48:	14 39       	cp.w	r9,r10
80004c4a:	cf 93       	brcs	80004c3c <_malloc_r+0x1c8>
80004c4c:	70 39       	ld.w	r9,r8[0xc]
80004c4e:	8d 39       	st.w	r6[0xc],r9
80004c50:	8d 28       	st.w	r6[0x8],r8
80004c52:	91 36       	st.w	r8[0xc],r6
80004c54:	93 26       	st.w	r9[0x8],r6
80004c56:	e6 08 14 02 	asr	r8,r3,0x2
80004c5a:	30 1b       	mov	r11,1
80004c5c:	4b 84       	lddpc	r4,80004d3c <_malloc_r+0x2c8>
80004c5e:	f6 08 09 4b 	lsl	r11,r11,r8
80004c62:	68 18       	ld.w	r8,r4[0x4]
80004c64:	10 3b       	cp.w	r11,r8
80004c66:	e0 8b 00 6f 	brhi	80004d44 <_malloc_r+0x2d0>
80004c6a:	f7 e8 00 09 	and	r9,r11,r8
80004c6e:	c0 b1       	brne	80004c84 <_malloc_r+0x210>
80004c70:	e0 13 ff fc 	andl	r3,0xfffc
80004c74:	a1 7b       	lsl	r11,0x1
80004c76:	2f c3       	sub	r3,-4
80004c78:	c0 38       	rjmp	80004c7e <_malloc_r+0x20a>
80004c7a:	2f c3       	sub	r3,-4
80004c7c:	a1 7b       	lsl	r11,0x1
80004c7e:	f7 e8 00 09 	and	r9,r11,r8
80004c82:	cf c0       	breq	80004c7a <_malloc_r+0x206>
80004c84:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80004c88:	06 92       	mov	r2,r3
80004c8a:	1c 91       	mov	r1,lr
80004c8c:	62 36       	ld.w	r6,r1[0xc]
80004c8e:	c2 e8       	rjmp	80004cea <_malloc_r+0x276>
80004c90:	6c 1a       	ld.w	r10,r6[0x4]
80004c92:	e0 1a ff fc 	andl	r10,0xfffc
80004c96:	f4 07 01 08 	sub	r8,r10,r7
80004c9a:	58 f8       	cp.w	r8,15
80004c9c:	e0 8a 00 15 	brle	80004cc6 <_malloc_r+0x252>
80004ca0:	6c 3a       	ld.w	r10,r6[0xc]
80004ca2:	6c 29       	ld.w	r9,r6[0x8]
80004ca4:	95 29       	st.w	r10[0x8],r9
80004ca6:	93 3a       	st.w	r9[0xc],r10
80004ca8:	0e 99       	mov	r9,r7
80004caa:	ec 07 00 07 	add	r7,r6,r7
80004cae:	a1 a9       	sbr	r9,0x0
80004cb0:	99 37       	st.w	r12[0xc],r7
80004cb2:	99 27       	st.w	r12[0x8],r7
80004cb4:	8d 19       	st.w	r6[0x4],r9
80004cb6:	ee 08 09 08 	st.w	r7[r8],r8
80004cba:	8f 2c       	st.w	r7[0x8],r12
80004cbc:	8f 3c       	st.w	r7[0xc],r12
80004cbe:	a1 a8       	sbr	r8,0x0
80004cc0:	0a 9c       	mov	r12,r5
80004cc2:	8f 18       	st.w	r7[0x4],r8
80004cc4:	c0 d8       	rjmp	80004cde <_malloc_r+0x26a>
80004cc6:	6c 39       	ld.w	r9,r6[0xc]
80004cc8:	58 08       	cp.w	r8,0
80004cca:	c0 f5       	brlt	80004ce8 <_malloc_r+0x274>
80004ccc:	ec 0a 00 0a 	add	r10,r6,r10
80004cd0:	74 18       	ld.w	r8,r10[0x4]
80004cd2:	a1 a8       	sbr	r8,0x0
80004cd4:	0a 9c       	mov	r12,r5
80004cd6:	95 18       	st.w	r10[0x4],r8
80004cd8:	6c 28       	ld.w	r8,r6[0x8]
80004cda:	93 28       	st.w	r9[0x8],r8
80004cdc:	91 39       	st.w	r8[0xc],r9
80004cde:	f0 1f 00 19 	mcall	80004d40 <_malloc_r+0x2cc>
80004ce2:	ec cc ff f8 	sub	r12,r6,-8
80004ce6:	d8 32       	popm	r0-r7,pc
80004ce8:	12 96       	mov	r6,r9
80004cea:	02 36       	cp.w	r6,r1
80004cec:	cd 21       	brne	80004c90 <_malloc_r+0x21c>
80004cee:	2f f2       	sub	r2,-1
80004cf0:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80004cf4:	c0 30       	breq	80004cfa <_malloc_r+0x286>
80004cf6:	2f 81       	sub	r1,-8
80004cf8:	cc ab       	rjmp	80004c8c <_malloc_r+0x218>
80004cfa:	1c 98       	mov	r8,lr
80004cfc:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80004d00:	c0 81       	brne	80004d10 <_malloc_r+0x29c>
80004d02:	68 19       	ld.w	r9,r4[0x4]
80004d04:	f6 08 11 ff 	rsub	r8,r11,-1
80004d08:	f3 e8 00 08 	and	r8,r9,r8
80004d0c:	89 18       	st.w	r4[0x4],r8
80004d0e:	c0 78       	rjmp	80004d1c <_malloc_r+0x2a8>
80004d10:	f0 c9 00 08 	sub	r9,r8,8
80004d14:	20 13       	sub	r3,1
80004d16:	70 08       	ld.w	r8,r8[0x0]
80004d18:	12 38       	cp.w	r8,r9
80004d1a:	cf 10       	breq	80004cfc <_malloc_r+0x288>
80004d1c:	a1 7b       	lsl	r11,0x1
80004d1e:	68 18       	ld.w	r8,r4[0x4]
80004d20:	10 3b       	cp.w	r11,r8
80004d22:	e0 8b 00 11 	brhi	80004d44 <_malloc_r+0x2d0>
80004d26:	58 0b       	cp.w	r11,0
80004d28:	c0 e0       	breq	80004d44 <_malloc_r+0x2d0>
80004d2a:	04 93       	mov	r3,r2
80004d2c:	c0 38       	rjmp	80004d32 <_malloc_r+0x2be>
80004d2e:	2f c3       	sub	r3,-4
80004d30:	a1 7b       	lsl	r11,0x1
80004d32:	f7 e8 00 09 	and	r9,r11,r8
80004d36:	ca 71       	brne	80004c84 <_malloc_r+0x210>
80004d38:	cf bb       	rjmp	80004d2e <_malloc_r+0x2ba>
80004d3a:	00 00       	add	r0,r0
80004d3c:	00 00       	add	r0,r0
80004d3e:	01 f0       	ld.ub	r0,r0[0x7]
80004d40:	80 00       	ld.sh	r0,r0[0x0]
80004d42:	42 dc       	lddsp	r12,sp[0xb4]
80004d44:	68 23       	ld.w	r3,r4[0x8]
80004d46:	66 12       	ld.w	r2,r3[0x4]
80004d48:	e0 12 ff fc 	andl	r2,0xfffc
80004d4c:	0e 32       	cp.w	r2,r7
80004d4e:	5f 39       	srlo	r9
80004d50:	e4 07 01 08 	sub	r8,r2,r7
80004d54:	58 f8       	cp.w	r8,15
80004d56:	5f aa       	srle	r10
80004d58:	f5 e9 10 09 	or	r9,r10,r9
80004d5c:	e0 80 00 a2 	breq	80004ea0 <_malloc_r+0x42c>
80004d60:	4c 88       	lddpc	r8,80004e80 <_malloc_r+0x40c>
80004d62:	70 01       	ld.w	r1,r8[0x0]
80004d64:	4c 88       	lddpc	r8,80004e84 <_malloc_r+0x410>
80004d66:	2f 01       	sub	r1,-16
80004d68:	70 08       	ld.w	r8,r8[0x0]
80004d6a:	0e 01       	add	r1,r7
80004d6c:	5b f8       	cp.w	r8,-1
80004d6e:	c0 40       	breq	80004d76 <_malloc_r+0x302>
80004d70:	28 11       	sub	r1,-127
80004d72:	e0 11 ff 80 	andl	r1,0xff80
80004d76:	02 9b       	mov	r11,r1
80004d78:	0a 9c       	mov	r12,r5
80004d7a:	f0 1f 00 44 	mcall	80004e88 <_malloc_r+0x414>
80004d7e:	18 96       	mov	r6,r12
80004d80:	5b fc       	cp.w	r12,-1
80004d82:	c6 e0       	breq	80004e5e <_malloc_r+0x3ea>
80004d84:	e6 02 00 08 	add	r8,r3,r2
80004d88:	10 3c       	cp.w	r12,r8
80004d8a:	c0 32       	brcc	80004d90 <_malloc_r+0x31c>
80004d8c:	08 33       	cp.w	r3,r4
80004d8e:	c6 81       	brne	80004e5e <_malloc_r+0x3ea>
80004d90:	4b fa       	lddpc	r10,80004e8c <_malloc_r+0x418>
80004d92:	74 09       	ld.w	r9,r10[0x0]
80004d94:	e2 09 00 09 	add	r9,r1,r9
80004d98:	95 09       	st.w	r10[0x0],r9
80004d9a:	10 36       	cp.w	r6,r8
80004d9c:	c0 a1       	brne	80004db0 <_malloc_r+0x33c>
80004d9e:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80004da2:	c0 71       	brne	80004db0 <_malloc_r+0x33c>
80004da4:	e2 02 00 02 	add	r2,r1,r2
80004da8:	68 28       	ld.w	r8,r4[0x8]
80004daa:	a1 a2       	sbr	r2,0x0
80004dac:	91 12       	st.w	r8[0x4],r2
80004dae:	c4 c8       	rjmp	80004e46 <_malloc_r+0x3d2>
80004db0:	4b 5a       	lddpc	r10,80004e84 <_malloc_r+0x410>
80004db2:	74 0b       	ld.w	r11,r10[0x0]
80004db4:	5b fb       	cp.w	r11,-1
80004db6:	c0 31       	brne	80004dbc <_malloc_r+0x348>
80004db8:	95 06       	st.w	r10[0x0],r6
80004dba:	c0 68       	rjmp	80004dc6 <_malloc_r+0x352>
80004dbc:	ec 09 00 09 	add	r9,r6,r9
80004dc0:	4b 3a       	lddpc	r10,80004e8c <_malloc_r+0x418>
80004dc2:	10 19       	sub	r9,r8
80004dc4:	95 09       	st.w	r10[0x0],r9
80004dc6:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80004dca:	f0 09 11 08 	rsub	r9,r8,8
80004dce:	58 08       	cp.w	r8,0
80004dd0:	f2 08 17 10 	movne	r8,r9
80004dd4:	ed d8 e1 06 	addne	r6,r6,r8
80004dd8:	28 08       	sub	r8,-128
80004dda:	ec 01 00 01 	add	r1,r6,r1
80004dde:	0a 9c       	mov	r12,r5
80004de0:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80004de4:	f0 01 01 01 	sub	r1,r8,r1
80004de8:	02 9b       	mov	r11,r1
80004dea:	f0 1f 00 28 	mcall	80004e88 <_malloc_r+0x414>
80004dee:	4a 88       	lddpc	r8,80004e8c <_malloc_r+0x418>
80004df0:	5b fc       	cp.w	r12,-1
80004df2:	ec 0c 17 00 	moveq	r12,r6
80004df6:	f9 b1 00 00 	moveq	r1,0
80004dfa:	70 09       	ld.w	r9,r8[0x0]
80004dfc:	0c 1c       	sub	r12,r6
80004dfe:	89 26       	st.w	r4[0x8],r6
80004e00:	02 0c       	add	r12,r1
80004e02:	12 01       	add	r1,r9
80004e04:	a1 ac       	sbr	r12,0x0
80004e06:	91 01       	st.w	r8[0x0],r1
80004e08:	8d 1c       	st.w	r6[0x4],r12
80004e0a:	08 33       	cp.w	r3,r4
80004e0c:	c1 d0       	breq	80004e46 <_malloc_r+0x3d2>
80004e0e:	58 f2       	cp.w	r2,15
80004e10:	e0 8b 00 05 	brhi	80004e1a <_malloc_r+0x3a6>
80004e14:	30 18       	mov	r8,1
80004e16:	8d 18       	st.w	r6[0x4],r8
80004e18:	c2 38       	rjmp	80004e5e <_malloc_r+0x3ea>
80004e1a:	30 59       	mov	r9,5
80004e1c:	20 c2       	sub	r2,12
80004e1e:	e0 12 ff f8 	andl	r2,0xfff8
80004e22:	e6 02 00 08 	add	r8,r3,r2
80004e26:	91 29       	st.w	r8[0x8],r9
80004e28:	91 19       	st.w	r8[0x4],r9
80004e2a:	66 18       	ld.w	r8,r3[0x4]
80004e2c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004e30:	e5 e8 10 08 	or	r8,r2,r8
80004e34:	87 18       	st.w	r3[0x4],r8
80004e36:	58 f2       	cp.w	r2,15
80004e38:	e0 88 00 07 	brls	80004e46 <_malloc_r+0x3d2>
80004e3c:	e6 cb ff f8 	sub	r11,r3,-8
80004e40:	0a 9c       	mov	r12,r5
80004e42:	f0 1f 00 14 	mcall	80004e90 <_malloc_r+0x41c>
80004e46:	49 49       	lddpc	r9,80004e94 <_malloc_r+0x420>
80004e48:	72 0a       	ld.w	r10,r9[0x0]
80004e4a:	49 18       	lddpc	r8,80004e8c <_malloc_r+0x418>
80004e4c:	70 08       	ld.w	r8,r8[0x0]
80004e4e:	14 38       	cp.w	r8,r10
80004e50:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80004e54:	49 19       	lddpc	r9,80004e98 <_malloc_r+0x424>
80004e56:	72 0a       	ld.w	r10,r9[0x0]
80004e58:	14 38       	cp.w	r8,r10
80004e5a:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80004e5e:	68 28       	ld.w	r8,r4[0x8]
80004e60:	70 18       	ld.w	r8,r8[0x4]
80004e62:	e0 18 ff fc 	andl	r8,0xfffc
80004e66:	0e 38       	cp.w	r8,r7
80004e68:	5f 39       	srlo	r9
80004e6a:	0e 18       	sub	r8,r7
80004e6c:	58 f8       	cp.w	r8,15
80004e6e:	5f aa       	srle	r10
80004e70:	f5 e9 10 09 	or	r9,r10,r9
80004e74:	c1 60       	breq	80004ea0 <_malloc_r+0x42c>
80004e76:	0a 9c       	mov	r12,r5
80004e78:	f0 1f 00 09 	mcall	80004e9c <_malloc_r+0x428>
80004e7c:	d8 3a       	popm	r0-r7,pc,r12=0
80004e7e:	00 00       	add	r0,r0
80004e80:	00 00       	add	r0,r0
80004e82:	09 d0       	ld.ub	r0,r4[0x5]
80004e84:	00 00       	add	r0,r0
80004e86:	05 fc       	ld.ub	r12,r2[0x7]
80004e88:	80 00       	ld.sh	r0,r0[0x0]
80004e8a:	4e d4       	lddpc	r4,8000503c <strncpy+0x4>
80004e8c:	00 00       	add	r0,r0
80004e8e:	09 d4       	ld.ub	r4,r4[0x5]
80004e90:	80 00       	ld.sh	r0,r0[0x0]
80004e92:	55 9c       	stdsp	sp[0x164],r12
80004e94:	00 00       	add	r0,r0
80004e96:	09 cc       	ld.ub	r12,r4[0x4]
80004e98:	00 00       	add	r0,r0
80004e9a:	09 c8       	ld.ub	r8,r4[0x4]
80004e9c:	80 00       	ld.sh	r0,r0[0x0]
80004e9e:	42 dc       	lddsp	r12,sp[0xb4]
80004ea0:	68 26       	ld.w	r6,r4[0x8]
80004ea2:	a1 a8       	sbr	r8,0x0
80004ea4:	0e 99       	mov	r9,r7
80004ea6:	a1 a9       	sbr	r9,0x0
80004ea8:	8d 19       	st.w	r6[0x4],r9
80004eaa:	ec 07 00 07 	add	r7,r6,r7
80004eae:	0a 9c       	mov	r12,r5
80004eb0:	89 27       	st.w	r4[0x8],r7
80004eb2:	8f 18       	st.w	r7[0x4],r8
80004eb4:	f0 1f 00 03 	mcall	80004ec0 <_malloc_r+0x44c>
80004eb8:	ec cc ff f8 	sub	r12,r6,-8
80004ebc:	d8 32       	popm	r0-r7,pc
80004ebe:	00 00       	add	r0,r0
80004ec0:	80 00       	ld.sh	r0,r0[0x0]
80004ec2:	42 dc       	lddsp	r12,sp[0xb4]

80004ec4 <memset>:
80004ec4:	18 98       	mov	r8,r12
80004ec6:	c0 38       	rjmp	80004ecc <memset+0x8>
80004ec8:	10 cb       	st.b	r8++,r11
80004eca:	20 1a       	sub	r10,1
80004ecc:	58 0a       	cp.w	r10,0
80004ece:	cf d1       	brne	80004ec8 <memset+0x4>
80004ed0:	5e fc       	retal	r12
80004ed2:	d7 03       	nop

80004ed4 <_sbrk_r>:
80004ed4:	d4 21       	pushm	r4-r7,lr
80004ed6:	30 08       	mov	r8,0
80004ed8:	18 97       	mov	r7,r12
80004eda:	48 76       	lddpc	r6,80004ef4 <_sbrk_r+0x20>
80004edc:	16 9c       	mov	r12,r11
80004ede:	8d 08       	st.w	r6[0x0],r8
80004ee0:	f0 1f 00 06 	mcall	80004ef8 <_sbrk_r+0x24>
80004ee4:	5b fc       	cp.w	r12,-1
80004ee6:	c0 51       	brne	80004ef0 <_sbrk_r+0x1c>
80004ee8:	6c 08       	ld.w	r8,r6[0x0]
80004eea:	58 08       	cp.w	r8,0
80004eec:	ef f8 1a 03 	st.wne	r7[0xc],r8
80004ef0:	d8 22       	popm	r4-r7,pc
80004ef2:	00 00       	add	r0,r0
80004ef4:	00 00       	add	r0,r0
80004ef6:	0a 2c       	rsub	r12,r5
80004ef8:	80 00       	ld.sh	r0,r0[0x0]
80004efa:	50 9c       	stdsp	sp[0x24],r12

80004efc <setbuf>:
80004efc:	d4 01       	pushm	lr
80004efe:	e0 69 04 00 	mov	r9,1024
80004f02:	58 0b       	cp.w	r11,0
80004f04:	f9 ba 00 02 	moveq	r10,2
80004f08:	f9 ba 01 00 	movne	r10,0
80004f0c:	f0 1f 00 02 	mcall	80004f14 <setbuf+0x18>
80004f10:	d8 02       	popm	pc
80004f12:	00 00       	add	r0,r0
80004f14:	80 00       	ld.sh	r0,r0[0x0]
80004f16:	4f 18       	lddpc	r8,800050d8 <_sbrk+0x3c>

80004f18 <setvbuf>:
80004f18:	d4 31       	pushm	r0-r7,lr
80004f1a:	4b f8       	lddpc	r8,80005014 <setvbuf+0xfc>
80004f1c:	18 97       	mov	r7,r12
80004f1e:	16 96       	mov	r6,r11
80004f20:	14 95       	mov	r5,r10
80004f22:	12 94       	mov	r4,r9
80004f24:	70 0c       	ld.w	r12,r8[0x0]
80004f26:	58 0c       	cp.w	r12,0
80004f28:	c0 60       	breq	80004f34 <setvbuf+0x1c>
80004f2a:	78 68       	ld.w	r8,r12[0x18]
80004f2c:	58 08       	cp.w	r8,0
80004f2e:	c0 31       	brne	80004f34 <setvbuf+0x1c>
80004f30:	f0 1f 00 3a 	mcall	80005018 <setvbuf+0x100>
80004f34:	4b a8       	lddpc	r8,8000501c <setvbuf+0x104>
80004f36:	10 37       	cp.w	r7,r8
80004f38:	c0 51       	brne	80004f42 <setvbuf+0x2a>
80004f3a:	4b 78       	lddpc	r8,80005014 <setvbuf+0xfc>
80004f3c:	70 08       	ld.w	r8,r8[0x0]
80004f3e:	70 07       	ld.w	r7,r8[0x0]
80004f40:	c0 e8       	rjmp	80004f5c <setvbuf+0x44>
80004f42:	4b 88       	lddpc	r8,80005020 <setvbuf+0x108>
80004f44:	10 37       	cp.w	r7,r8
80004f46:	c0 51       	brne	80004f50 <setvbuf+0x38>
80004f48:	4b 38       	lddpc	r8,80005014 <setvbuf+0xfc>
80004f4a:	70 08       	ld.w	r8,r8[0x0]
80004f4c:	70 17       	ld.w	r7,r8[0x4]
80004f4e:	c0 78       	rjmp	80004f5c <setvbuf+0x44>
80004f50:	4b 58       	lddpc	r8,80005024 <setvbuf+0x10c>
80004f52:	10 37       	cp.w	r7,r8
80004f54:	c0 41       	brne	80004f5c <setvbuf+0x44>
80004f56:	4b 08       	lddpc	r8,80005014 <setvbuf+0xfc>
80004f58:	70 08       	ld.w	r8,r8[0x0]
80004f5a:	70 27       	ld.w	r7,r8[0x8]
80004f5c:	58 25       	cp.w	r5,2
80004f5e:	5f b8       	srhi	r8
80004f60:	f1 e4 13 f8 	or	r8,r8,r4>>0x1f
80004f64:	c0 20       	breq	80004f68 <setvbuf+0x50>
80004f66:	dc 3a       	popm	r0-r7,pc,r12=-1
80004f68:	4a b3       	lddpc	r3,80005014 <setvbuf+0xfc>
80004f6a:	0e 9b       	mov	r11,r7
80004f6c:	66 0c       	ld.w	r12,r3[0x0]
80004f6e:	f0 1f 00 2f 	mcall	80005028 <setvbuf+0x110>
80004f72:	30 08       	mov	r8,0
80004f74:	8f 68       	st.w	r7[0x18],r8
80004f76:	8f 18       	st.w	r7[0x4],r8
80004f78:	8e 68       	ld.sh	r8,r7[0xc]
80004f7a:	ed b8 00 07 	bld	r8,0x7
80004f7e:	c0 51       	brne	80004f88 <setvbuf+0x70>
80004f80:	66 0c       	ld.w	r12,r3[0x0]
80004f82:	6e 4b       	ld.w	r11,r7[0x10]
80004f84:	f0 1f 00 2a 	mcall	8000502c <setvbuf+0x114>
80004f88:	8e 68       	ld.sh	r8,r7[0xc]
80004f8a:	e0 18 ff 7c 	andl	r8,0xff7c
80004f8e:	ae 68       	st.h	r7[0xc],r8
80004f90:	58 25       	cp.w	r5,2
80004f92:	c0 31       	brne	80004f98 <setvbuf+0x80>
80004f94:	30 0c       	mov	r12,0
80004f96:	c1 38       	rjmp	80004fbc <setvbuf+0xa4>
80004f98:	58 06       	cp.w	r6,0
80004f9a:	c2 11       	brne	80004fdc <setvbuf+0xc4>
80004f9c:	e0 63 04 00 	mov	r3,1024
80004fa0:	58 04       	cp.w	r4,0
80004fa2:	e6 04 17 00 	moveq	r4,r3
80004fa6:	08 9c       	mov	r12,r4
80004fa8:	f0 1f 00 22 	mcall	80005030 <setvbuf+0x118>
80004fac:	18 96       	mov	r6,r12
80004fae:	c1 41       	brne	80004fd6 <setvbuf+0xbe>
80004fb0:	06 9c       	mov	r12,r3
80004fb2:	f0 1f 00 20 	mcall	80005030 <setvbuf+0x118>
80004fb6:	18 96       	mov	r6,r12
80004fb8:	c0 e1       	brne	80004fd4 <setvbuf+0xbc>
80004fba:	3f fc       	mov	r12,-1
80004fbc:	8e 68       	ld.sh	r8,r7[0xc]
80004fbe:	a1 b8       	sbr	r8,0x1
80004fc0:	ae 68       	st.h	r7[0xc],r8
80004fc2:	ee c8 ff b9 	sub	r8,r7,-71
80004fc6:	8f 48       	st.w	r7[0x10],r8
80004fc8:	8f 08       	st.w	r7[0x0],r8
80004fca:	30 08       	mov	r8,0
80004fcc:	8f 28       	st.w	r7[0x8],r8
80004fce:	30 18       	mov	r8,1
80004fd0:	8f 58       	st.w	r7[0x14],r8
80004fd2:	d8 32       	popm	r0-r7,pc
80004fd4:	06 94       	mov	r4,r3
80004fd6:	8e 68       	ld.sh	r8,r7[0xc]
80004fd8:	a7 b8       	sbr	r8,0x7
80004fda:	ae 68       	st.h	r7[0xc],r8
80004fdc:	58 15       	cp.w	r5,1
80004fde:	c0 71       	brne	80004fec <setvbuf+0xd4>
80004fe0:	8e 68       	ld.sh	r8,r7[0xc]
80004fe2:	a1 a8       	sbr	r8,0x0
80004fe4:	ae 68       	st.h	r7[0xc],r8
80004fe6:	e8 08 11 00 	rsub	r8,r4,0
80004fea:	8f 68       	st.w	r7[0x18],r8
80004fec:	48 a8       	lddpc	r8,80005014 <setvbuf+0xfc>
80004fee:	49 29       	lddpc	r9,80005034 <setvbuf+0x11c>
80004ff0:	70 08       	ld.w	r8,r8[0x0]
80004ff2:	8f 46       	st.w	r7[0x10],r6
80004ff4:	91 a9       	st.w	r8[0x28],r9
80004ff6:	8f 06       	st.w	r7[0x0],r6
80004ff8:	8f 54       	st.w	r7[0x14],r4
80004ffa:	8e 68       	ld.sh	r8,r7[0xc]
80004ffc:	10 9c       	mov	r12,r8
80004ffe:	e2 1c 00 08 	andl	r12,0x8,COH
80005002:	c0 70       	breq	80005010 <setvbuf+0xf8>
80005004:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
80005008:	30 0c       	mov	r12,0
8000500a:	f9 b4 01 00 	movne	r4,0
8000500e:	8f 24       	st.w	r7[0x8],r4
80005010:	d8 32       	popm	r0-r7,pc
80005012:	00 00       	add	r0,r0
80005014:	00 00       	add	r0,r0
80005016:	01 ec       	ld.ub	r12,r0[0x6]
80005018:	80 00       	ld.sh	r0,r0[0x0]
8000501a:	54 44       	stdsp	sp[0x110],r4
8000501c:	80 00       	ld.sh	r0,r0[0x0]
8000501e:	5d 18       	icall	r8
80005020:	80 00       	ld.sh	r0,r0[0x0]
80005022:	5d 38       	musfr	r8
80005024:	80 00       	ld.sh	r0,r0[0x0]
80005026:	5d 58       	*unknown*
80005028:	80 00       	ld.sh	r0,r0[0x0]
8000502a:	52 68       	stdsp	sp[0x98],r8
8000502c:	80 00       	ld.sh	r0,r0[0x0]
8000502e:	55 9c       	stdsp	sp[0x164],r12
80005030:	80 00       	ld.sh	r0,r0[0x0]
80005032:	4a 5c       	lddpc	r12,800050c4 <_sbrk+0x28>
80005034:	80 00       	ld.sh	r0,r0[0x0]
80005036:	53 84       	stdsp	sp[0xe0],r4

80005038 <strncpy>:
80005038:	30 08       	mov	r8,0
8000503a:	10 3a       	cp.w	r10,r8
8000503c:	5e 0c       	reteq	r12
8000503e:	f6 08 07 09 	ld.ub	r9,r11[r8]
80005042:	f8 08 0b 09 	st.b	r12[r8],r9
80005046:	2f f8       	sub	r8,-1
80005048:	58 09       	cp.w	r9,0
8000504a:	cf 81       	brne	8000503a <strncpy+0x2>
8000504c:	10 3a       	cp.w	r10,r8
8000504e:	5e 0c       	reteq	r12
80005050:	f8 08 0b 09 	st.b	r12[r8],r9
80005054:	2f f8       	sub	r8,-1
80005056:	cf bb       	rjmp	8000504c <strncpy+0x14>

80005058 <_init_argv>:
80005058:	30 e8       	mov	r8,14
8000505a:	d6 73       	breakpoint
8000505c:	3f fc       	mov	r12,-1
8000505e:	35 8b       	mov	r11,88
80005060:	5e fc       	retal	r12

80005062 <_exit>:
80005062:	30 d8       	mov	r8,13
80005064:	d6 73       	breakpoint
80005066:	3f fc       	mov	r12,-1
80005068:	35 8b       	mov	r11,88
8000506a:	c0 08       	rjmp	8000506a <_exit+0x8>

8000506c <_close>:
8000506c:	30 28       	mov	r8,2
8000506e:	d6 73       	breakpoint
80005070:	3f fc       	mov	r12,-1
80005072:	35 8b       	mov	r11,88
80005074:	58 0c       	cp.w	r12,0
80005076:	5e 4c       	retge	r12
80005078:	48 2a       	lddpc	r10,80005080 <_close+0x14>
8000507a:	95 0b       	st.w	r10[0x0],r11
8000507c:	5e fc       	retal	r12
8000507e:	00 00       	add	r0,r0
80005080:	00 00       	add	r0,r0
80005082:	0a 2c       	rsub	r12,r5

80005084 <_lseek>:
80005084:	30 58       	mov	r8,5
80005086:	d6 73       	breakpoint
80005088:	3f fc       	mov	r12,-1
8000508a:	35 8b       	mov	r11,88
8000508c:	58 0c       	cp.w	r12,0
8000508e:	5e 4c       	retge	r12
80005090:	48 2a       	lddpc	r10,80005098 <_lseek+0x14>
80005092:	95 0b       	st.w	r10[0x0],r11
80005094:	5e fc       	retal	r12
80005096:	00 00       	add	r0,r0
80005098:	00 00       	add	r0,r0
8000509a:	0a 2c       	rsub	r12,r5

8000509c <_sbrk>:
8000509c:	d4 01       	pushm	lr
8000509e:	48 c8       	lddpc	r8,800050cc <_sbrk+0x30>
800050a0:	70 09       	ld.w	r9,r8[0x0]
800050a2:	58 09       	cp.w	r9,0
800050a4:	c0 31       	brne	800050aa <_sbrk+0xe>
800050a6:	48 b9       	lddpc	r9,800050d0 <_sbrk+0x34>
800050a8:	91 09       	st.w	r8[0x0],r9
800050aa:	48 99       	lddpc	r9,800050cc <_sbrk+0x30>
800050ac:	48 aa       	lddpc	r10,800050d4 <_sbrk+0x38>
800050ae:	72 08       	ld.w	r8,r9[0x0]
800050b0:	f0 0c 00 0c 	add	r12,r8,r12
800050b4:	14 3c       	cp.w	r12,r10
800050b6:	e0 8b 00 04 	brhi	800050be <_sbrk+0x22>
800050ba:	93 0c       	st.w	r9[0x0],r12
800050bc:	c0 68       	rjmp	800050c8 <_sbrk+0x2c>
800050be:	f0 1f 00 07 	mcall	800050d8 <_sbrk+0x3c>
800050c2:	30 c8       	mov	r8,12
800050c4:	99 08       	st.w	r12[0x0],r8
800050c6:	3f f8       	mov	r8,-1
800050c8:	10 9c       	mov	r12,r8
800050ca:	d8 02       	popm	pc
800050cc:	00 00       	add	r0,r0
800050ce:	09 fc       	ld.ub	r12,r4[0x7]
800050d0:	00 00       	add	r0,r0
800050d2:	0a 30       	cp.w	r0,r5
800050d4:	00 00       	add	r0,r0
800050d6:	f0 00       	*unknown*
800050d8:	80 00       	ld.sh	r0,r0[0x0]
800050da:	52 5c       	stdsp	sp[0x94],r12

800050dc <__register_exitproc>:
800050dc:	d4 31       	pushm	r0-r7,lr
800050de:	4a 98       	lddpc	r8,80005180 <__register_exitproc+0xa4>
800050e0:	70 03       	ld.w	r3,r8[0x0]
800050e2:	67 24       	ld.w	r4,r3[0x48]
800050e4:	e6 c8 ff b4 	sub	r8,r3,-76
800050e8:	58 04       	cp.w	r4,0
800050ea:	f0 04 17 00 	moveq	r4,r8
800050ee:	e7 f4 0a 12 	st.weq	r3[0x48],r4
800050f2:	18 97       	mov	r7,r12
800050f4:	16 96       	mov	r6,r11
800050f6:	14 95       	mov	r5,r10
800050f8:	12 92       	mov	r2,r9
800050fa:	68 18       	ld.w	r8,r4[0x4]
800050fc:	59 f8       	cp.w	r8,31
800050fe:	e0 8a 00 0e 	brle	8000511a <__register_exitproc+0x3e>
80005102:	e0 6c 00 8c 	mov	r12,140
80005106:	f0 1f 00 20 	mcall	80005184 <__register_exitproc+0xa8>
8000510a:	18 94       	mov	r4,r12
8000510c:	c3 80       	breq	8000517c <__register_exitproc+0xa0>
8000510e:	67 28       	ld.w	r8,r3[0x48]
80005110:	99 08       	st.w	r12[0x0],r8
80005112:	e7 4c 00 48 	st.w	r3[72],r12
80005116:	30 08       	mov	r8,0
80005118:	99 18       	st.w	r12[0x4],r8
8000511a:	58 07       	cp.w	r7,0
8000511c:	c2 70       	breq	8000516a <__register_exitproc+0x8e>
8000511e:	e8 fc 00 88 	ld.w	r12,r4[136]
80005122:	58 0c       	cp.w	r12,0
80005124:	c0 d1       	brne	8000513e <__register_exitproc+0x62>
80005126:	e0 6c 01 08 	mov	r12,264
8000512a:	f0 1f 00 17 	mcall	80005184 <__register_exitproc+0xa8>
8000512e:	c2 70       	breq	8000517c <__register_exitproc+0xa0>
80005130:	30 08       	mov	r8,0
80005132:	e9 4c 00 88 	st.w	r4[136],r12
80005136:	f9 48 01 04 	st.w	r12[260],r8
8000513a:	f9 48 01 00 	st.w	r12[256],r8
8000513e:	68 18       	ld.w	r8,r4[0x4]
80005140:	f0 c9 ff e0 	sub	r9,r8,-32
80005144:	f8 08 09 25 	st.w	r12[r8<<0x2],r5
80005148:	f8 09 09 22 	st.w	r12[r9<<0x2],r2
8000514c:	30 1a       	mov	r10,1
8000514e:	f8 f9 01 00 	ld.w	r9,r12[256]
80005152:	f4 08 09 48 	lsl	r8,r10,r8
80005156:	10 49       	or	r9,r8
80005158:	f9 49 01 00 	st.w	r12[256],r9
8000515c:	58 27       	cp.w	r7,2
8000515e:	f9 f9 00 41 	ld.weq	r9,r12[0x104]
80005162:	f3 d8 e0 38 	oreq	r8,r9,r8
80005166:	f9 f8 0a 41 	st.weq	r12[0x104],r8
8000516a:	68 18       	ld.w	r8,r4[0x4]
8000516c:	30 0c       	mov	r12,0
8000516e:	f0 c9 ff ff 	sub	r9,r8,-1
80005172:	2f e8       	sub	r8,-2
80005174:	89 19       	st.w	r4[0x4],r9
80005176:	e8 08 09 26 	st.w	r4[r8<<0x2],r6
8000517a:	d8 32       	popm	r0-r7,pc
8000517c:	dc 3a       	popm	r0-r7,pc,r12=-1
8000517e:	00 00       	add	r0,r0
80005180:	80 00       	ld.sh	r0,r0[0x0]
80005182:	5d 14       	icall	r4
80005184:	80 00       	ld.sh	r0,r0[0x0]
80005186:	4a 5c       	lddpc	r12,80005218 <__call_exitprocs+0x90>

80005188 <__call_exitprocs>:
80005188:	d4 31       	pushm	r0-r7,lr
8000518a:	20 3d       	sub	sp,12
8000518c:	4b 28       	lddpc	r8,80005254 <__call_exitprocs+0xcc>
8000518e:	50 2c       	stdsp	sp[0x8],r12
80005190:	70 08       	ld.w	r8,r8[0x0]
80005192:	16 91       	mov	r1,r11
80005194:	50 08       	stdsp	sp[0x0],r8
80005196:	2b 88       	sub	r8,-72
80005198:	50 18       	stdsp	sp[0x4],r8
8000519a:	40 0a       	lddsp	r10,sp[0x0]
8000519c:	40 14       	lddsp	r4,sp[0x4]
8000519e:	75 27       	ld.w	r7,r10[0x48]
800051a0:	c5 58       	rjmp	8000524a <__call_exitprocs+0xc2>
800051a2:	6e 15       	ld.w	r5,r7[0x4]
800051a4:	ee f6 00 88 	ld.w	r6,r7[136]
800051a8:	ea c2 ff ff 	sub	r2,r5,-1
800051ac:	20 15       	sub	r5,1
800051ae:	ee 02 00 22 	add	r2,r7,r2<<0x2
800051b2:	ec 05 00 23 	add	r3,r6,r5<<0x2
800051b6:	c3 58       	rjmp	80005220 <__call_exitprocs+0x98>
800051b8:	58 01       	cp.w	r1,0
800051ba:	c0 70       	breq	800051c8 <__call_exitprocs+0x40>
800051bc:	58 06       	cp.w	r6,0
800051be:	c2 e0       	breq	8000521a <__call_exitprocs+0x92>
800051c0:	e6 f8 00 80 	ld.w	r8,r3[128]
800051c4:	02 38       	cp.w	r8,r1
800051c6:	c2 a1       	brne	8000521a <__call_exitprocs+0x92>
800051c8:	6e 19       	ld.w	r9,r7[0x4]
800051ca:	64 08       	ld.w	r8,r2[0x0]
800051cc:	20 19       	sub	r9,1
800051ce:	12 35       	cp.w	r5,r9
800051d0:	ef f5 0a 01 	st.weq	r7[0x4],r5
800051d4:	f9 b9 01 00 	movne	r9,0
800051d8:	e5 f9 1a 00 	st.wne	r2[0x0],r9
800051dc:	58 08       	cp.w	r8,0
800051de:	c1 e0       	breq	8000521a <__call_exitprocs+0x92>
800051e0:	6e 10       	ld.w	r0,r7[0x4]
800051e2:	58 06       	cp.w	r6,0
800051e4:	c0 90       	breq	800051f6 <__call_exitprocs+0x6e>
800051e6:	30 1a       	mov	r10,1
800051e8:	f4 05 09 49 	lsl	r9,r10,r5
800051ec:	ec fa 01 00 	ld.w	r10,r6[256]
800051f0:	f3 ea 00 0a 	and	r10,r9,r10
800051f4:	c0 31       	brne	800051fa <__call_exitprocs+0x72>
800051f6:	5d 18       	icall	r8
800051f8:	c0 b8       	rjmp	8000520e <__call_exitprocs+0x86>
800051fa:	ec fa 01 04 	ld.w	r10,r6[260]
800051fe:	66 0b       	ld.w	r11,r3[0x0]
80005200:	14 69       	and	r9,r10
80005202:	c0 41       	brne	8000520a <__call_exitprocs+0x82>
80005204:	40 2c       	lddsp	r12,sp[0x8]
80005206:	5d 18       	icall	r8
80005208:	c0 38       	rjmp	8000520e <__call_exitprocs+0x86>
8000520a:	16 9c       	mov	r12,r11
8000520c:	5d 18       	icall	r8
8000520e:	6e 18       	ld.w	r8,r7[0x4]
80005210:	10 30       	cp.w	r0,r8
80005212:	cc 41       	brne	8000519a <__call_exitprocs+0x12>
80005214:	68 08       	ld.w	r8,r4[0x0]
80005216:	0e 38       	cp.w	r8,r7
80005218:	cc 11       	brne	8000519a <__call_exitprocs+0x12>
8000521a:	20 15       	sub	r5,1
8000521c:	20 43       	sub	r3,4
8000521e:	20 42       	sub	r2,4
80005220:	58 05       	cp.w	r5,0
80005222:	cc b4       	brge	800051b8 <__call_exitprocs+0x30>
80005224:	6e 18       	ld.w	r8,r7[0x4]
80005226:	58 08       	cp.w	r8,0
80005228:	c0 f1       	brne	80005246 <__call_exitprocs+0xbe>
8000522a:	6e 08       	ld.w	r8,r7[0x0]
8000522c:	58 08       	cp.w	r8,0
8000522e:	c0 c0       	breq	80005246 <__call_exitprocs+0xbe>
80005230:	89 08       	st.w	r4[0x0],r8
80005232:	58 06       	cp.w	r6,0
80005234:	c0 40       	breq	8000523c <__call_exitprocs+0xb4>
80005236:	0c 9c       	mov	r12,r6
80005238:	f0 1f 00 08 	mcall	80005258 <__call_exitprocs+0xd0>
8000523c:	0e 9c       	mov	r12,r7
8000523e:	f0 1f 00 07 	mcall	80005258 <__call_exitprocs+0xd0>
80005242:	68 07       	ld.w	r7,r4[0x0]
80005244:	c0 38       	rjmp	8000524a <__call_exitprocs+0xc2>
80005246:	0e 94       	mov	r4,r7
80005248:	6e 07       	ld.w	r7,r7[0x0]
8000524a:	58 07       	cp.w	r7,0
8000524c:	ca b1       	brne	800051a2 <__call_exitprocs+0x1a>
8000524e:	2f dd       	sub	sp,-12
80005250:	d8 32       	popm	r0-r7,pc
80005252:	00 00       	add	r0,r0
80005254:	80 00       	ld.sh	r0,r0[0x0]
80005256:	5d 14       	icall	r4
80005258:	80 00       	ld.sh	r0,r0[0x0]
8000525a:	4a 44       	lddpc	r4,800052e8 <_fflush_r+0x80>

8000525c <__errno>:
8000525c:	48 28       	lddpc	r8,80005264 <__errno+0x8>
8000525e:	70 0c       	ld.w	r12,r8[0x0]
80005260:	2f 4c       	sub	r12,-12
80005262:	5e fc       	retal	r12
80005264:	00 00       	add	r0,r0
80005266:	01 ec       	ld.ub	r12,r0[0x6]

80005268 <_fflush_r>:
80005268:	d4 21       	pushm	r4-r7,lr
8000526a:	16 97       	mov	r7,r11
8000526c:	18 96       	mov	r6,r12
8000526e:	76 48       	ld.w	r8,r11[0x10]
80005270:	58 08       	cp.w	r8,0
80005272:	c7 d0       	breq	8000536c <_fflush_r+0x104>
80005274:	58 0c       	cp.w	r12,0
80005276:	c0 60       	breq	80005282 <_fflush_r+0x1a>
80005278:	78 68       	ld.w	r8,r12[0x18]
8000527a:	58 08       	cp.w	r8,0
8000527c:	c0 31       	brne	80005282 <_fflush_r+0x1a>
8000527e:	f0 1f 00 3d 	mcall	80005370 <_fflush_r+0x108>
80005282:	4b d8       	lddpc	r8,80005374 <_fflush_r+0x10c>
80005284:	10 37       	cp.w	r7,r8
80005286:	c0 31       	brne	8000528c <_fflush_r+0x24>
80005288:	6c 07       	ld.w	r7,r6[0x0]
8000528a:	c0 a8       	rjmp	8000529e <_fflush_r+0x36>
8000528c:	4b b8       	lddpc	r8,80005378 <_fflush_r+0x110>
8000528e:	10 37       	cp.w	r7,r8
80005290:	c0 31       	brne	80005296 <_fflush_r+0x2e>
80005292:	6c 17       	ld.w	r7,r6[0x4]
80005294:	c0 58       	rjmp	8000529e <_fflush_r+0x36>
80005296:	4b a8       	lddpc	r8,8000537c <_fflush_r+0x114>
80005298:	10 37       	cp.w	r7,r8
8000529a:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000529e:	8e 6a       	ld.sh	r10,r7[0xc]
800052a0:	14 98       	mov	r8,r10
800052a2:	ed ba 00 03 	bld	r10,0x3
800052a6:	c4 20       	breq	8000532a <_fflush_r+0xc2>
800052a8:	ab ba       	sbr	r10,0xb
800052aa:	ae 6a       	st.h	r7[0xc],r10
800052ac:	6e 18       	ld.w	r8,r7[0x4]
800052ae:	58 08       	cp.w	r8,0
800052b0:	e0 89 00 06 	brgt	800052bc <_fflush_r+0x54>
800052b4:	6f 08       	ld.w	r8,r7[0x40]
800052b6:	58 08       	cp.w	r8,0
800052b8:	e0 8a 00 5a 	brle	8000536c <_fflush_r+0x104>
800052bc:	6e b8       	ld.w	r8,r7[0x2c]
800052be:	58 08       	cp.w	r8,0
800052c0:	c5 60       	breq	8000536c <_fflush_r+0x104>
800052c2:	e2 1a 10 00 	andl	r10,0x1000,COH
800052c6:	c0 30       	breq	800052cc <_fflush_r+0x64>
800052c8:	6f 55       	ld.w	r5,r7[0x54]
800052ca:	c0 f8       	rjmp	800052e8 <_fflush_r+0x80>
800052cc:	30 19       	mov	r9,1
800052ce:	6e 8b       	ld.w	r11,r7[0x20]
800052d0:	0c 9c       	mov	r12,r6
800052d2:	5d 18       	icall	r8
800052d4:	18 95       	mov	r5,r12
800052d6:	5b fc       	cp.w	r12,-1
800052d8:	c0 81       	brne	800052e8 <_fflush_r+0x80>
800052da:	6c 38       	ld.w	r8,r6[0xc]
800052dc:	59 d8       	cp.w	r8,29
800052de:	c4 70       	breq	8000536c <_fflush_r+0x104>
800052e0:	8e 68       	ld.sh	r8,r7[0xc]
800052e2:	a7 a8       	sbr	r8,0x6
800052e4:	ae 68       	st.h	r7[0xc],r8
800052e6:	d8 22       	popm	r4-r7,pc
800052e8:	8e 68       	ld.sh	r8,r7[0xc]
800052ea:	ed b8 00 02 	bld	r8,0x2
800052ee:	c0 91       	brne	80005300 <_fflush_r+0x98>
800052f0:	6e 18       	ld.w	r8,r7[0x4]
800052f2:	10 15       	sub	r5,r8
800052f4:	6e d8       	ld.w	r8,r7[0x34]
800052f6:	58 08       	cp.w	r8,0
800052f8:	ef f8 10 10 	ld.wne	r8,r7[0x40]
800052fc:	eb d8 e1 15 	subne	r5,r5,r8
80005300:	6e b8       	ld.w	r8,r7[0x2c]
80005302:	0c 9c       	mov	r12,r6
80005304:	30 09       	mov	r9,0
80005306:	0a 9a       	mov	r10,r5
80005308:	6e 8b       	ld.w	r11,r7[0x20]
8000530a:	5d 18       	icall	r8
8000530c:	8e 68       	ld.sh	r8,r7[0xc]
8000530e:	0a 3c       	cp.w	r12,r5
80005310:	c2 61       	brne	8000535c <_fflush_r+0xf4>
80005312:	ab d8       	cbr	r8,0xb
80005314:	30 0c       	mov	r12,0
80005316:	6e 49       	ld.w	r9,r7[0x10]
80005318:	ae 68       	st.h	r7[0xc],r8
8000531a:	8f 1c       	st.w	r7[0x4],r12
8000531c:	8f 09       	st.w	r7[0x0],r9
8000531e:	ed b8 00 0c 	bld	r8,0xc
80005322:	c2 51       	brne	8000536c <_fflush_r+0x104>
80005324:	ef 45 00 54 	st.w	r7[84],r5
80005328:	d8 22       	popm	r4-r7,pc
8000532a:	6e 45       	ld.w	r5,r7[0x10]
8000532c:	58 05       	cp.w	r5,0
8000532e:	c1 f0       	breq	8000536c <_fflush_r+0x104>
80005330:	6e 04       	ld.w	r4,r7[0x0]
80005332:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
80005336:	8f 05       	st.w	r7[0x0],r5
80005338:	f9 b8 01 00 	movne	r8,0
8000533c:	ef f8 00 05 	ld.weq	r8,r7[0x14]
80005340:	0a 14       	sub	r4,r5
80005342:	8f 28       	st.w	r7[0x8],r8
80005344:	c1 18       	rjmp	80005366 <_fflush_r+0xfe>
80005346:	08 99       	mov	r9,r4
80005348:	0a 9a       	mov	r10,r5
8000534a:	6e a8       	ld.w	r8,r7[0x28]
8000534c:	6e 8b       	ld.w	r11,r7[0x20]
8000534e:	0c 9c       	mov	r12,r6
80005350:	5d 18       	icall	r8
80005352:	18 14       	sub	r4,r12
80005354:	58 0c       	cp.w	r12,0
80005356:	e0 89 00 07 	brgt	80005364 <_fflush_r+0xfc>
8000535a:	8e 68       	ld.sh	r8,r7[0xc]
8000535c:	a7 a8       	sbr	r8,0x6
8000535e:	3f fc       	mov	r12,-1
80005360:	ae 68       	st.h	r7[0xc],r8
80005362:	d8 22       	popm	r4-r7,pc
80005364:	18 05       	add	r5,r12
80005366:	58 04       	cp.w	r4,0
80005368:	fe 99 ff ef 	brgt	80005346 <_fflush_r+0xde>
8000536c:	d8 2a       	popm	r4-r7,pc,r12=0
8000536e:	00 00       	add	r0,r0
80005370:	80 00       	ld.sh	r0,r0[0x0]
80005372:	54 44       	stdsp	sp[0x110],r4
80005374:	80 00       	ld.sh	r0,r0[0x0]
80005376:	5d 18       	icall	r8
80005378:	80 00       	ld.sh	r0,r0[0x0]
8000537a:	5d 38       	musfr	r8
8000537c:	80 00       	ld.sh	r0,r0[0x0]
8000537e:	5d 58       	*unknown*

80005380 <__sfp_lock_acquire>:
80005380:	5e fc       	retal	r12

80005382 <__sfp_lock_release>:
80005382:	5e fc       	retal	r12

80005384 <_cleanup_r>:
80005384:	d4 01       	pushm	lr
80005386:	48 3b       	lddpc	r11,80005390 <_cleanup_r+0xc>
80005388:	f0 1f 00 03 	mcall	80005394 <_cleanup_r+0x10>
8000538c:	d8 02       	popm	pc
8000538e:	00 00       	add	r0,r0
80005390:	80 00       	ld.sh	r0,r0[0x0]
80005392:	59 48       	cp.w	r8,20
80005394:	80 00       	ld.sh	r0,r0[0x0]
80005396:	57 3c       	stdsp	sp[0x1cc],r12

80005398 <__sfmoreglue>:
80005398:	d4 21       	pushm	r4-r7,lr
8000539a:	16 95       	mov	r5,r11
8000539c:	f6 06 10 5c 	mul	r6,r11,92
800053a0:	ec cb ff f4 	sub	r11,r6,-12
800053a4:	f0 1f 00 07 	mcall	800053c0 <__sfmoreglue+0x28>
800053a8:	18 97       	mov	r7,r12
800053aa:	c0 90       	breq	800053bc <__sfmoreglue+0x24>
800053ac:	99 15       	st.w	r12[0x4],r5
800053ae:	30 0b       	mov	r11,0
800053b0:	2f 4c       	sub	r12,-12
800053b2:	0c 9a       	mov	r10,r6
800053b4:	8f 2c       	st.w	r7[0x8],r12
800053b6:	8f 0b       	st.w	r7[0x0],r11
800053b8:	f0 1f 00 03 	mcall	800053c4 <__sfmoreglue+0x2c>
800053bc:	0e 9c       	mov	r12,r7
800053be:	d8 22       	popm	r4-r7,pc
800053c0:	80 00       	ld.sh	r0,r0[0x0]
800053c2:	4a 74       	lddpc	r4,8000545c <__sinit+0x18>
800053c4:	80 00       	ld.sh	r0,r0[0x0]
800053c6:	4e c4       	lddpc	r4,80005574 <_malloc_trim_r+0x80>

800053c8 <__sfp>:
800053c8:	d4 21       	pushm	r4-r7,lr
800053ca:	49 c8       	lddpc	r8,80005438 <__sfp+0x70>
800053cc:	18 96       	mov	r6,r12
800053ce:	70 07       	ld.w	r7,r8[0x0]
800053d0:	6e 68       	ld.w	r8,r7[0x18]
800053d2:	58 08       	cp.w	r8,0
800053d4:	c0 41       	brne	800053dc <__sfp+0x14>
800053d6:	0e 9c       	mov	r12,r7
800053d8:	f0 1f 00 19 	mcall	8000543c <__sfp+0x74>
800053dc:	ee c7 ff 28 	sub	r7,r7,-216
800053e0:	30 05       	mov	r5,0
800053e2:	6e 2c       	ld.w	r12,r7[0x8]
800053e4:	6e 18       	ld.w	r8,r7[0x4]
800053e6:	c0 68       	rjmp	800053f2 <__sfp+0x2a>
800053e8:	98 69       	ld.sh	r9,r12[0xc]
800053ea:	ea 09 19 00 	cp.h	r9,r5
800053ee:	c1 20       	breq	80005412 <__sfp+0x4a>
800053f0:	2a 4c       	sub	r12,-92
800053f2:	20 18       	sub	r8,1
800053f4:	cf a7       	brpl	800053e8 <__sfp+0x20>
800053f6:	6e 08       	ld.w	r8,r7[0x0]
800053f8:	58 08       	cp.w	r8,0
800053fa:	c0 71       	brne	80005408 <__sfp+0x40>
800053fc:	30 4b       	mov	r11,4
800053fe:	0c 9c       	mov	r12,r6
80005400:	f0 1f 00 10 	mcall	80005440 <__sfp+0x78>
80005404:	8f 0c       	st.w	r7[0x0],r12
80005406:	c0 30       	breq	8000540c <__sfp+0x44>
80005408:	6e 07       	ld.w	r7,r7[0x0]
8000540a:	ce cb       	rjmp	800053e2 <__sfp+0x1a>
8000540c:	30 c8       	mov	r8,12
8000540e:	8d 38       	st.w	r6[0xc],r8
80005410:	d8 22       	popm	r4-r7,pc
80005412:	30 08       	mov	r8,0
80005414:	f9 48 00 4c 	st.w	r12[76],r8
80005418:	99 08       	st.w	r12[0x0],r8
8000541a:	99 28       	st.w	r12[0x8],r8
8000541c:	99 18       	st.w	r12[0x4],r8
8000541e:	99 48       	st.w	r12[0x10],r8
80005420:	99 58       	st.w	r12[0x14],r8
80005422:	99 68       	st.w	r12[0x18],r8
80005424:	99 d8       	st.w	r12[0x34],r8
80005426:	99 e8       	st.w	r12[0x38],r8
80005428:	f9 48 00 48 	st.w	r12[72],r8
8000542c:	3f f8       	mov	r8,-1
8000542e:	b8 78       	st.h	r12[0xe],r8
80005430:	30 18       	mov	r8,1
80005432:	b8 68       	st.h	r12[0xc],r8
80005434:	d8 22       	popm	r4-r7,pc
80005436:	00 00       	add	r0,r0
80005438:	80 00       	ld.sh	r0,r0[0x0]
8000543a:	5d 14       	icall	r4
8000543c:	80 00       	ld.sh	r0,r0[0x0]
8000543e:	54 44       	stdsp	sp[0x110],r4
80005440:	80 00       	ld.sh	r0,r0[0x0]
80005442:	53 98       	stdsp	sp[0xe4],r8

80005444 <__sinit>:
80005444:	d4 21       	pushm	r4-r7,lr
80005446:	18 96       	mov	r6,r12
80005448:	78 67       	ld.w	r7,r12[0x18]
8000544a:	58 07       	cp.w	r7,0
8000544c:	c4 71       	brne	800054da <__sinit+0x96>
8000544e:	4a 48       	lddpc	r8,800054dc <__sinit+0x98>
80005450:	30 15       	mov	r5,1
80005452:	99 a8       	st.w	r12[0x28],r8
80005454:	f9 47 00 d8 	st.w	r12[216],r7
80005458:	f9 47 00 dc 	st.w	r12[220],r7
8000545c:	f9 47 00 e0 	st.w	r12[224],r7
80005460:	99 65       	st.w	r12[0x18],r5
80005462:	f0 1f 00 20 	mcall	800054e0 <__sinit+0x9c>
80005466:	8d 0c       	st.w	r6[0x0],r12
80005468:	0c 9c       	mov	r12,r6
8000546a:	f0 1f 00 1e 	mcall	800054e0 <__sinit+0x9c>
8000546e:	8d 1c       	st.w	r6[0x4],r12
80005470:	0c 9c       	mov	r12,r6
80005472:	f0 1f 00 1c 	mcall	800054e0 <__sinit+0x9c>
80005476:	6c 09       	ld.w	r9,r6[0x0]
80005478:	30 48       	mov	r8,4
8000547a:	93 07       	st.w	r9[0x0],r7
8000547c:	b2 68       	st.h	r9[0xc],r8
8000547e:	93 17       	st.w	r9[0x4],r7
80005480:	93 27       	st.w	r9[0x8],r7
80005482:	6c 18       	ld.w	r8,r6[0x4]
80005484:	b2 77       	st.h	r9[0xe],r7
80005486:	93 47       	st.w	r9[0x10],r7
80005488:	93 57       	st.w	r9[0x14],r7
8000548a:	93 67       	st.w	r9[0x18],r7
8000548c:	93 89       	st.w	r9[0x20],r9
8000548e:	91 07       	st.w	r8[0x0],r7
80005490:	91 17       	st.w	r8[0x4],r7
80005492:	91 27       	st.w	r8[0x8],r7
80005494:	49 4e       	lddpc	lr,800054e4 <__sinit+0xa0>
80005496:	49 5b       	lddpc	r11,800054e8 <__sinit+0xa4>
80005498:	93 9e       	st.w	r9[0x24],lr
8000549a:	93 ab       	st.w	r9[0x28],r11
8000549c:	49 4a       	lddpc	r10,800054ec <__sinit+0xa8>
8000549e:	49 54       	lddpc	r4,800054f0 <__sinit+0xac>
800054a0:	93 ba       	st.w	r9[0x2c],r10
800054a2:	93 c4       	st.w	r9[0x30],r4
800054a4:	30 99       	mov	r9,9
800054a6:	b0 69       	st.h	r8[0xc],r9
800054a8:	b0 75       	st.h	r8[0xe],r5
800054aa:	91 c4       	st.w	r8[0x30],r4
800054ac:	91 47       	st.w	r8[0x10],r7
800054ae:	91 57       	st.w	r8[0x14],r7
800054b0:	91 67       	st.w	r8[0x18],r7
800054b2:	91 88       	st.w	r8[0x20],r8
800054b4:	91 9e       	st.w	r8[0x24],lr
800054b6:	91 ab       	st.w	r8[0x28],r11
800054b8:	91 ba       	st.w	r8[0x2c],r10
800054ba:	8d 2c       	st.w	r6[0x8],r12
800054bc:	31 28       	mov	r8,18
800054be:	99 07       	st.w	r12[0x0],r7
800054c0:	b8 68       	st.h	r12[0xc],r8
800054c2:	99 17       	st.w	r12[0x4],r7
800054c4:	99 27       	st.w	r12[0x8],r7
800054c6:	30 28       	mov	r8,2
800054c8:	b8 78       	st.h	r12[0xe],r8
800054ca:	99 c4       	st.w	r12[0x30],r4
800054cc:	99 67       	st.w	r12[0x18],r7
800054ce:	99 9e       	st.w	r12[0x24],lr
800054d0:	99 ab       	st.w	r12[0x28],r11
800054d2:	99 ba       	st.w	r12[0x2c],r10
800054d4:	99 47       	st.w	r12[0x10],r7
800054d6:	99 57       	st.w	r12[0x14],r7
800054d8:	99 8c       	st.w	r12[0x20],r12
800054da:	d8 22       	popm	r4-r7,pc
800054dc:	80 00       	ld.sh	r0,r0[0x0]
800054de:	53 84       	stdsp	sp[0xe0],r4
800054e0:	80 00       	ld.sh	r0,r0[0x0]
800054e2:	53 c8       	stdsp	sp[0xf0],r8
800054e4:	80 00       	ld.sh	r0,r0[0x0]
800054e6:	58 00       	cp.w	r0,0
800054e8:	80 00       	ld.sh	r0,r0[0x0]
800054ea:	57 c8       	stdsp	sp[0x1f0],r8
800054ec:	80 00       	ld.sh	r0,r0[0x0]
800054ee:	57 a0       	stdsp	sp[0x1e8],r0
800054f0:	80 00       	ld.sh	r0,r0[0x0]
800054f2:	57 90       	stdsp	sp[0x1e4],r0

800054f4 <_malloc_trim_r>:
800054f4:	d4 21       	pushm	r4-r7,lr
800054f6:	16 95       	mov	r5,r11
800054f8:	18 97       	mov	r7,r12
800054fa:	f0 1f 00 23 	mcall	80005584 <_malloc_trim_r+0x90>
800054fe:	4a 34       	lddpc	r4,80005588 <_malloc_trim_r+0x94>
80005500:	68 28       	ld.w	r8,r4[0x8]
80005502:	70 16       	ld.w	r6,r8[0x4]
80005504:	e0 16 ff fc 	andl	r6,0xfffc
80005508:	ec c8 ff 91 	sub	r8,r6,-111
8000550c:	f0 05 01 05 	sub	r5,r8,r5
80005510:	e0 15 ff 80 	andl	r5,0xff80
80005514:	ea c5 00 80 	sub	r5,r5,128
80005518:	e0 45 00 7f 	cp.w	r5,127
8000551c:	e0 8a 00 23 	brle	80005562 <_malloc_trim_r+0x6e>
80005520:	30 0b       	mov	r11,0
80005522:	0e 9c       	mov	r12,r7
80005524:	f0 1f 00 1a 	mcall	8000558c <_malloc_trim_r+0x98>
80005528:	68 28       	ld.w	r8,r4[0x8]
8000552a:	0c 08       	add	r8,r6
8000552c:	10 3c       	cp.w	r12,r8
8000552e:	c1 a1       	brne	80005562 <_malloc_trim_r+0x6e>
80005530:	ea 0b 11 00 	rsub	r11,r5,0
80005534:	0e 9c       	mov	r12,r7
80005536:	f0 1f 00 16 	mcall	8000558c <_malloc_trim_r+0x98>
8000553a:	5b fc       	cp.w	r12,-1
8000553c:	c1 71       	brne	8000556a <_malloc_trim_r+0x76>
8000553e:	30 0b       	mov	r11,0
80005540:	0e 9c       	mov	r12,r7
80005542:	f0 1f 00 13 	mcall	8000558c <_malloc_trim_r+0x98>
80005546:	68 28       	ld.w	r8,r4[0x8]
80005548:	f8 08 01 09 	sub	r9,r12,r8
8000554c:	58 f9       	cp.w	r9,15
8000554e:	e0 8a 00 0a 	brle	80005562 <_malloc_trim_r+0x6e>
80005552:	a1 a9       	sbr	r9,0x0
80005554:	91 19       	st.w	r8[0x4],r9
80005556:	48 f8       	lddpc	r8,80005590 <_malloc_trim_r+0x9c>
80005558:	70 09       	ld.w	r9,r8[0x0]
8000555a:	48 f8       	lddpc	r8,80005594 <_malloc_trim_r+0xa0>
8000555c:	f8 09 01 09 	sub	r9,r12,r9
80005560:	91 09       	st.w	r8[0x0],r9
80005562:	0e 9c       	mov	r12,r7
80005564:	f0 1f 00 0d 	mcall	80005598 <_malloc_trim_r+0xa4>
80005568:	d8 2a       	popm	r4-r7,pc,r12=0
8000556a:	68 28       	ld.w	r8,r4[0x8]
8000556c:	0a 16       	sub	r6,r5
8000556e:	a1 a6       	sbr	r6,0x0
80005570:	91 16       	st.w	r8[0x4],r6
80005572:	48 98       	lddpc	r8,80005594 <_malloc_trim_r+0xa0>
80005574:	70 09       	ld.w	r9,r8[0x0]
80005576:	0a 19       	sub	r9,r5
80005578:	0e 9c       	mov	r12,r7
8000557a:	91 09       	st.w	r8[0x0],r9
8000557c:	f0 1f 00 07 	mcall	80005598 <_malloc_trim_r+0xa4>
80005580:	da 2a       	popm	r4-r7,pc,r12=1
80005582:	00 00       	add	r0,r0
80005584:	80 00       	ld.sh	r0,r0[0x0]
80005586:	42 d0       	lddsp	r0,sp[0xb4]
80005588:	00 00       	add	r0,r0
8000558a:	01 f0       	ld.ub	r0,r0[0x7]
8000558c:	80 00       	ld.sh	r0,r0[0x0]
8000558e:	4e d4       	lddpc	r4,80005740 <_fwalk+0x4>
80005590:	00 00       	add	r0,r0
80005592:	05 fc       	ld.ub	r12,r2[0x7]
80005594:	00 00       	add	r0,r0
80005596:	09 d4       	ld.ub	r4,r4[0x5]
80005598:	80 00       	ld.sh	r0,r0[0x0]
8000559a:	42 dc       	lddsp	r12,sp[0xb4]

8000559c <_free_r>:
8000559c:	d4 21       	pushm	r4-r7,lr
8000559e:	16 96       	mov	r6,r11
800055a0:	18 97       	mov	r7,r12
800055a2:	58 0b       	cp.w	r11,0
800055a4:	e0 80 00 c8 	breq	80005734 <_free_r+0x198>
800055a8:	f0 1f 00 4c 	mcall	800056d8 <_free_r+0x13c>
800055ac:	20 86       	sub	r6,8
800055ae:	4c ca       	lddpc	r10,800056dc <_free_r+0x140>
800055b0:	6c 18       	ld.w	r8,r6[0x4]
800055b2:	74 2e       	ld.w	lr,r10[0x8]
800055b4:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
800055b8:	a1 c8       	cbr	r8,0x0
800055ba:	ec 08 00 09 	add	r9,r6,r8
800055be:	72 1b       	ld.w	r11,r9[0x4]
800055c0:	e0 1b ff fc 	andl	r11,0xfffc
800055c4:	1c 39       	cp.w	r9,lr
800055c6:	c1 d1       	brne	80005600 <_free_r+0x64>
800055c8:	f6 08 00 08 	add	r8,r11,r8
800055cc:	58 0c       	cp.w	r12,0
800055ce:	c0 81       	brne	800055de <_free_r+0x42>
800055d0:	6c 09       	ld.w	r9,r6[0x0]
800055d2:	12 16       	sub	r6,r9
800055d4:	12 08       	add	r8,r9
800055d6:	6c 3b       	ld.w	r11,r6[0xc]
800055d8:	6c 29       	ld.w	r9,r6[0x8]
800055da:	97 29       	st.w	r11[0x8],r9
800055dc:	93 3b       	st.w	r9[0xc],r11
800055de:	10 99       	mov	r9,r8
800055e0:	95 26       	st.w	r10[0x8],r6
800055e2:	a1 a9       	sbr	r9,0x0
800055e4:	8d 19       	st.w	r6[0x4],r9
800055e6:	4b f9       	lddpc	r9,800056e0 <_free_r+0x144>
800055e8:	72 09       	ld.w	r9,r9[0x0]
800055ea:	12 38       	cp.w	r8,r9
800055ec:	c0 63       	brcs	800055f8 <_free_r+0x5c>
800055ee:	4b e8       	lddpc	r8,800056e4 <_free_r+0x148>
800055f0:	0e 9c       	mov	r12,r7
800055f2:	70 0b       	ld.w	r11,r8[0x0]
800055f4:	f0 1f 00 3d 	mcall	800056e8 <_free_r+0x14c>
800055f8:	0e 9c       	mov	r12,r7
800055fa:	f0 1f 00 3d 	mcall	800056ec <_free_r+0x150>
800055fe:	d8 22       	popm	r4-r7,pc
80005600:	93 1b       	st.w	r9[0x4],r11
80005602:	58 0c       	cp.w	r12,0
80005604:	c0 30       	breq	8000560a <_free_r+0x6e>
80005606:	30 0c       	mov	r12,0
80005608:	c1 08       	rjmp	80005628 <_free_r+0x8c>
8000560a:	6c 0e       	ld.w	lr,r6[0x0]
8000560c:	f4 c5 ff f8 	sub	r5,r10,-8
80005610:	1c 16       	sub	r6,lr
80005612:	1c 08       	add	r8,lr
80005614:	6c 2e       	ld.w	lr,r6[0x8]
80005616:	0a 3e       	cp.w	lr,r5
80005618:	f9 bc 00 01 	moveq	r12,1
8000561c:	ed f5 10 03 	ld.wne	r5,r6[0xc]
80005620:	eb fe 1a 02 	st.wne	r5[0x8],lr
80005624:	fd f5 1a 03 	st.wne	lr[0xc],r5
80005628:	f2 0b 00 0e 	add	lr,r9,r11
8000562c:	7c 1e       	ld.w	lr,lr[0x4]
8000562e:	ed be 00 00 	bld	lr,0x0
80005632:	c1 30       	breq	80005658 <_free_r+0xbc>
80005634:	16 08       	add	r8,r11
80005636:	58 0c       	cp.w	r12,0
80005638:	c0 c1       	brne	80005650 <_free_r+0xb4>
8000563a:	4a 9e       	lddpc	lr,800056dc <_free_r+0x140>
8000563c:	72 2b       	ld.w	r11,r9[0x8]
8000563e:	2f 8e       	sub	lr,-8
80005640:	1c 3b       	cp.w	r11,lr
80005642:	c0 71       	brne	80005650 <_free_r+0xb4>
80005644:	97 36       	st.w	r11[0xc],r6
80005646:	97 26       	st.w	r11[0x8],r6
80005648:	8d 2b       	st.w	r6[0x8],r11
8000564a:	8d 3b       	st.w	r6[0xc],r11
8000564c:	30 1c       	mov	r12,1
8000564e:	c0 58       	rjmp	80005658 <_free_r+0xbc>
80005650:	72 2b       	ld.w	r11,r9[0x8]
80005652:	72 39       	ld.w	r9,r9[0xc]
80005654:	93 2b       	st.w	r9[0x8],r11
80005656:	97 39       	st.w	r11[0xc],r9
80005658:	10 99       	mov	r9,r8
8000565a:	ec 08 09 08 	st.w	r6[r8],r8
8000565e:	a1 a9       	sbr	r9,0x0
80005660:	8d 19       	st.w	r6[0x4],r9
80005662:	58 0c       	cp.w	r12,0
80005664:	c6 51       	brne	8000572e <_free_r+0x192>
80005666:	e0 48 01 ff 	cp.w	r8,511
8000566a:	e0 8b 00 13 	brhi	80005690 <_free_r+0xf4>
8000566e:	a3 98       	lsr	r8,0x3
80005670:	f4 08 00 39 	add	r9,r10,r8<<0x3
80005674:	72 2b       	ld.w	r11,r9[0x8]
80005676:	8d 39       	st.w	r6[0xc],r9
80005678:	8d 2b       	st.w	r6[0x8],r11
8000567a:	97 36       	st.w	r11[0xc],r6
8000567c:	93 26       	st.w	r9[0x8],r6
8000567e:	a3 48       	asr	r8,0x2
80005680:	74 19       	ld.w	r9,r10[0x4]
80005682:	30 1b       	mov	r11,1
80005684:	f6 08 09 48 	lsl	r8,r11,r8
80005688:	f3 e8 10 08 	or	r8,r9,r8
8000568c:	95 18       	st.w	r10[0x4],r8
8000568e:	c5 08       	rjmp	8000572e <_free_r+0x192>
80005690:	f0 0b 16 09 	lsr	r11,r8,0x9
80005694:	58 4b       	cp.w	r11,4
80005696:	e0 8b 00 06 	brhi	800056a2 <_free_r+0x106>
8000569a:	f0 0b 16 06 	lsr	r11,r8,0x6
8000569e:	2c 8b       	sub	r11,-56
800056a0:	c2 b8       	rjmp	800056f6 <_free_r+0x15a>
800056a2:	59 4b       	cp.w	r11,20
800056a4:	e0 8b 00 04 	brhi	800056ac <_free_r+0x110>
800056a8:	2a 5b       	sub	r11,-91
800056aa:	c2 68       	rjmp	800056f6 <_free_r+0x15a>
800056ac:	e0 4b 00 54 	cp.w	r11,84
800056b0:	e0 8b 00 06 	brhi	800056bc <_free_r+0x120>
800056b4:	f0 0b 16 0c 	lsr	r11,r8,0xc
800056b8:	29 2b       	sub	r11,-110
800056ba:	c1 e8       	rjmp	800056f6 <_free_r+0x15a>
800056bc:	e0 4b 01 54 	cp.w	r11,340
800056c0:	e0 8b 00 06 	brhi	800056cc <_free_r+0x130>
800056c4:	f0 0b 16 0f 	lsr	r11,r8,0xf
800056c8:	28 9b       	sub	r11,-119
800056ca:	c1 68       	rjmp	800056f6 <_free_r+0x15a>
800056cc:	e0 4b 05 54 	cp.w	r11,1364
800056d0:	e0 88 00 10 	brls	800056f0 <_free_r+0x154>
800056d4:	37 eb       	mov	r11,126
800056d6:	c1 08       	rjmp	800056f6 <_free_r+0x15a>
800056d8:	80 00       	ld.sh	r0,r0[0x0]
800056da:	42 d0       	lddsp	r0,sp[0xb4]
800056dc:	00 00       	add	r0,r0
800056de:	01 f0       	ld.ub	r0,r0[0x7]
800056e0:	00 00       	add	r0,r0
800056e2:	05 f8       	ld.ub	r8,r2[0x7]
800056e4:	00 00       	add	r0,r0
800056e6:	09 d0       	ld.ub	r0,r4[0x5]
800056e8:	80 00       	ld.sh	r0,r0[0x0]
800056ea:	54 f4       	stdsp	sp[0x13c],r4
800056ec:	80 00       	ld.sh	r0,r0[0x0]
800056ee:	42 dc       	lddsp	r12,sp[0xb4]
800056f0:	f0 0b 16 12 	lsr	r11,r8,0x12
800056f4:	28 4b       	sub	r11,-124
800056f6:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
800056fa:	78 29       	ld.w	r9,r12[0x8]
800056fc:	18 39       	cp.w	r9,r12
800056fe:	c0 e1       	brne	8000571a <_free_r+0x17e>
80005700:	74 18       	ld.w	r8,r10[0x4]
80005702:	a3 4b       	asr	r11,0x2
80005704:	30 1c       	mov	r12,1
80005706:	f8 0b 09 4b 	lsl	r11,r12,r11
8000570a:	f1 eb 10 0b 	or	r11,r8,r11
8000570e:	12 98       	mov	r8,r9
80005710:	95 1b       	st.w	r10[0x4],r11
80005712:	c0 a8       	rjmp	80005726 <_free_r+0x18a>
80005714:	72 29       	ld.w	r9,r9[0x8]
80005716:	18 39       	cp.w	r9,r12
80005718:	c0 60       	breq	80005724 <_free_r+0x188>
8000571a:	72 1a       	ld.w	r10,r9[0x4]
8000571c:	e0 1a ff fc 	andl	r10,0xfffc
80005720:	14 38       	cp.w	r8,r10
80005722:	cf 93       	brcs	80005714 <_free_r+0x178>
80005724:	72 38       	ld.w	r8,r9[0xc]
80005726:	8d 38       	st.w	r6[0xc],r8
80005728:	8d 29       	st.w	r6[0x8],r9
8000572a:	93 36       	st.w	r9[0xc],r6
8000572c:	91 26       	st.w	r8[0x8],r6
8000572e:	0e 9c       	mov	r12,r7
80005730:	f0 1f 00 02 	mcall	80005738 <_free_r+0x19c>
80005734:	d8 22       	popm	r4-r7,pc
80005736:	00 00       	add	r0,r0
80005738:	80 00       	ld.sh	r0,r0[0x0]
8000573a:	42 dc       	lddsp	r12,sp[0xb4]

8000573c <_fwalk>:
8000573c:	d4 31       	pushm	r0-r7,lr
8000573e:	30 05       	mov	r5,0
80005740:	16 91       	mov	r1,r11
80005742:	f8 c7 ff 28 	sub	r7,r12,-216
80005746:	0a 92       	mov	r2,r5
80005748:	f0 1f 00 10 	mcall	80005788 <_fwalk+0x4c>
8000574c:	3f f3       	mov	r3,-1
8000574e:	c1 68       	rjmp	8000577a <_fwalk+0x3e>
80005750:	6e 26       	ld.w	r6,r7[0x8]
80005752:	6e 14       	ld.w	r4,r7[0x4]
80005754:	2f 46       	sub	r6,-12
80005756:	c0 c8       	rjmp	8000576e <_fwalk+0x32>
80005758:	8c 08       	ld.sh	r8,r6[0x0]
8000575a:	e4 08 19 00 	cp.h	r8,r2
8000575e:	c0 70       	breq	8000576c <_fwalk+0x30>
80005760:	8c 18       	ld.sh	r8,r6[0x2]
80005762:	e6 08 19 00 	cp.h	r8,r3
80005766:	c0 30       	breq	8000576c <_fwalk+0x30>
80005768:	5d 11       	icall	r1
8000576a:	18 45       	or	r5,r12
8000576c:	2a 46       	sub	r6,-92
8000576e:	20 14       	sub	r4,1
80005770:	ec cc 00 0c 	sub	r12,r6,12
80005774:	58 04       	cp.w	r4,0
80005776:	cf 14       	brge	80005758 <_fwalk+0x1c>
80005778:	6e 07       	ld.w	r7,r7[0x0]
8000577a:	58 07       	cp.w	r7,0
8000577c:	ce a1       	brne	80005750 <_fwalk+0x14>
8000577e:	f0 1f 00 04 	mcall	8000578c <_fwalk+0x50>
80005782:	0a 9c       	mov	r12,r5
80005784:	d8 32       	popm	r0-r7,pc
80005786:	00 00       	add	r0,r0
80005788:	80 00       	ld.sh	r0,r0[0x0]
8000578a:	53 80       	stdsp	sp[0xe0],r0
8000578c:	80 00       	ld.sh	r0,r0[0x0]
8000578e:	53 82       	stdsp	sp[0xe0],r2

80005790 <__sclose>:
80005790:	d4 01       	pushm	lr
80005792:	96 7b       	ld.sh	r11,r11[0xe]
80005794:	f0 1f 00 02 	mcall	8000579c <__sclose+0xc>
80005798:	d8 02       	popm	pc
8000579a:	00 00       	add	r0,r0
8000579c:	80 00       	ld.sh	r0,r0[0x0]
8000579e:	58 50       	cp.w	r0,5

800057a0 <__sseek>:
800057a0:	d4 21       	pushm	r4-r7,lr
800057a2:	16 97       	mov	r7,r11
800057a4:	96 7b       	ld.sh	r11,r11[0xe]
800057a6:	f0 1f 00 08 	mcall	800057c4 <__sseek+0x24>
800057aa:	8e 68       	ld.sh	r8,r7[0xc]
800057ac:	10 99       	mov	r9,r8
800057ae:	ad c8       	cbr	r8,0xc
800057b0:	ad a9       	sbr	r9,0xc
800057b2:	5b fc       	cp.w	r12,-1
800057b4:	ef f8 0c 06 	st.heq	r7[0xc],r8
800057b8:	ef f9 1c 06 	st.hne	r7[0xc],r9
800057bc:	ef fc 1a 15 	st.wne	r7[0x54],r12
800057c0:	d8 22       	popm	r4-r7,pc
800057c2:	00 00       	add	r0,r0
800057c4:	80 00       	ld.sh	r0,r0[0x0]
800057c6:	59 60       	cp.w	r0,22

800057c8 <__swrite>:
800057c8:	d4 21       	pushm	r4-r7,lr
800057ca:	96 68       	ld.sh	r8,r11[0xc]
800057cc:	16 97       	mov	r7,r11
800057ce:	14 95       	mov	r5,r10
800057d0:	12 94       	mov	r4,r9
800057d2:	e2 18 01 00 	andl	r8,0x100,COH
800057d6:	18 96       	mov	r6,r12
800057d8:	c0 60       	breq	800057e4 <__swrite+0x1c>
800057da:	30 29       	mov	r9,2
800057dc:	30 0a       	mov	r10,0
800057de:	96 7b       	ld.sh	r11,r11[0xe]
800057e0:	f0 1f 00 06 	mcall	800057f8 <__swrite+0x30>
800057e4:	8e 68       	ld.sh	r8,r7[0xc]
800057e6:	ad c8       	cbr	r8,0xc
800057e8:	08 99       	mov	r9,r4
800057ea:	0a 9a       	mov	r10,r5
800057ec:	8e 7b       	ld.sh	r11,r7[0xe]
800057ee:	0c 9c       	mov	r12,r6
800057f0:	ae 68       	st.h	r7[0xc],r8
800057f2:	f0 1f 00 03 	mcall	800057fc <__swrite+0x34>
800057f6:	d8 22       	popm	r4-r7,pc
800057f8:	80 00       	ld.sh	r0,r0[0x0]
800057fa:	59 60       	cp.w	r0,22
800057fc:	80 00       	ld.sh	r0,r0[0x0]
800057fe:	58 24       	cp.w	r4,2

80005800 <__sread>:
80005800:	d4 21       	pushm	r4-r7,lr
80005802:	16 97       	mov	r7,r11
80005804:	96 7b       	ld.sh	r11,r11[0xe]
80005806:	f0 1f 00 07 	mcall	80005820 <__sread+0x20>
8000580a:	c0 65       	brlt	80005816 <__sread+0x16>
8000580c:	6f 58       	ld.w	r8,r7[0x54]
8000580e:	18 08       	add	r8,r12
80005810:	ef 48 00 54 	st.w	r7[84],r8
80005814:	d8 22       	popm	r4-r7,pc
80005816:	8e 68       	ld.sh	r8,r7[0xc]
80005818:	ad c8       	cbr	r8,0xc
8000581a:	ae 68       	st.h	r7[0xc],r8
8000581c:	d8 22       	popm	r4-r7,pc
8000581e:	00 00       	add	r0,r0
80005820:	80 00       	ld.sh	r0,r0[0x0]
80005822:	59 8c       	cp.w	r12,24

80005824 <_write_r>:
80005824:	d4 21       	pushm	r4-r7,lr
80005826:	16 98       	mov	r8,r11
80005828:	18 97       	mov	r7,r12
8000582a:	10 9c       	mov	r12,r8
8000582c:	30 08       	mov	r8,0
8000582e:	14 9b       	mov	r11,r10
80005830:	48 66       	lddpc	r6,80005848 <_write_r+0x24>
80005832:	12 9a       	mov	r10,r9
80005834:	8d 08       	st.w	r6[0x0],r8
80005836:	f0 1f 00 06 	mcall	8000584c <_write_r+0x28>
8000583a:	5b fc       	cp.w	r12,-1
8000583c:	c0 51       	brne	80005846 <_write_r+0x22>
8000583e:	6c 08       	ld.w	r8,r6[0x0]
80005840:	58 08       	cp.w	r8,0
80005842:	ef f8 1a 03 	st.wne	r7[0xc],r8
80005846:	d8 22       	popm	r4-r7,pc
80005848:	00 00       	add	r0,r0
8000584a:	0a 2c       	rsub	r12,r5
8000584c:	80 00       	ld.sh	r0,r0[0x0]
8000584e:	3f ec       	mov	r12,-2

80005850 <_close_r>:
80005850:	d4 21       	pushm	r4-r7,lr
80005852:	30 08       	mov	r8,0
80005854:	18 97       	mov	r7,r12
80005856:	48 76       	lddpc	r6,80005870 <_close_r+0x20>
80005858:	16 9c       	mov	r12,r11
8000585a:	8d 08       	st.w	r6[0x0],r8
8000585c:	f0 1f 00 06 	mcall	80005874 <_close_r+0x24>
80005860:	5b fc       	cp.w	r12,-1
80005862:	c0 51       	brne	8000586c <_close_r+0x1c>
80005864:	6c 08       	ld.w	r8,r6[0x0]
80005866:	58 08       	cp.w	r8,0
80005868:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000586c:	d8 22       	popm	r4-r7,pc
8000586e:	00 00       	add	r0,r0
80005870:	00 00       	add	r0,r0
80005872:	0a 2c       	rsub	r12,r5
80005874:	80 00       	ld.sh	r0,r0[0x0]
80005876:	50 6c       	stdsp	sp[0x18],r12

80005878 <_fclose_r>:
80005878:	d4 21       	pushm	r4-r7,lr
8000587a:	18 96       	mov	r6,r12
8000587c:	16 97       	mov	r7,r11
8000587e:	58 0b       	cp.w	r11,0
80005880:	c0 31       	brne	80005886 <_fclose_r+0xe>
80005882:	16 95       	mov	r5,r11
80005884:	c5 08       	rjmp	80005924 <_fclose_r+0xac>
80005886:	f0 1f 00 29 	mcall	80005928 <_fclose_r+0xb0>
8000588a:	58 06       	cp.w	r6,0
8000588c:	c0 70       	breq	8000589a <_fclose_r+0x22>
8000588e:	6c 68       	ld.w	r8,r6[0x18]
80005890:	58 08       	cp.w	r8,0
80005892:	c0 41       	brne	8000589a <_fclose_r+0x22>
80005894:	0c 9c       	mov	r12,r6
80005896:	f0 1f 00 26 	mcall	8000592c <_fclose_r+0xb4>
8000589a:	4a 68       	lddpc	r8,80005930 <_fclose_r+0xb8>
8000589c:	10 37       	cp.w	r7,r8
8000589e:	c0 31       	brne	800058a4 <_fclose_r+0x2c>
800058a0:	6c 07       	ld.w	r7,r6[0x0]
800058a2:	c0 a8       	rjmp	800058b6 <_fclose_r+0x3e>
800058a4:	4a 48       	lddpc	r8,80005934 <_fclose_r+0xbc>
800058a6:	10 37       	cp.w	r7,r8
800058a8:	c0 31       	brne	800058ae <_fclose_r+0x36>
800058aa:	6c 17       	ld.w	r7,r6[0x4]
800058ac:	c0 58       	rjmp	800058b6 <_fclose_r+0x3e>
800058ae:	4a 38       	lddpc	r8,80005938 <_fclose_r+0xc0>
800058b0:	10 37       	cp.w	r7,r8
800058b2:	ed f7 00 02 	ld.weq	r7,r6[0x8]
800058b6:	8e 69       	ld.sh	r9,r7[0xc]
800058b8:	30 08       	mov	r8,0
800058ba:	f0 09 19 00 	cp.h	r9,r8
800058be:	c0 51       	brne	800058c8 <_fclose_r+0x50>
800058c0:	f0 1f 00 1f 	mcall	8000593c <_fclose_r+0xc4>
800058c4:	30 05       	mov	r5,0
800058c6:	c2 f8       	rjmp	80005924 <_fclose_r+0xac>
800058c8:	0e 9b       	mov	r11,r7
800058ca:	0c 9c       	mov	r12,r6
800058cc:	f0 1f 00 1d 	mcall	80005940 <_fclose_r+0xc8>
800058d0:	6e c8       	ld.w	r8,r7[0x30]
800058d2:	18 95       	mov	r5,r12
800058d4:	58 08       	cp.w	r8,0
800058d6:	c0 60       	breq	800058e2 <_fclose_r+0x6a>
800058d8:	6e 8b       	ld.w	r11,r7[0x20]
800058da:	0c 9c       	mov	r12,r6
800058dc:	5d 18       	icall	r8
800058de:	f9 b5 05 ff 	movlt	r5,-1
800058e2:	8e 68       	ld.sh	r8,r7[0xc]
800058e4:	ed b8 00 07 	bld	r8,0x7
800058e8:	c0 51       	brne	800058f2 <_fclose_r+0x7a>
800058ea:	6e 4b       	ld.w	r11,r7[0x10]
800058ec:	0c 9c       	mov	r12,r6
800058ee:	f0 1f 00 16 	mcall	80005944 <_fclose_r+0xcc>
800058f2:	6e db       	ld.w	r11,r7[0x34]
800058f4:	58 0b       	cp.w	r11,0
800058f6:	c0 a0       	breq	8000590a <_fclose_r+0x92>
800058f8:	ee c8 ff bc 	sub	r8,r7,-68
800058fc:	10 3b       	cp.w	r11,r8
800058fe:	c0 40       	breq	80005906 <_fclose_r+0x8e>
80005900:	0c 9c       	mov	r12,r6
80005902:	f0 1f 00 11 	mcall	80005944 <_fclose_r+0xcc>
80005906:	30 08       	mov	r8,0
80005908:	8f d8       	st.w	r7[0x34],r8
8000590a:	6f 2b       	ld.w	r11,r7[0x48]
8000590c:	58 0b       	cp.w	r11,0
8000590e:	c0 70       	breq	8000591c <_fclose_r+0xa4>
80005910:	0c 9c       	mov	r12,r6
80005912:	f0 1f 00 0d 	mcall	80005944 <_fclose_r+0xcc>
80005916:	30 08       	mov	r8,0
80005918:	ef 48 00 48 	st.w	r7[72],r8
8000591c:	30 08       	mov	r8,0
8000591e:	ae 68       	st.h	r7[0xc],r8
80005920:	f0 1f 00 07 	mcall	8000593c <_fclose_r+0xc4>
80005924:	0a 9c       	mov	r12,r5
80005926:	d8 22       	popm	r4-r7,pc
80005928:	80 00       	ld.sh	r0,r0[0x0]
8000592a:	53 80       	stdsp	sp[0xe0],r0
8000592c:	80 00       	ld.sh	r0,r0[0x0]
8000592e:	54 44       	stdsp	sp[0x110],r4
80005930:	80 00       	ld.sh	r0,r0[0x0]
80005932:	5d 18       	icall	r8
80005934:	80 00       	ld.sh	r0,r0[0x0]
80005936:	5d 38       	musfr	r8
80005938:	80 00       	ld.sh	r0,r0[0x0]
8000593a:	5d 58       	*unknown*
8000593c:	80 00       	ld.sh	r0,r0[0x0]
8000593e:	53 82       	stdsp	sp[0xe0],r2
80005940:	80 00       	ld.sh	r0,r0[0x0]
80005942:	52 68       	stdsp	sp[0x98],r8
80005944:	80 00       	ld.sh	r0,r0[0x0]
80005946:	55 9c       	stdsp	sp[0x164],r12

80005948 <fclose>:
80005948:	d4 01       	pushm	lr
8000594a:	48 48       	lddpc	r8,80005958 <fclose+0x10>
8000594c:	18 9b       	mov	r11,r12
8000594e:	70 0c       	ld.w	r12,r8[0x0]
80005950:	f0 1f 00 03 	mcall	8000595c <fclose+0x14>
80005954:	d8 02       	popm	pc
80005956:	00 00       	add	r0,r0
80005958:	00 00       	add	r0,r0
8000595a:	01 ec       	ld.ub	r12,r0[0x6]
8000595c:	80 00       	ld.sh	r0,r0[0x0]
8000595e:	58 78       	cp.w	r8,7

80005960 <_lseek_r>:
80005960:	d4 21       	pushm	r4-r7,lr
80005962:	16 98       	mov	r8,r11
80005964:	18 97       	mov	r7,r12
80005966:	10 9c       	mov	r12,r8
80005968:	30 08       	mov	r8,0
8000596a:	14 9b       	mov	r11,r10
8000596c:	48 66       	lddpc	r6,80005984 <_lseek_r+0x24>
8000596e:	12 9a       	mov	r10,r9
80005970:	8d 08       	st.w	r6[0x0],r8
80005972:	f0 1f 00 06 	mcall	80005988 <_lseek_r+0x28>
80005976:	5b fc       	cp.w	r12,-1
80005978:	c0 51       	brne	80005982 <_lseek_r+0x22>
8000597a:	6c 08       	ld.w	r8,r6[0x0]
8000597c:	58 08       	cp.w	r8,0
8000597e:	ef f8 1a 03 	st.wne	r7[0xc],r8
80005982:	d8 22       	popm	r4-r7,pc
80005984:	00 00       	add	r0,r0
80005986:	0a 2c       	rsub	r12,r5
80005988:	80 00       	ld.sh	r0,r0[0x0]
8000598a:	50 84       	stdsp	sp[0x20],r4

8000598c <_read_r>:
8000598c:	d4 21       	pushm	r4-r7,lr
8000598e:	16 98       	mov	r8,r11
80005990:	18 97       	mov	r7,r12
80005992:	10 9c       	mov	r12,r8
80005994:	30 08       	mov	r8,0
80005996:	14 9b       	mov	r11,r10
80005998:	48 66       	lddpc	r6,800059b0 <_read_r+0x24>
8000599a:	12 9a       	mov	r10,r9
8000599c:	8d 08       	st.w	r6[0x0],r8
8000599e:	f0 1f 00 06 	mcall	800059b4 <_read_r+0x28>
800059a2:	5b fc       	cp.w	r12,-1
800059a4:	c0 51       	brne	800059ae <_read_r+0x22>
800059a6:	6c 08       	ld.w	r8,r6[0x0]
800059a8:	58 08       	cp.w	r8,0
800059aa:	ef f8 1a 03 	st.wne	r7[0xc],r8
800059ae:	d8 22       	popm	r4-r7,pc
800059b0:	00 00       	add	r0,r0
800059b2:	0a 2c       	rsub	r12,r5
800059b4:	80 00       	ld.sh	r0,r0[0x0]
800059b6:	3e d0       	mov	r0,-19

800059b8 <__do_global_ctors_aux>:
800059b8:	d4 21       	pushm	r4-r7,lr
800059ba:	48 57       	lddpc	r7,800059cc <__do_global_ctors_aux+0x14>
800059bc:	c0 28       	rjmp	800059c0 <__do_global_ctors_aux+0x8>
800059be:	5d 18       	icall	r8
800059c0:	20 47       	sub	r7,4
800059c2:	6e 08       	ld.w	r8,r7[0x0]
800059c4:	5b f8       	cp.w	r8,-1
800059c6:	cf c1       	brne	800059be <__do_global_ctors_aux+0x6>
800059c8:	d8 22       	popm	r4-r7,pc
800059ca:	00 00       	add	r0,r0
800059cc:	00 00       	add	r0,r0
800059ce:	00 0c       	add	r12,r0

Disassembly of section .exception:

80005a00 <_evba>:
80005a00:	c0 08       	rjmp	80005a00 <_evba>
	...

80005a04 <_handle_TLB_Multiple_Hit>:
80005a04:	c0 08       	rjmp	80005a04 <_handle_TLB_Multiple_Hit>
	...

80005a08 <_handle_Bus_Error_Data_Fetch>:
80005a08:	c0 08       	rjmp	80005a08 <_handle_Bus_Error_Data_Fetch>
	...

80005a0c <_handle_Bus_Error_Instruction_Fetch>:
80005a0c:	c0 08       	rjmp	80005a0c <_handle_Bus_Error_Instruction_Fetch>
	...

80005a10 <_handle_NMI>:
80005a10:	c0 08       	rjmp	80005a10 <_handle_NMI>
	...

80005a14 <_handle_Instruction_Address>:
80005a14:	c0 08       	rjmp	80005a14 <_handle_Instruction_Address>
	...

80005a18 <_handle_ITLB_Protection>:
80005a18:	c0 08       	rjmp	80005a18 <_handle_ITLB_Protection>
	...

80005a1c <_handle_Breakpoint>:
80005a1c:	c0 08       	rjmp	80005a1c <_handle_Breakpoint>
	...

80005a20 <_handle_Illegal_Opcode>:
80005a20:	c0 08       	rjmp	80005a20 <_handle_Illegal_Opcode>
	...

80005a24 <_handle_Unimplemented_Instruction>:
80005a24:	c0 08       	rjmp	80005a24 <_handle_Unimplemented_Instruction>
	...

80005a28 <_handle_Privilege_Violation>:
80005a28:	c0 08       	rjmp	80005a28 <_handle_Privilege_Violation>
	...

80005a2c <_handle_Floating_Point>:
80005a2c:	c0 08       	rjmp	80005a2c <_handle_Floating_Point>
	...

80005a30 <_handle_Coprocessor_Absent>:
80005a30:	c0 08       	rjmp	80005a30 <_handle_Coprocessor_Absent>
	...

80005a34 <_handle_Data_Address_Read>:
80005a34:	c0 08       	rjmp	80005a34 <_handle_Data_Address_Read>
	...

80005a38 <_handle_Data_Address_Write>:
80005a38:	c0 08       	rjmp	80005a38 <_handle_Data_Address_Write>
	...

80005a3c <_handle_DTLB_Protection_Read>:
80005a3c:	c0 08       	rjmp	80005a3c <_handle_DTLB_Protection_Read>
	...

80005a40 <_handle_DTLB_Protection_Write>:
80005a40:	c0 08       	rjmp	80005a40 <_handle_DTLB_Protection_Write>
	...

80005a44 <_handle_DTLB_Modified>:
80005a44:	c0 08       	rjmp	80005a44 <_handle_DTLB_Modified>
	...

80005a50 <_handle_ITLB_Miss>:
80005a50:	c0 08       	rjmp	80005a50 <_handle_ITLB_Miss>
	...

80005a60 <_handle_DTLB_Miss_Read>:
80005a60:	c0 08       	rjmp	80005a60 <_handle_DTLB_Miss_Read>
	...

80005a70 <_handle_DTLB_Miss_Write>:
80005a70:	c0 08       	rjmp	80005a70 <_handle_DTLB_Miss_Write>
	...

80005b00 <_handle_Supervisor_Call>:
80005b00:	49 3f       	lddpc	pc,80005b4c <ipr_val+0x10>
	...

80005b04 <_int0>:
80005b04:	30 0c       	mov	r12,0
80005b06:	f0 1f 00 13 	mcall	80005b50 <ipr_val+0x14>
80005b0a:	58 0c       	cp.w	r12,0
80005b0c:	f8 0f 17 10 	movne	pc,r12
80005b10:	d6 03       	rete

80005b12 <_int1>:
80005b12:	30 1c       	mov	r12,1
80005b14:	f0 1f 00 0f 	mcall	80005b50 <ipr_val+0x14>
80005b18:	58 0c       	cp.w	r12,0
80005b1a:	f8 0f 17 10 	movne	pc,r12
80005b1e:	d6 03       	rete

80005b20 <_int2>:
80005b20:	30 2c       	mov	r12,2
80005b22:	f0 1f 00 0c 	mcall	80005b50 <ipr_val+0x14>
80005b26:	58 0c       	cp.w	r12,0
80005b28:	f8 0f 17 10 	movne	pc,r12
80005b2c:	d6 03       	rete

80005b2e <_int3>:
80005b2e:	30 3c       	mov	r12,3
80005b30:	f0 1f 00 08 	mcall	80005b50 <ipr_val+0x14>
80005b34:	58 0c       	cp.w	r12,0
80005b36:	f8 0f 17 10 	movne	pc,r12
80005b3a:	d6 03       	rete

80005b3c <ipr_val>:
80005b3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
80005b4c:	80 00 41 88 80 00 22 bc 00 00 00 00 00 00 00 00     ..A...".........
	...

Disassembly of section .fini:

80005c00 <_fini>:
80005c00:	eb cd 40 40 	pushm	r6,lr
80005c04:	48 26       	lddpc	r6,80005c0c <_fini+0xc>
80005c06:	1e 26       	rsub	r6,pc
80005c08:	c0 48       	rjmp	80005c10 <_fini+0x10>
80005c0a:	00 00       	add	r0,r0
80005c0c:	80 00       	ld.sh	r0,r0[0x0]
80005c0e:	5b ea       	cp.w	r10,-2
80005c10:	f0 16 00 02 	mcall	r6[8]
80005c14:	e3 cd 80 40 	ldm	sp++,r6,pc
